{"version":3,"file":"dexie-query.js","names":["INDEX_MAX","INDEX_MIN","getQueryMatcher","getSortComparator","dexieReplaceIfStartsWithPipe","DEXIE_DOCS_TABLE_NAME","fromDexieToStorage","mapKeyForKeyRange","k","Infinity","rangeFieldToBooleanSubstitute","booleanIndexes","fieldName","value","includes","newValue","getKeyRangeByQueryPlan","queryPlan","IDBKeyRange","window","Error","startKeys","map","v","i","index","endKeys","keyRange","bound","inclusiveStart","inclusiveEnd","dexieQuery","instance","preparedQuery","state","internals","query","skip","limit","skipPlusLimit","queryMatcher","selectorSatisfiedByIndex","schema","dexieDb","_options","queryPlanFields","rows","transaction","dexieTable","dexieTx","tx","idbtrans","store","objectStore","indexName","field","join","cursorReq","openCursor","Promise","res","onsuccess","e","cursor","target","result","docData","push","sortSatisfiedByIndex","length","continue","sortComparator","sort","slice","documents","dexieCount","count","request","rej","onerror","err"],"sources":["../../../../src/plugins/storage-dexie/dexie-query.ts"],"sourcesContent":["import { INDEX_MAX, INDEX_MIN } from '../../query-planner.ts';\r\nimport { getQueryMatcher, getSortComparator } from '../../rx-query-helper.ts';\r\nimport type {\r\n    PreparedQuery,\r\n    QueryMatcher,\r\n    RxDocumentData,\r\n    RxQueryPlan,\r\n    RxStorageQueryResult\r\n} from '../../types/index.d.ts';\r\nimport {\r\n    dexieReplaceIfStartsWithPipe,\r\n    DEXIE_DOCS_TABLE_NAME,\r\n    fromDexieToStorage\r\n} from './dexie-helper.ts';\r\nimport type { RxStorageInstanceDexie } from './rx-storage-instance-dexie.ts';\r\n\r\nexport function mapKeyForKeyRange(k: any) {\r\n    if (k === INDEX_MIN) {\r\n        return -Infinity;\r\n    } else {\r\n        return k;\r\n    }\r\n}\r\n\r\nfunction rangeFieldToBooleanSubstitute(\r\n    booleanIndexes: string[],\r\n    fieldName: string,\r\n    value: any\r\n) {\r\n    if (booleanIndexes.includes(fieldName)) {\r\n        const newValue = value === INDEX_MAX || value === true ? '1' : '0';\r\n        return newValue;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\nexport function getKeyRangeByQueryPlan(\r\n    booleanIndexes: string[],\r\n    queryPlan: RxQueryPlan,\r\n    IDBKeyRange?: any\r\n) {\r\n    if (!IDBKeyRange) {\r\n        if (typeof window === 'undefined') {\r\n            throw new Error('IDBKeyRange missing');\r\n        } else {\r\n            IDBKeyRange = window.IDBKeyRange;\r\n        }\r\n    }\r\n\r\n    const startKeys = queryPlan.startKeys\r\n        .map((v, i) => {\r\n            const fieldName = queryPlan.index[i];\r\n            return rangeFieldToBooleanSubstitute(booleanIndexes, fieldName, v);\r\n        })\r\n        .map(mapKeyForKeyRange);\r\n    const endKeys = queryPlan.endKeys\r\n        .map((v, i) => {\r\n            const fieldName = queryPlan.index[i];\r\n            return rangeFieldToBooleanSubstitute(booleanIndexes, fieldName, v);\r\n        })\r\n        .map(mapKeyForKeyRange);\r\n\r\n    const keyRange = IDBKeyRange.bound(\r\n        startKeys,\r\n        endKeys,\r\n        !queryPlan.inclusiveStart,\r\n        !queryPlan.inclusiveEnd\r\n    );\r\n    return keyRange;\r\n}\r\n\r\n\r\n/**\r\n * Runs mango queries over the Dexie.js database.\r\n */\r\nexport async function dexieQuery<RxDocType>(\r\n    instance: RxStorageInstanceDexie<RxDocType>,\r\n    preparedQuery: PreparedQuery<RxDocType>\r\n): Promise<RxStorageQueryResult<RxDocType>> {\r\n    const state = await instance.internals;\r\n    const query = preparedQuery.query;\r\n\r\n    const skip = query.skip ? query.skip : 0;\r\n    const limit = query.limit ? query.limit : Infinity;\r\n    const skipPlusLimit = skip + limit;\r\n    const queryPlan = preparedQuery.queryPlan;\r\n\r\n    let queryMatcher: QueryMatcher<RxDocumentData<RxDocType>> | false = false;\r\n    if (!queryPlan.selectorSatisfiedByIndex) {\r\n        queryMatcher = getQueryMatcher(\r\n            instance.schema,\r\n            preparedQuery.query\r\n        );\r\n    }\r\n    const keyRange = getKeyRangeByQueryPlan(\r\n        state.booleanIndexes,\r\n        queryPlan,\r\n        (state.dexieDb as any)._options.IDBKeyRange\r\n    );\r\n\r\n    const queryPlanFields: string[] = queryPlan.index;\r\n\r\n    let rows: any[] = [];\r\n    await state.dexieDb.transaction(\r\n        'r',\r\n        state.dexieTable,\r\n        async (dexieTx) => {\r\n            /**\r\n             * Here we use the native IndexedDB transaction\r\n             * to get the cursor.\r\n             * Maybe we should not leave Dexie.js API and find\r\n             * a way to create the cursor with Dexie.js.\r\n             */\r\n            const tx = (dexieTx as any).idbtrans;\r\n\r\n            // const nativeIndexedDB = state.dexieDb.backendDB();\r\n            // const trans = nativeIndexedDB.transaction([DEXIE_DOCS_TABLE_NAME], 'readonly');\r\n\r\n            const store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);\r\n            let index: any;\r\n            let indexName: string;\r\n            indexName = '[' +\r\n                queryPlanFields\r\n                    .map(field => dexieReplaceIfStartsWithPipe(field))\r\n                    .join('+')\r\n                + ']';\r\n            index = store.index(indexName);\r\n\r\n\r\n            const cursorReq = index.openCursor(keyRange);\r\n            await new Promise<void>(res => {\r\n                cursorReq.onsuccess = function (e: any) {\r\n                    const cursor = e.target.result;\r\n                    if (cursor) {\r\n                        // We have a record in cursor.value\r\n                        const docData = fromDexieToStorage<RxDocType>(state.booleanIndexes, cursor.value);\r\n                        if (!queryMatcher || queryMatcher(docData)) {\r\n                            rows.push(docData);\r\n                        }\r\n\r\n                        /**\r\n                         * If we do not have to manually sort\r\n                         * and have enough documents,\r\n                         * we can abort iterating over the cursor\r\n                         * because we already have every relevant document.\r\n                         */\r\n                        if (\r\n                            queryPlan.sortSatisfiedByIndex &&\r\n                            rows.length === skipPlusLimit\r\n                        ) {\r\n                            res();\r\n                        } else {\r\n                            cursor.continue();\r\n                        }\r\n                    } else {\r\n                        // Iteration complete\r\n                        res();\r\n                    }\r\n                };\r\n            });\r\n\r\n\r\n        }\r\n    );\r\n\r\n\r\n    if (!queryPlan.sortSatisfiedByIndex) {\r\n        const sortComparator = getSortComparator(instance.schema, preparedQuery.query);\r\n        rows = rows.sort(sortComparator);\r\n    }\r\n\r\n    // apply skip and limit boundaries.\r\n    rows = rows.slice(skip, skipPlusLimit);\r\n\r\n    /**\r\n     * Comment this in for debugging to check all fields in the database.\r\n     */\r\n    // const docsInDb = await state.dexieTable.filter(queryMatcher).toArray();\r\n    // let documents = docsInDb\r\n    //     .map(docData => stripDexieKey(docData))\r\n    //     .sort(sortComparator);\r\n    // if (preparedQuery.skip) {\r\n    //     documents = documents.slice(preparedQuery.skip);\r\n    // }\r\n    // if (preparedQuery.limit && documents.length > preparedQuery.limit) {\r\n    //     documents = documents.slice(0, preparedQuery.limit);\r\n    // }\r\n\r\n\r\n\r\n    return {\r\n        documents: rows\r\n    };\r\n}\r\n\r\n\r\nexport async function dexieCount<RxDocType>(\r\n    instance: RxStorageInstanceDexie<RxDocType>,\r\n    preparedQuery: PreparedQuery<RxDocType>\r\n): Promise<number> {\r\n    const state = await instance.internals;\r\n    const queryPlan = preparedQuery.queryPlan;\r\n    const queryPlanFields: string[] = queryPlan.index;\r\n\r\n    const keyRange = getKeyRangeByQueryPlan(\r\n        state.booleanIndexes,\r\n        queryPlan,\r\n        (state.dexieDb as any)._options.IDBKeyRange\r\n    );\r\n    let count: number = -1;\r\n    await state.dexieDb.transaction(\r\n        'r',\r\n        state.dexieTable,\r\n        async (dexieTx) => {\r\n            const tx = (dexieTx as any).idbtrans;\r\n            const store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);\r\n            let index: any;\r\n            let indexName: string;\r\n            indexName = '[' +\r\n                queryPlanFields\r\n                    .map(field => dexieReplaceIfStartsWithPipe(field))\r\n                    .join('+')\r\n                + ']';\r\n            index = store.index(indexName);\r\n            const request = index.count(keyRange);\r\n            count = await new Promise<number>((res, rej) => {\r\n                request.onsuccess = function () {\r\n                    res(request.result);\r\n                };\r\n                request.onerror = (err: any) => rej(err);\r\n            });\r\n        }\r\n    );\r\n    return count;\r\n}\r\n"],"mappings":"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","ignoreList":[]}