{"version":3,"file":"index.js","names":["ensureNotFalsy","errorToPlainJson","RxDBLeaderElectionPlugin","RxReplicationState","startReplicationOnLeaderShip","addRxPlugin","newRxError","Subject","connect","DeliverPolicy","JSONCodec","ReplayPolicy","getNatsServerDocumentState","awaitRetry","RxNatsReplicationState","_RxReplicationState","replicationIdentifier","collection","pull","push","live","retryTime","autoStart","_this","call","_inheritsLoose","replicateNats","options","waitForLeadership","primaryPath","schema","jc","connectionStatePromise","nc","connection","jetstreamClient","jetstream","jsm","jetstreamManager","streams","add","name","streamName","subjects","subjectPrefix","natsStream","get","pullStream$","replicationPrimitivesPull","handler","lastPulledCheckpoint","batchSize","cn","newCheckpoint","sequence","consumer","getConsumer","opt_start_seq","deliver_policy","LastPerSubject","replay_policy","Instant","fetchedMessages","fetch","max_messages","signal","close","useMessages","m","json","seq","ack","documents","checkpoint","modifier","stream$","asObservable","replicationPrimitivesPush","rows","conflicts","Promise","all","map","writeRow","docId","newDocumentState","remoteDocState","err","message","includes","assumedMasterState","conflictHandler","isEqual","pushDone","publish","encode","expect","lastSubjectSequence","undefined","newServerState","replicationState","error","next","document","startBefore","start","bind","cancelBefore","cancel","lastSeq","lastDocState","getMessage","last_by_subj","newMessages","consume","docData"],"sources":["../../../../src/plugins/replication-nats/index.ts"],"sourcesContent":["import {\r\n    ensureNotFalsy,\r\n    errorToPlainJson\r\n} from '../../plugins/utils/index.ts';\r\n\r\n\r\nimport { RxDBLeaderElectionPlugin } from '../leader-election/index.ts';\r\nimport type {\r\n    RxCollection,\r\n    ReplicationPullOptions,\r\n    ReplicationPushOptions,\r\n    RxReplicationWriteToMasterRow,\r\n    RxReplicationPullStreamItem\r\n} from '../../types/index.d.ts';\r\nimport {\r\n    RxReplicationState,\r\n    startReplicationOnLeaderShip\r\n} from '../replication/index.ts';\r\nimport {\r\n    addRxPlugin,\r\n    newRxError,\r\n    WithDeleted\r\n} from '../../index.ts';\r\n\r\nimport { Subject } from 'rxjs';\r\nimport type {\r\n    NatsCheckpointType,\r\n    NatsSyncOptions\r\n} from './nats-types.ts';\r\nimport { connect, DeliverPolicy, JSONCodec, ReplayPolicy } from 'nats';\r\nimport { getNatsServerDocumentState } from './nats-helper.ts';\r\nimport { awaitRetry } from '../replication/replication-helper.ts';\r\n\r\nexport * from './nats-types.ts';\r\nexport * from './nats-helper.ts';\r\n\r\n\r\nexport class RxNatsReplicationState<RxDocType> extends RxReplicationState<RxDocType, NatsCheckpointType> {\r\n    constructor(\r\n        public readonly replicationIdentifier: string,\r\n        public readonly collection: RxCollection<RxDocType>,\r\n        public readonly pull?: ReplicationPullOptions<RxDocType, NatsCheckpointType>,\r\n        public readonly push?: ReplicationPushOptions<RxDocType>,\r\n        public readonly live: boolean = true,\r\n        public retryTime: number = 1000 * 5,\r\n        public autoStart: boolean = true\r\n    ) {\r\n        super(\r\n            replicationIdentifier,\r\n            collection,\r\n            '_deleted',\r\n            pull,\r\n            push,\r\n            live,\r\n            retryTime,\r\n            autoStart\r\n        );\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function replicateNats<RxDocType>(\r\n    options: NatsSyncOptions<RxDocType>\r\n): RxNatsReplicationState<RxDocType> {\r\n    options.live = typeof options.live === 'undefined' ? true : options.live;\r\n    options.waitForLeadership = typeof options.waitForLeadership === 'undefined' ? true : options.waitForLeadership;\r\n\r\n    const collection: RxCollection<RxDocType> = options.collection;\r\n    const primaryPath = collection.schema.primaryPath;\r\n    addRxPlugin(RxDBLeaderElectionPlugin);\r\n\r\n    const jc = JSONCodec();\r\n\r\n\r\n    const connectionStatePromise = (async () => {\r\n        const nc = await connect(options.connection);\r\n        const jetstreamClient = nc.jetstream();\r\n        const jsm = await nc.jetstreamManager();\r\n        await jsm.streams.add({\r\n            name: options.streamName, subjects: [\r\n                options.subjectPrefix + '.*'\r\n            ]\r\n        });\r\n        const natsStream = await jetstreamClient.streams.get(options.streamName);\r\n        return {\r\n            nc,\r\n            jetstreamClient,\r\n            jsm,\r\n            natsStream\r\n        };\r\n    })();\r\n    const pullStream$: Subject<RxReplicationPullStreamItem<RxDocType, NatsCheckpointType>> = new Subject();\r\n\r\n    let replicationPrimitivesPull: ReplicationPullOptions<RxDocType, NatsCheckpointType> | undefined;\r\n    if (options.pull) {\r\n        replicationPrimitivesPull = {\r\n            async handler(\r\n                lastPulledCheckpoint: NatsCheckpointType | undefined,\r\n                batchSize: number\r\n            ) {\r\n                const cn = await connectionStatePromise;\r\n                const newCheckpoint: NatsCheckpointType = {\r\n                    sequence: lastPulledCheckpoint ? lastPulledCheckpoint.sequence : 0\r\n                };\r\n                const consumer = await cn.natsStream.getConsumer({\r\n                    opt_start_seq: lastPulledCheckpoint ? lastPulledCheckpoint.sequence : 0,\r\n                    deliver_policy: DeliverPolicy.LastPerSubject,\r\n                    replay_policy: ReplayPolicy.Instant\r\n                });\r\n\r\n                const fetchedMessages = await consumer.fetch({\r\n                    max_messages: batchSize\r\n                });\r\n                await (fetchedMessages as any).signal;\r\n                await fetchedMessages.close();\r\n\r\n                const useMessages: WithDeleted<RxDocType>[] = [];\r\n                for await (const m of fetchedMessages) {\r\n                    useMessages.push(m.json());\r\n                    newCheckpoint.sequence = m.seq;\r\n                    m.ack();\r\n                }\r\n                return {\r\n                    documents: useMessages,\r\n                    checkpoint: newCheckpoint\r\n                };\r\n            },\r\n            batchSize: ensureNotFalsy(options.pull).batchSize,\r\n            modifier: ensureNotFalsy(options.pull).modifier,\r\n            stream$: pullStream$.asObservable()\r\n        };\r\n    }\r\n\r\n\r\n    let replicationPrimitivesPush: ReplicationPushOptions<RxDocType> | undefined;\r\n    if (options.push) {\r\n        replicationPrimitivesPush = {\r\n            async handler(\r\n                rows: RxReplicationWriteToMasterRow<RxDocType>[]\r\n            ) {\r\n                const cn = await connectionStatePromise;\r\n                const conflicts: WithDeleted<RxDocType>[] = [];\r\n                await Promise.all(\r\n                    rows.map(async (writeRow) => {\r\n                        const docId = (writeRow.newDocumentState as any)[primaryPath];\r\n\r\n                        /**\r\n                         * first get the current state of the documents from the server\r\n                         * so that we have the sequence number for conflict detection.\r\n                         */\r\n                        let remoteDocState;\r\n                        try {\r\n                            remoteDocState = await getNatsServerDocumentState(\r\n                                cn.natsStream,\r\n                                options.subjectPrefix,\r\n                                docId\r\n                            );\r\n                        } catch (err: Error | any) {\r\n                            if (!err.message.includes('no message found')) {\r\n                                throw err;\r\n                            }\r\n                        }\r\n\r\n                        if (\r\n                            remoteDocState &&\r\n                            (\r\n                                !writeRow.assumedMasterState ||\r\n                                collection.conflictHandler.isEqual(remoteDocState.json(), writeRow.assumedMasterState, 'replication-nats-push') === false\r\n                            )\r\n                        ) {\r\n                            // conflict\r\n                            conflicts.push(remoteDocState.json());\r\n                        } else {\r\n                            // no conflict (yet)\r\n                            let pushDone = false;\r\n                            while (!pushDone) {\r\n                                try {\r\n                                    await cn.jetstreamClient.publish(\r\n                                        options.subjectPrefix + '.' + docId,\r\n                                        jc.encode(writeRow.newDocumentState),\r\n                                        {\r\n                                            expect: remoteDocState ? {\r\n                                                streamName: options.streamName,\r\n                                                lastSubjectSequence: remoteDocState.seq\r\n                                            } : undefined\r\n                                        }\r\n                                    );\r\n                                    pushDone = true;\r\n                                } catch (err: Error | any) {\r\n                                    if (err.message.includes('wrong last sequence')) {\r\n                                        // A write happened while we are doing our write -> handle conflict\r\n                                        const newServerState = await getNatsServerDocumentState(\r\n                                            cn.natsStream,\r\n                                            options.subjectPrefix,\r\n                                            docId\r\n                                        );\r\n                                        conflicts.push(ensureNotFalsy(newServerState).json());\r\n                                        pushDone = true;\r\n                                    } else {\r\n                                        replicationState.subjects.error.next(\r\n                                            newRxError('RC_STREAM', {\r\n                                                document: writeRow.newDocumentState,\r\n                                                error: errorToPlainJson(err)\r\n                                            })\r\n                                        );\r\n\r\n                                        // -> retry after wait\r\n                                        await awaitRetry(\r\n                                            collection,\r\n                                            replicationState.retryTime\r\n                                        );\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n                return conflicts;\r\n            },\r\n            batchSize: options.push.batchSize,\r\n            modifier: options.push.modifier\r\n        };\r\n    }\r\n\r\n\r\n    const replicationState = new RxNatsReplicationState<RxDocType>(\r\n        options.replicationIdentifier,\r\n        collection,\r\n        replicationPrimitivesPull,\r\n        replicationPrimitivesPush,\r\n        options.live,\r\n        options.retryTime,\r\n        options.autoStart\r\n    );\r\n\r\n    /**\r\n     * Use long polling to get live changes for the pull.stream$\r\n     */\r\n    if (options.live && options.pull) {\r\n        const startBefore = replicationState.start.bind(replicationState);\r\n        const cancelBefore = replicationState.cancel.bind(replicationState);\r\n        replicationState.start = async () => {\r\n            const cn = await connectionStatePromise;\r\n\r\n            /**\r\n             * First get the last sequence so that we can\r\n             * laster only fetch 'newer' messages.\r\n             */\r\n            let lastSeq = 0;\r\n            try {\r\n                const lastDocState = await cn.natsStream.getMessage({\r\n                    last_by_subj: options.subjectPrefix + '.*'\r\n                });\r\n                lastSeq = lastDocState.seq;\r\n            } catch (err: any | Error) {\r\n                if (!err.message.includes('no message found')) {\r\n                    throw err;\r\n                }\r\n            }\r\n\r\n            const consumer = await cn.natsStream.getConsumer({\r\n                opt_start_seq: lastSeq\r\n            });\r\n            const newMessages = await consumer.consume();\r\n            (async () => {\r\n                for await (const m of newMessages) {\r\n                    const docData: WithDeleted<RxDocType> = m.json();\r\n                    pullStream$.next({\r\n                        documents: [docData],\r\n                        checkpoint: {\r\n                            sequence: m.seq\r\n                        }\r\n                    });\r\n                    m.ack();\r\n                }\r\n            })();\r\n            replicationState.cancel = () => {\r\n                newMessages.close();\r\n                return cancelBefore();\r\n            };\r\n            return startBefore();\r\n        };\r\n    }\r\n\r\n    startReplicationOnLeaderShip(options.waitForLeadership, replicationState);\r\n\r\n    return replicationState;\r\n}\r\n"],"mappings":"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","ignoreList":[]}