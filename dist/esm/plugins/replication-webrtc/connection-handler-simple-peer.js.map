{"version":3,"file":"connection-handler-simple-peer.js","names":["Subject","ensureNotFalsy","getFromMapOrThrow","PROMISE_RESOLVE_VOID","promiseWait","randomToken","default","_Peer","Peer","newRxError","sendMessage","ws","msg","send","JSON","stringify","DEFAULT_SIGNALING_SERVER_HOSTNAME","DEFAULT_SIGNALING_SERVER","defaultServerWarningShown","SIMPLE_PEER_PING_INTERVAL","getConnectionHandlerSimplePeer","signalingServerUrl","wrtc","config","webSocketConstructor","ensureProcessNextTickIsSet","WebSocket","includes","console","warn","join","creator","options","connect$","disconnect$","message$","response$","error$","peers","Map","closed","ownPeerId","socket","undefined","createSocket","type","onclose","onopen","onmessage","msgEvent","parse","data","yourPeerId","room","topic","createPeerConnection","remotePeerId","disconnected","newSimplePeer","initiator","trickle","id","set","on","signal","senderPeerId","receiverPeerId","messageOrResponse","toString","result","next","peer","response","message","error","destroy","otherPeerIds","forEach","has","handler","close","complete","process","nextTick"],"sources":["../../../../src/plugins/replication-webrtc/connection-handler-simple-peer.ts"],"sourcesContent":["import { Subject } from 'rxjs';\r\nimport {\r\n    ensureNotFalsy,\r\n    getFromMapOrThrow,\r\n    PROMISE_RESOLVE_VOID,\r\n    promiseWait,\r\n    randomToken\r\n} from '../../plugins/utils/index.ts';\r\nimport type {\r\n    WebRTCConnectionHandler,\r\n    WebRTCConnectionHandlerCreator,\r\n    WebRTCMessage,\r\n    PeerWithMessage,\r\n    PeerWithResponse,\r\n    SyncOptionsWebRTC\r\n} from './webrtc-types.ts';\r\n\r\nimport type { \r\n    SimplePeer as Peer, \r\n    Instance as SimplePeerInstance, \r\n    Options as SimplePeerOptions \r\n} from 'simple-peer';\r\nimport {\r\n    default as _Peer\r\n    // @ts-ignore\r\n} from 'simple-peer/simplepeer.min.js';\r\n\r\nconst Peer = _Peer as Peer\r\n\r\nimport type { RxError, RxTypeError } from '../../types/index.d.ts';\r\nimport { newRxError } from '../../rx-error.ts';\r\n\r\nexport type SimplePeer = SimplePeerInstance & {\r\n    // add id to make debugging easier\r\n    id: string;\r\n};\r\n\r\nexport type SimplePeerInitMessage = {\r\n    type: 'init';\r\n    yourPeerId: string;\r\n};\r\nexport type SimplePeerJoinMessage = {\r\n    type: 'join';\r\n    room: string;\r\n};\r\nexport type SimplePeerJoinedMessage = {\r\n    type: 'joined';\r\n    otherPeerIds: string[];\r\n};\r\nexport type SimplePeerSignalMessage = {\r\n    type: 'signal';\r\n    room: string;\r\n    senderPeerId: string;\r\n    receiverPeerId: string;\r\n    data: string;\r\n};\r\nexport type SimplePeerPingMessage = {\r\n    type: 'ping';\r\n};\r\n\r\nexport type PeerMessage =\r\n    SimplePeerInitMessage |\r\n    SimplePeerJoinMessage |\r\n    SimplePeerJoinedMessage |\r\n    SimplePeerSignalMessage |\r\n    SimplePeerPingMessage;\r\n\r\n\r\nfunction sendMessage(ws: WebSocket, msg: PeerMessage) {\r\n    ws.send(JSON.stringify(msg));\r\n}\r\n\r\nconst DEFAULT_SIGNALING_SERVER_HOSTNAME = 'signaling.rxdb.info';\r\nexport const DEFAULT_SIGNALING_SERVER = 'wss://' + DEFAULT_SIGNALING_SERVER_HOSTNAME + '/';\r\nlet defaultServerWarningShown = false;\r\n\r\nexport type SimplePeerWrtc = SimplePeerOptions['wrtc'];\r\nexport type SimplePeerConfig = SimplePeerOptions['config'];\r\n\r\nexport type SimplePeerConnectionHandlerOptions = {\r\n    /**\r\n     * If no server is specified, the default signaling server\r\n     * from signaling.rxdb.info is used.\r\n     * This server is not reliable and you should use\r\n     * your own signaling server instead.\r\n     */\r\n    signalingServerUrl?: string;\r\n    wrtc?: SimplePeerWrtc;\r\n    config?: SimplePeerConfig;\r\n    webSocketConstructor?: WebSocket;\r\n};\r\n\r\nexport const SIMPLE_PEER_PING_INTERVAL = 1000 * 60 * 2;\r\n\r\n/**\r\n * Returns a connection handler that uses simple-peer and the signaling server.\r\n */\r\nexport function getConnectionHandlerSimplePeer({\r\n    signalingServerUrl,\r\n    wrtc,\r\n    config,\r\n    webSocketConstructor\r\n}: SimplePeerConnectionHandlerOptions): WebRTCConnectionHandlerCreator<SimplePeer> {\r\n    ensureProcessNextTickIsSet();\r\n\r\n    signalingServerUrl = signalingServerUrl ? signalingServerUrl : DEFAULT_SIGNALING_SERVER;\r\n    webSocketConstructor = webSocketConstructor ? webSocketConstructor as any : WebSocket;\r\n\r\n    if (\r\n        signalingServerUrl.includes(DEFAULT_SIGNALING_SERVER_HOSTNAME) &&\r\n        !defaultServerWarningShown\r\n    ) {\r\n        defaultServerWarningShown = true;\r\n        console.warn(\r\n            [\r\n                'RxDB Warning: You are using the RxDB WebRTC replication plugin',\r\n                'but you did not specify your own signaling server url.',\r\n                'By default it will use a signaling server provided by RxDB at ' + DEFAULT_SIGNALING_SERVER,\r\n                'This server is made for demonstration purposes and tryouts. It is not reliable and might be offline at any time.',\r\n                'In production you must always use your own signaling server instead.',\r\n                'Learn how to run your own server at https://rxdb.info/replication-webrtc.html',\r\n                'Also leave a ‚≠ê at the RxDB github repo üôè https://github.com/pubkey/rxdb üôè'\r\n            ].join(' ')\r\n        );\r\n    }\r\n\r\n    const creator: WebRTCConnectionHandlerCreator<SimplePeer> = async (options: SyncOptionsWebRTC<any, SimplePeer>) => {\r\n\r\n        const connect$ = new Subject<SimplePeer>();\r\n        const disconnect$ = new Subject<SimplePeer>();\r\n        const message$ = new Subject<PeerWithMessage<SimplePeer>>();\r\n        const response$ = new Subject<PeerWithResponse<SimplePeer>>();\r\n        const error$ = new Subject<RxError | RxTypeError>();\r\n\r\n        const peers = new Map<string, SimplePeer>();\r\n        let closed = false;\r\n        let ownPeerId: string;\r\n        let socket: WebSocket | undefined = undefined;\r\n        createSocket();\r\n\r\n\r\n        /**\r\n         * Send ping signals to the server.\r\n         */\r\n        (async () => {\r\n            while (true) {\r\n                await promiseWait(SIMPLE_PEER_PING_INTERVAL / 2);\r\n                if (closed) {\r\n                    break;\r\n                }\r\n                if (socket) {\r\n                    sendMessage(socket, { type: 'ping' });\r\n                }\r\n            }\r\n        })();\r\n\r\n\r\n        /**\r\n         * @recursive calls it self on socket disconnects\r\n         * so that when the user goes offline and online\r\n         * again, it will recreate the WebSocket connection.\r\n         */\r\n        function createSocket() {\r\n            if (closed) {\r\n                return;\r\n            }\r\n            socket = new (webSocketConstructor as any)(signalingServerUrl) as WebSocket;\r\n            socket.onclose = () => createSocket();\r\n            socket.onopen = () => {\r\n                ensureNotFalsy(socket).onmessage = (msgEvent: any) => {\r\n                    const msg: PeerMessage = JSON.parse(msgEvent.data as any);\r\n                    switch (msg.type) {\r\n                        case 'init':\r\n                            ownPeerId = msg.yourPeerId;\r\n                            sendMessage(ensureNotFalsy(socket), {\r\n                                type: 'join',\r\n                                room: options.topic\r\n                            });\r\n                            break;\r\n                        case 'joined':\r\n                            /**\r\n                             * PeerId is created by the signaling server\r\n                             * to prevent spoofing it.\r\n                             */\r\n                            function createPeerConnection(remotePeerId: string) {\r\n                                let disconnected = false;\r\n                                const newSimplePeer: SimplePeer = new Peer({\r\n                                    initiator: remotePeerId > ownPeerId,\r\n                                    wrtc,\r\n                                    config,\r\n                                    trickle: true\r\n                                }) as any;\r\n                                newSimplePeer.id = randomToken(10);\r\n                                peers.set(remotePeerId, newSimplePeer);\r\n\r\n\r\n                                newSimplePeer.on('signal', (signal: any) => {\r\n                                    sendMessage(ensureNotFalsy(socket), {\r\n                                        type: 'signal',\r\n                                        senderPeerId: ownPeerId,\r\n                                        receiverPeerId: remotePeerId,\r\n                                        room: options.topic,\r\n                                        data: signal\r\n                                    });\r\n                                });\r\n\r\n                                newSimplePeer.on('data', (messageOrResponse: any) => {\r\n                                    messageOrResponse = JSON.parse(messageOrResponse.toString());\r\n                                    if (messageOrResponse.result) {\r\n                                        response$.next({\r\n                                            peer: newSimplePeer,\r\n                                            response: messageOrResponse\r\n                                        });\r\n                                    } else {\r\n                                        message$.next({\r\n                                            peer: newSimplePeer,\r\n                                            message: messageOrResponse\r\n                                        });\r\n                                    }\r\n                                });\r\n\r\n                                newSimplePeer.on('error', (error) => {\r\n                                    error$.next(newRxError('RC_WEBRTC_PEER', {\r\n                                        error\r\n                                    }));\r\n                                    newSimplePeer.destroy();\r\n                                    if (!disconnected) {\r\n                                        disconnected = true;\r\n                                        disconnect$.next(newSimplePeer);\r\n                                    }\r\n                                });\r\n\r\n                                newSimplePeer.on('connect', () => {\r\n                                    connect$.next(newSimplePeer);\r\n                                });\r\n\r\n                                newSimplePeer.on('close', () => {\r\n                                    if (!disconnected) {\r\n                                        disconnected = true;\r\n                                        disconnect$.next(newSimplePeer);\r\n                                    }\r\n                                    createPeerConnection(remotePeerId);\r\n                                });\r\n                            }\r\n                            msg.otherPeerIds.forEach(remotePeerId => {\r\n                                if (\r\n                                    remotePeerId === ownPeerId ||\r\n                                    peers.has(remotePeerId)\r\n                                ) {\r\n                                    return;\r\n                                } else {\r\n                                    createPeerConnection(remotePeerId);\r\n                                }\r\n\r\n                            });\r\n                            break;\r\n                        case 'signal':\r\n                            const peer = getFromMapOrThrow(peers, msg.senderPeerId);\r\n                            peer.signal(msg.data);\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        const handler: WebRTCConnectionHandler<SimplePeer> = {\r\n            error$,\r\n            connect$,\r\n            disconnect$,\r\n            message$,\r\n            response$,\r\n            async send(peer: SimplePeer, message: WebRTCMessage) {\r\n                await peer.send(JSON.stringify(message));\r\n            },\r\n            close() {\r\n                closed = true;\r\n                ensureNotFalsy(socket).close();\r\n                error$.complete();\r\n                connect$.complete();\r\n                disconnect$.complete();\r\n                message$.complete();\r\n                response$.complete();\r\n                return PROMISE_RESOLVE_VOID;\r\n            }\r\n        };\r\n        return handler;\r\n    };\r\n    return creator;\r\n}\r\n\r\n\r\n/**\r\n * Multiple people had problems because it requires to have\r\n * the nextTick() method in the runtime. So we check here and\r\n * throw a helpful error.\r\n */\r\nexport function ensureProcessNextTickIsSet() {\r\n    if (\r\n        typeof process === 'undefined' ||\r\n        typeof process.nextTick !== 'function'\r\n    ) {\r\n        throw newRxError('RC7');\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]}