{"version":3,"file":"connection-handler-p2pcf.js","names":[],"sources":["../../../../src/plugins/replication-webrtc/connection-handler-p2pcf.ts"],"sourcesContent":["// import { Subject } from 'rxjs';\r\n// import { PROMISE_RESOLVE_VOID, randomToken } from '../../util';\r\n// import type {\r\n//     P2PConnectionHandler,\r\n//     P2PConnectionHandlerCreator,\r\n//     P2PMessage,\r\n//     P2PPeer,\r\n//     PeerWithMessage,\r\n//     PeerWithResponse\r\n// } from './p2p-types';\r\n\r\n// import P2PCF from 'p2pcf';\r\n\r\n// /**\r\n//  * Returns a connection handler that uses the Cloudflare worker signaling server\r\n//  * @link https://github.com/gfodor/p2pcf\r\n//  */\r\n// export function getConnectionHandlerP2PCF(\r\n//     p2pCFOptions: {\r\n//         workerUrl?: string\r\n//     } = {}\r\n// ): P2PConnectionHandlerCreator {\r\n// //    const P2PCF = require('p2pcf');\r\n\r\n//     const creator: P2PConnectionHandlerCreator = (options) => {\r\n//         const clientId = randomToken(10);\r\n//         const p2p2 = new P2PCF(clientId, options.topic, p2pCFOptions);\r\n\r\n//         const connect$ = new Subject<P2PPeer>();\r\n//         p2p2.on('peerconnect', (peer) => connect$.next(peer as any));\r\n\r\n//         const disconnect$ = new Subject<P2PPeer>();\r\n//         p2p2.on('peerclose', (peer) => disconnect$.next(peer as any));\r\n\r\n//         const message$ = new Subject<PeerWithMessage>();\r\n//         const response$ = new Subject<PeerWithResponse>();\r\n//         p2p2.on('msg', (peer, messageOrResponse) => {\r\n//             if (messageOrResponse.result) {\r\n//                 response$.next({\r\n//                     peer: peer as any,\r\n//                     response: messageOrResponse\r\n//                 });\r\n//             } else {\r\n//                 message$.next({\r\n//                     peer: peer as any,\r\n//                     message: messageOrResponse\r\n//                 });\r\n//             }\r\n\r\n//         });\r\n\r\n//         const handler: P2PConnectionHandler = {\r\n//             connect$,\r\n//             disconnect$,\r\n//             message$,\r\n//             response$,\r\n//             async send(peer: P2PPeer, message: P2PMessage) {\r\n//                 const [responsePeer, response] = await p2p2.send(peer as any, message);\r\n//                 return {\r\n//                     peer: responsePeer,\r\n//                     response\r\n//                 } as any;\r\n//             },\r\n//             close() {\r\n//                 p2p2.close();\r\n//                 connect$.complete();\r\n//                 disconnect$.complete();\r\n//                 message$.complete();\r\n//                 response$.complete();\r\n//                 return PROMISE_RESOLVE_VOID;\r\n//             }\r\n//         }\r\n//         p2p2.start();\r\n//         return handler;\r\n//     };\r\n//     return creator;\r\n// }\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]}