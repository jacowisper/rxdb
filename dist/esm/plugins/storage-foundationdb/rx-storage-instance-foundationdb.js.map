{"version":3,"file":"rx-storage-instance-foundationdb.js","names":["Subject","getPrimaryFieldOfPrimaryKey","categorizeBulkWriteRows","CLEANUP_INDEX","FOUNDATION_DB_WRITE_BATCH_SIZE","getFoundationDBIndexName","getIndexableStringMonad","getStartIndexStringFromLowerBound","getStartIndexStringFromUpperBound","appendToArray","batchArray","ensureNotFalsy","now","PROMISE_RESOLVE_VOID","toArray","queryFoundationDB","INDEX_MAX","attachmentMapKey","RxStorageInstanceFoundationDB","storage","databaseName","collectionName","schema","internals","options","settings","changes$","primaryPath","primaryKey","_proto","prototype","bulkWrite","documentWrites","context","dbs","dbsPromise","ret","error","writeBatches","Promise","all","map","writeBatch","categorized","root","doTransaction","tx","ids","row","document","mainTx","at","main","subspace","attachmentTx","attachments","docsInDB","Map","id","doc","get","set","errors","bulkInsertDocs","forEach","writeRow","docId","Object","values","indexes","indexMeta","indexString","getIndexableString","indexTx","db","bulkUpdateDocs","oldIndexString","previous","newIndexString","delete","attachmentsAdd","attachment","documentId","attachmentId","attachmentData","attachmentsUpdate","attachmentsRemove","eventBulk","events","length","lastState","newestRow","checkpoint","lwt","_meta","next","findDocumentsById","withDeleted","docInDb","_deleted","push","query","preparedQuery","count","result","documents","mode","getAttachmentData","_digest","data","changeStream","asObservable","remove","clearRange","close","cleanup","minimumDeletedTime","keySelector","StreamingMode","require","maxDeletionTime","index","indexName","lowerBoundString","upperBoundString","noMoreUndeleted","batchSize","range","getRangeAll","firstGreaterThan","limit","streamingMode","Exact","pop","docIds","docsData","indexMetaInner","subIndexDB","docData","closed","complete","createFoundationDBStorageInstance","params","open","directory","encoders","connection","clusterFile","dir","createOrOpen","version","withKeyEncoding","string","withValueEncoding","json","indexDBs","useIndexes","slice","useIndexesFinal","indexAr","indexDB","instance","resolve"],"sources":["../../../../src/plugins/storage-foundationdb/rx-storage-instance-foundationdb.ts"],"sourcesContent":["import { Observable, Subject } from 'rxjs';\r\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper.ts';\r\nimport type {\r\n    BulkWriteRow,\r\n    CategorizeBulkWriteRowsOutput,\r\n    EventBulk,\r\n    PreparedQuery,\r\n    RxAttachmentWriteData,\r\n    RxDocumentData,\r\n    RxJsonSchema,\r\n    RxStorageBulkWriteResponse,\r\n    RxStorageChangeEvent,\r\n    RxStorageCountResult,\r\n    RxStorageDefaultCheckpoint,\r\n    RxStorageInstance,\r\n    RxStorageInstanceCreationParams,\r\n    RxStorageQueryResult,\r\n    StringKeys\r\n} from '../../types/index.d.ts';\r\nimport type {\r\n    FoundationDBDatabase,\r\n    FoundationDBIndexMeta,\r\n    FoundationDBStorageInternals,\r\n    RxStorageFoundationDB,\r\n    RxStorageFoundationDBInstanceCreationOptions,\r\n    RxStorageFoundationDBSettings\r\n} from './foundationdb-types.ts';\r\n// import {\r\n//     open as foundationDBOpen,\r\n//     directory as foundationDBDirectory,\r\n//     encoders as foundationDBEncoders,\r\n//     keySelector as foundationDBKeySelector,\r\n//     StreamingMode as foundationDBStreamingMode\r\n// } from 'foundationdb';\r\nimport {\r\n    categorizeBulkWriteRows\r\n} from '../../rx-storage-helper.ts';\r\nimport {\r\n\r\n    CLEANUP_INDEX,\r\n    FOUNDATION_DB_WRITE_BATCH_SIZE,\r\n    getFoundationDBIndexName\r\n} from './foundationdb-helpers.ts';\r\nimport {\r\n    getIndexableStringMonad,\r\n    getStartIndexStringFromLowerBound,\r\n    getStartIndexStringFromUpperBound\r\n} from '../../custom-index.ts';\r\nimport {\r\n    appendToArray,\r\n    batchArray,\r\n    ensureNotFalsy,\r\n    lastOfArray,\r\n    now,\r\n    PROMISE_RESOLVE_VOID,\r\n    toArray\r\n} from '../../plugins/utils/index.ts';\r\nimport { queryFoundationDB } from './foundationdb-query.ts';\r\nimport { INDEX_MAX } from '../../query-planner.ts';\r\nimport { attachmentMapKey } from '../storage-memory/index.ts';\r\n\r\nexport class RxStorageInstanceFoundationDB<RxDocType> implements RxStorageInstance<\r\n    RxDocType,\r\n    FoundationDBStorageInternals<RxDocType>,\r\n    RxStorageFoundationDBInstanceCreationOptions,\r\n    RxStorageDefaultCheckpoint\r\n> {\r\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\r\n\r\n    public closed?: Promise<void>;\r\n    private changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> = new Subject();\r\n\r\n    constructor(\r\n        public readonly storage: RxStorageFoundationDB,\r\n        public readonly databaseName: string,\r\n        public readonly collectionName: string,\r\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\r\n        public readonly internals: FoundationDBStorageInternals<RxDocType>,\r\n        public readonly options: Readonly<RxStorageFoundationDBInstanceCreationOptions>,\r\n        public readonly settings: RxStorageFoundationDBSettings\r\n    ) {\r\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\r\n    }\r\n\r\n    async bulkWrite(\r\n        documentWrites: BulkWriteRow<RxDocType>[],\r\n        context: string\r\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\r\n        const dbs = await this.internals.dbsPromise;\r\n        const ret: RxStorageBulkWriteResponse<RxDocType> = {\r\n            error: []\r\n        };\r\n\r\n        /**\r\n         * Doing too many write in a single transaction\r\n         * will throw with a 'Transaction exceeds byte limit'\r\n         * so we have to batch up the writes.\r\n         */\r\n        const writeBatches = batchArray(documentWrites, FOUNDATION_DB_WRITE_BATCH_SIZE);\r\n        await Promise.all(\r\n            writeBatches.map(async (writeBatch) => {\r\n                let categorized: CategorizeBulkWriteRowsOutput<RxDocType> | undefined = null as any;\r\n                await dbs.root.doTransaction(async (tx: any) => {\r\n                    const ids = writeBatch.map(row => (row.document as any)[this.primaryPath]);\r\n                    const mainTx = tx.at(dbs.main.subspace);\r\n                    const attachmentTx = tx.at(dbs.attachments.subspace);\r\n                    const docsInDB = new Map<string, RxDocumentData<RxDocType>>();\r\n                    /**\r\n                     * TODO this might be faster if fdb\r\n                     * any time adds a bulk-fetch-by-key method.\r\n                     */\r\n                    await Promise.all(\r\n                        ids.map(async (id) => {\r\n                            const doc = await mainTx.get(id);\r\n                            docsInDB.set(id, doc);\r\n                        })\r\n                    );\r\n                    categorized = categorizeBulkWriteRows<RxDocType>(\r\n                        this,\r\n                        this.primaryPath as any,\r\n                        docsInDB,\r\n                        writeBatch,\r\n                        context\r\n                    );\r\n                    appendToArray(ret.error, categorized.errors);\r\n\r\n                    // INSERTS\r\n                    categorized.bulkInsertDocs.forEach(writeRow => {\r\n                        const docId: string = writeRow.document[this.primaryPath] as any;\r\n\r\n                        // insert document data\r\n                        mainTx.set(docId, writeRow.document);\r\n\r\n                        // insert secondary indexes\r\n                        Object.values(dbs.indexes).forEach(indexMeta => {\r\n                            const indexString = indexMeta.getIndexableString(writeRow.document as any);\r\n                            const indexTx = tx.at(indexMeta.db.subspace);\r\n                            indexTx.set(indexString, docId);\r\n                        });\r\n                    });\r\n                    // UPDATES\r\n                    categorized.bulkUpdateDocs.forEach((writeRow: BulkWriteRow<RxDocType>) => {\r\n                        const docId: string = writeRow.document[this.primaryPath] as any;\r\n\r\n                        // overwrite document data\r\n                        mainTx.set(docId, writeRow.document);\r\n\r\n                        // update secondary indexes\r\n                        Object.values(dbs.indexes).forEach(indexMeta => {\r\n                            const oldIndexString = indexMeta.getIndexableString(ensureNotFalsy(writeRow.previous));\r\n                            const newIndexString = indexMeta.getIndexableString(writeRow.document as any);\r\n                            if (oldIndexString !== newIndexString) {\r\n                                const indexTx = tx.at(indexMeta.db.subspace);\r\n                                indexTx.delete(oldIndexString);\r\n                                indexTx.set(newIndexString, docId);\r\n                            }\r\n                        });\r\n                    });\r\n\r\n                    // attachments\r\n                    categorized.attachmentsAdd.forEach(attachment => {\r\n                        attachmentTx.set(\r\n                            attachmentMapKey(attachment.documentId, attachment.attachmentId),\r\n                            attachment.attachmentData\r\n                        );\r\n                    });\r\n                    categorized.attachmentsUpdate.forEach(attachment => {\r\n                        attachmentTx.set(\r\n                            attachmentMapKey(attachment.documentId, attachment.attachmentId),\r\n                            attachment.attachmentData\r\n                        );\r\n                    });\r\n                    categorized.attachmentsRemove.forEach(attachment => {\r\n                        attachmentTx.delete(\r\n                            attachmentMapKey(attachment.documentId, attachment.attachmentId)\r\n                        );\r\n                    });\r\n                });\r\n                categorized = ensureNotFalsy(categorized);\r\n                /**\r\n                 * The events must be emitted AFTER the transaction\r\n                 * has finished.\r\n                 * Otherwise an observable changestream might cause a read\r\n                 * to a document that does not already exist outside of the transaction.\r\n                 */\r\n                if (categorized.eventBulk.events.length > 0) {\r\n                    const lastState = ensureNotFalsy(categorized.newestRow).document;\r\n                    categorized.eventBulk.checkpoint = {\r\n                        id: lastState[this.primaryPath],\r\n                        lwt: lastState._meta.lwt\r\n                    };\r\n                    this.changes$.next(categorized.eventBulk);\r\n                }\r\n            })\r\n        );\r\n\r\n\r\n        return ret;\r\n    }\r\n\r\n    async findDocumentsById(ids: string[], withDeleted: boolean): Promise<RxDocumentData<RxDocType>[]> {\r\n        const dbs = await this.internals.dbsPromise;\r\n        return dbs.main.doTransaction(async (tx: any) => {\r\n            const ret: RxDocumentData<RxDocType>[] = [];\r\n            await Promise.all(\r\n                ids.map(async (docId) => {\r\n                    const docInDb = await tx.get(docId);\r\n                    if (\r\n                        docInDb &&\r\n                        (\r\n                            !docInDb._deleted ||\r\n                            withDeleted\r\n                        )\r\n                    ) {\r\n                        ret.push(docInDb);\r\n                    }\r\n                })\r\n            );\r\n            return ret;\r\n        });\r\n    }\r\n    query(preparedQuery: PreparedQuery<RxDocType>): Promise<RxStorageQueryResult<RxDocType>> {\r\n        return queryFoundationDB(this, preparedQuery);\r\n    }\r\n    async count(\r\n        preparedQuery: PreparedQuery<RxDocType>\r\n    ): Promise<RxStorageCountResult> {\r\n        /**\r\n         * At this point in time (end 2022), FoundationDB does not support\r\n         * range counts. So we have to run a normal query and use the result set length.\r\n         * @link https://github.com/apple/foundationdb/issues/5981\r\n         */\r\n        const result = await this.query(preparedQuery);\r\n        return {\r\n            count: result.documents.length,\r\n            mode: 'fast'\r\n        };\r\n    }\r\n\r\n    async getAttachmentData(documentId: string, attachmentId: string, _digest: string): Promise<string> {\r\n        const dbs = await this.internals.dbsPromise;\r\n        const attachment = await dbs.attachments.get(attachmentMapKey(documentId, attachmentId));\r\n        return attachment.data;\r\n    }\r\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocType>, RxStorageDefaultCheckpoint>> {\r\n        return this.changes$.asObservable();\r\n    }\r\n\r\n    async remove(): Promise<void> {\r\n        const dbs = await this.internals.dbsPromise;\r\n        await dbs.root.doTransaction((tx: any) => {\r\n            tx.clearRange('', INDEX_MAX);\r\n            return PROMISE_RESOLVE_VOID;\r\n        });\r\n        return this.close();\r\n    }\r\n    async cleanup(minimumDeletedTime: number): Promise<boolean> {\r\n        const {\r\n            keySelector,\r\n            StreamingMode\r\n        } = require('foundationdb');\r\n        const maxDeletionTime = now() - minimumDeletedTime;\r\n        const dbs = await this.internals.dbsPromise;\r\n        const index = CLEANUP_INDEX;\r\n        const indexName = getFoundationDBIndexName(index);\r\n        const indexMeta = dbs.indexes[indexName];\r\n        const lowerBoundString = getStartIndexStringFromLowerBound(\r\n            this.schema,\r\n            index,\r\n            [\r\n                true,\r\n                /**\r\n                 * Do not use 0 here,\r\n                 * because 1 is the minimum value for _meta.lwt\r\n                 */\r\n                1\r\n            ]\r\n        );\r\n        const upperBoundString = getStartIndexStringFromUpperBound(\r\n            this.schema,\r\n            index,\r\n            [\r\n                true,\r\n                maxDeletionTime\r\n            ]\r\n        );\r\n        let noMoreUndeleted: boolean = true;\r\n        await dbs.root.doTransaction(async (tx: any) => {\r\n            const batchSize = ensureNotFalsy(this.settings.batchSize);\r\n            const indexTx = tx.at(indexMeta.db.subspace);\r\n            const mainTx = tx.at(dbs.main.subspace);\r\n            const range = await indexTx.getRangeAll(\r\n                keySelector.firstGreaterThan(lowerBoundString),\r\n                upperBoundString,\r\n                {\r\n                    limit: batchSize + 1, // get one more extra to detect what to return from cleanup()\r\n                    streamingMode: StreamingMode.Exact\r\n                }\r\n            );\r\n            if (range.length > batchSize) {\r\n                noMoreUndeleted = false;\r\n                range.pop();\r\n            }\r\n            const docIds = range.map((row: string[]) => row[1]);\r\n            const docsData: RxDocumentData<RxDocType>[] = await Promise.all(docIds.map((docId: string) => mainTx.get(docId)));\r\n\r\n            Object\r\n                .values(dbs.indexes)\r\n                .forEach(indexMetaInner => {\r\n                    const subIndexDB = tx.at(indexMetaInner.db.subspace);\r\n                    docsData.forEach(docData => {\r\n                        const indexString = indexMetaInner.getIndexableString(docData);\r\n                        subIndexDB.delete(indexString);\r\n                    });\r\n                });\r\n            docIds.forEach((id: string) => mainTx.delete(id));\r\n        });\r\n\r\n        return noMoreUndeleted;\r\n    }\r\n    async close() {\r\n        if (this.closed) {\r\n            return this.closed;\r\n        }\r\n        this.closed = (async () => {\r\n            this.changes$.complete();\r\n            const dbs = await this.internals.dbsPromise;\r\n            await dbs.root.close();\r\n\r\n            // TODO shouldn't we close the index databases?\r\n            // Object.values(dbs.indexes).forEach(db => db.close());\r\n        })();\r\n        return this.closed;\r\n    }\r\n}\r\n\r\n\r\nexport function createFoundationDBStorageInstance<RxDocType>(\r\n    storage: RxStorageFoundationDB,\r\n    params: RxStorageInstanceCreationParams<RxDocType, RxStorageFoundationDBInstanceCreationOptions>,\r\n    settings: RxStorageFoundationDBSettings\r\n): Promise<RxStorageInstanceFoundationDB<RxDocType>> {\r\n    const primaryPath = getPrimaryFieldOfPrimaryKey(params.schema.primaryKey);\r\n\r\n    const {\r\n        open,\r\n        directory,\r\n        encoders\r\n    } = require('foundationdb');\r\n\r\n    const connection = open(settings.clusterFile);\r\n    const dbsPromise = (async () => {\r\n        const dir = await directory.createOrOpen(connection, 'rxdb');\r\n\r\n        const root = connection\r\n            .at(dir)\r\n            .at(params.databaseName + '.')\r\n            .at(params.collectionName + '.')\r\n            .at(params.schema.version + '.');\r\n        const main: FoundationDBDatabase<RxDocType> = root\r\n            .at('main.')\r\n            .withKeyEncoding(encoders.string) // automatically encode & decode keys using tuples\r\n            .withValueEncoding(encoders.json) as any; // and values using JSON\r\n\r\n\r\n        const events: FoundationDBDatabase<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> = root\r\n            .at('events.')\r\n            .withKeyEncoding(encoders.string)\r\n            .withValueEncoding(encoders.json) as any;\r\n\r\n        const attachments: FoundationDBDatabase<RxAttachmentWriteData> = root\r\n            .at('attachments.')\r\n            .withKeyEncoding(encoders.string)\r\n            .withValueEncoding(encoders.json) as any;\r\n\r\n\r\n        const indexDBs: { [indexName: string]: FoundationDBIndexMeta<RxDocType>; } = {};\r\n        const useIndexes = params.schema.indexes ? params.schema.indexes.slice(0) : [];\r\n        useIndexes.push([primaryPath]);\r\n        const useIndexesFinal = useIndexes.map(index => {\r\n            const indexAr = toArray(index);\r\n            return indexAr;\r\n        });\r\n        // used for `getChangedDocumentsSince()`\r\n        useIndexesFinal.push([\r\n            '_meta.lwt',\r\n            primaryPath\r\n        ]);\r\n        useIndexesFinal.push(CLEANUP_INDEX);\r\n        useIndexesFinal.forEach(indexAr => {\r\n            const indexName = getFoundationDBIndexName(indexAr);\r\n            const indexDB = root.at(indexName + '.')\r\n                .withKeyEncoding(encoders.string)\r\n                .withValueEncoding(encoders.string);\r\n            indexDBs[indexName] = {\r\n                indexName,\r\n                db: indexDB,\r\n                getIndexableString: getIndexableStringMonad(params.schema, indexAr),\r\n                index: indexAr\r\n            };\r\n        });\r\n\r\n        return {\r\n            root,\r\n            main,\r\n            events,\r\n            attachments,\r\n            indexes: indexDBs\r\n        };\r\n    })();\r\n\r\n\r\n    const internals: FoundationDBStorageInternals<RxDocType> = {\r\n        connection,\r\n        dbsPromise: dbsPromise\r\n    };\r\n\r\n    const instance = new RxStorageInstanceFoundationDB(\r\n        storage,\r\n        params.databaseName,\r\n        params.collectionName,\r\n        params.schema,\r\n        internals,\r\n        params.options,\r\n        settings\r\n    );\r\n    return Promise.resolve(instance);\r\n}\r\n"],"mappings":"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","ignoreList":[]}