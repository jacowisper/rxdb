{"version":3,"file":"rx-storage-instance-memory.js","names":["Subject","getStartIndexStringFromLowerBound","getStartIndexStringFromUpperBound","getPrimaryFieldOfPrimaryKey","categorizeBulkWriteRows","deepEqual","ensureNotFalsy","now","PROMISE_RESOLVE_TRUE","PROMISE_RESOLVE_VOID","randomToken","requestIdlePromiseNoQueue","boundGE","boundGT","boundLE","boundLT","attachmentMapKey","compareDocsWithIndex","ensureNotRemoved","getMemoryCollectionKey","putWriteRowToState","removeDocFromState","addIndexesToInternalsState","getMemoryIndexName","getQueryMatcher","getSortComparator","OPEN_MEMORY_INSTANCES","Set","RxStorageInstanceMemory","storage","databaseName","collectionName","schema","internals","options","settings","devMode","closed","categorizedByWriteInput","WeakMap","add","primaryPath","primaryKey","_proto","prototype","bulkWrite","documentWrites","context","ensurePersistence","documentsById","documents","categorized","error","errors","awaitMe","Promise","resolve","set","ensurePersistenceTask","ensurePersistenceIdlePromise","then","undefined","eventBulk","events","length","lastState","newestRow","document","checkpoint","id","lwt","_meta","changes$","next","stateByIndex","Object","values","byIndex","bulkInsertDocs","i","writeRow","doc","docId","bulkUpdateDocs","get","attachments","attachmentsMap","attachmentsAdd","forEach","attachment","documentId","attachmentId","writeData","attachmentData","digest","attachmentsUpdate","attachmentsRemove","delete","findDocumentsById","docIds","withDeleted","ret","size","docInDb","_deleted","push","query","preparedQuery","queryPlan","skip","limit","Infinity","skipPlusLimit","queryMatcher","selectorSatisfiedByIndex","queryPlanFields","index","mustManuallyResort","sortSatisfiedByIndex","lowerBound","startKeys","lowerBoundString","upperBound","endKeys","upperBoundString","indexName","Error","docsWithIndex","indexOfLower","inclusiveStart","indexOfUpper","inclusiveEnd","rows","done","currentRow","currentDoc","sortComparator","sort","slice","count","result","mode","cleanup","minimumDeletedTime","maxDeletionTime","getAttachmentData","key","data","changeStream","asObservable","remove","removed","collectionStates","version","close","refCount","createMemoryStorageInstance","params","collectionKey","Map","instance"],"sources":["../../../../src/plugins/storage-memory/rx-storage-instance-memory.ts"],"sourcesContent":["import {\r\n    Observable,\r\n    Subject\r\n} from 'rxjs';\r\nimport {\r\n    getStartIndexStringFromLowerBound,\r\n    getStartIndexStringFromUpperBound\r\n} from '../../custom-index.ts';\r\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper.ts';\r\nimport {\r\n    categorizeBulkWriteRows\r\n} from '../../rx-storage-helper.ts';\r\nimport type {\r\n    BulkWriteRow,\r\n    CategorizeBulkWriteRowsOutput,\r\n    EventBulk,\r\n    PreparedQuery,\r\n    QueryMatcher,\r\n    RxDocumentData,\r\n    RxJsonSchema,\r\n    RxStorageBulkWriteResponse,\r\n    RxStorageChangeEvent,\r\n    RxStorageCountResult,\r\n    RxStorageDefaultCheckpoint,\r\n    RxStorageInstance,\r\n    RxStorageInstanceCreationParams,\r\n    RxStorageQueryResult,\r\n    StringKeys\r\n} from '../../types/index.d.ts';\r\nimport {\r\n    deepEqual,\r\n    ensureNotFalsy,\r\n    now,\r\n    PROMISE_RESOLVE_TRUE,\r\n    PROMISE_RESOLVE_VOID,\r\n    randomToken,\r\n    requestIdlePromiseNoQueue\r\n} from '../../plugins/utils/index.ts';\r\nimport {\r\n    boundGE,\r\n    boundGT,\r\n    boundLE,\r\n    boundLT\r\n} from './binary-search-bounds.ts';\r\nimport {\r\n    attachmentMapKey,\r\n    compareDocsWithIndex,\r\n    ensureNotRemoved,\r\n    getMemoryCollectionKey,\r\n    putWriteRowToState,\r\n    removeDocFromState\r\n} from './memory-helper.ts';\r\nimport {\r\n    addIndexesToInternalsState,\r\n    getMemoryIndexName\r\n} from './memory-indexes.ts';\r\nimport type {\r\n    MemoryStorageInternals,\r\n    RxStorageMemory,\r\n    RxStorageMemoryInstanceCreationOptions,\r\n    RxStorageMemorySettings\r\n} from './memory-types.ts';\r\nimport { getQueryMatcher, getSortComparator } from '../../rx-query-helper.ts';\r\n\r\n/**\r\n * Used in tests to ensure everything\r\n * is closed correctly\r\n */\r\nexport const OPEN_MEMORY_INSTANCES = new Set<RxStorageInstanceMemory<any>>();\r\n\r\nexport class RxStorageInstanceMemory<RxDocType> implements RxStorageInstance<\r\n    RxDocType,\r\n    MemoryStorageInternals<RxDocType>,\r\n    RxStorageMemoryInstanceCreationOptions,\r\n    RxStorageDefaultCheckpoint\r\n> {\r\n\r\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\r\n    public closed = false;\r\n\r\n    /**\r\n     * Used by some plugins and storage wrappers\r\n     * to find out details about the internals of a write operation.\r\n     * For example if you want to know which documents really have been replaced\r\n     * or newly inserted.\r\n     */\r\n    public categorizedByWriteInput = new WeakMap<BulkWriteRow<RxDocType>[], CategorizeBulkWriteRowsOutput<RxDocType>>();\r\n\r\n    constructor(\r\n        public readonly storage: RxStorageMemory,\r\n        public readonly databaseName: string,\r\n        public readonly collectionName: string,\r\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\r\n        public readonly internals: MemoryStorageInternals<RxDocType>,\r\n        public readonly options: Readonly<RxStorageMemoryInstanceCreationOptions>,\r\n        public readonly settings: RxStorageMemorySettings,\r\n        public readonly devMode: boolean\r\n    ) {\r\n        OPEN_MEMORY_INSTANCES.add(this);\r\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\r\n    }\r\n\r\n    bulkWrite(\r\n        documentWrites: BulkWriteRow<RxDocType>[],\r\n        context: string\r\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\r\n        this.ensurePersistence();\r\n        ensureNotRemoved(this);\r\n        const internals = this.internals;\r\n        const documentsById = this.internals.documents;\r\n        const primaryPath = this.primaryPath;\r\n\r\n\r\n        const categorized = categorizeBulkWriteRows<RxDocType>(\r\n            this,\r\n            primaryPath as any,\r\n            documentsById,\r\n            documentWrites,\r\n            context\r\n        );\r\n        const error = categorized.errors;\r\n        /**\r\n         * @performance\r\n         * We have to return a Promise but we do not want to wait\r\n         * one tick, so we directly create the promise\r\n         * which makes it likely to be already resolved later.\r\n         */\r\n        const awaitMe = Promise.resolve({ error });\r\n\r\n        this.categorizedByWriteInput.set(documentWrites, categorized);\r\n        this.internals.ensurePersistenceTask = categorized;\r\n\r\n        if (!this.internals.ensurePersistenceIdlePromise) {\r\n            this.internals.ensurePersistenceIdlePromise = requestIdlePromiseNoQueue().then(() => {\r\n                this.internals.ensurePersistenceIdlePromise = undefined;\r\n                this.ensurePersistence();\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Important: The events must be emitted AFTER the persistence\r\n         * task has been added.\r\n         */\r\n        if (categorized.eventBulk.events.length > 0) {\r\n            const lastState = ensureNotFalsy(categorized.newestRow).document;\r\n            categorized.eventBulk.checkpoint = {\r\n                id: lastState[primaryPath],\r\n                lwt: lastState._meta.lwt\r\n            };\r\n            internals.changes$.next(categorized.eventBulk);\r\n        }\r\n        return awaitMe;\r\n    }\r\n\r\n    /**\r\n     * Instead of directly inserting the documents into all indexes,\r\n     * we do it lazy in the background. This gives the application time\r\n     * to directly work with the write-result and to do stuff like rendering DOM\r\n     * notes and processing RxDB queries.\r\n     * Then in some later time, or just before the next read/write,\r\n     * it is ensured that the indexes have been written.\r\n     */\r\n    public ensurePersistence() {\r\n        if (\r\n            !this.internals.ensurePersistenceTask\r\n        ) {\r\n            return;\r\n        }\r\n        const internals = this.internals;\r\n        const documentsById = this.internals.documents;\r\n        const primaryPath = this.primaryPath;\r\n\r\n        const categorized = this.internals.ensurePersistenceTask;\r\n        this.internals.ensurePersistenceTask = undefined;\r\n\r\n        /**\r\n         * Do inserts/updates\r\n         */\r\n        const stateByIndex = Object.values(this.internals.byIndex);\r\n\r\n        const bulkInsertDocs = categorized.bulkInsertDocs;\r\n        for (let i = 0; i < bulkInsertDocs.length; ++i) {\r\n            const writeRow = bulkInsertDocs[i];\r\n            const doc = writeRow.document;\r\n            const docId = doc[primaryPath];\r\n            putWriteRowToState(\r\n                docId as any,\r\n                internals,\r\n                stateByIndex,\r\n                doc,\r\n                undefined\r\n            );\r\n        }\r\n\r\n        const bulkUpdateDocs = categorized.bulkUpdateDocs;\r\n        for (let i = 0; i < bulkUpdateDocs.length; ++i) {\r\n            const writeRow = bulkUpdateDocs[i];\r\n            const doc = writeRow.document;\r\n            const docId = doc[primaryPath];\r\n            putWriteRowToState(\r\n                docId as any,\r\n                internals,\r\n                stateByIndex,\r\n                doc,\r\n                documentsById.get(docId as any)\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Handle attachments\r\n         */\r\n        if (this.schema.attachments) {\r\n            const attachmentsMap = internals.attachments;\r\n            categorized.attachmentsAdd.forEach(attachment => {\r\n                attachmentsMap.set(\r\n                    attachmentMapKey(attachment.documentId, attachment.attachmentId),\r\n                    {\r\n                        writeData: attachment.attachmentData,\r\n                        digest: attachment.digest\r\n                    }\r\n                );\r\n            });\r\n            if (this.schema.attachments) {\r\n                categorized.attachmentsUpdate.forEach(attachment => {\r\n                    attachmentsMap.set(\r\n                        attachmentMapKey(attachment.documentId, attachment.attachmentId),\r\n                        {\r\n                            writeData: attachment.attachmentData,\r\n                            digest: attachment.digest\r\n                        }\r\n                    );\r\n                });\r\n                categorized.attachmentsRemove.forEach(attachment => {\r\n                    attachmentsMap.delete(\r\n                        attachmentMapKey(attachment.documentId, attachment.attachmentId)\r\n                    );\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    findDocumentsById(\r\n        docIds: string[],\r\n        withDeleted: boolean\r\n    ): Promise<RxDocumentData<RxDocType>[]> {\r\n        this.ensurePersistence();\r\n        const documentsById = this.internals.documents;\r\n        const ret: RxDocumentData<RxDocType>[] = [];\r\n        if (documentsById.size === 0) {\r\n            return Promise.resolve(ret);\r\n        }\r\n        for (let i = 0; i < docIds.length; ++i) {\r\n            const docId = docIds[i];\r\n            const docInDb = documentsById.get(docId);\r\n            if (\r\n                docInDb &&\r\n                (\r\n                    !docInDb._deleted ||\r\n                    withDeleted\r\n                )\r\n            ) {\r\n                ret.push(docInDb);\r\n            }\r\n        }\r\n        return Promise.resolve(ret);\r\n    }\r\n\r\n    query(\r\n        preparedQuery: PreparedQuery<RxDocType>\r\n    ): Promise<RxStorageQueryResult<RxDocType>> {\r\n        this.ensurePersistence();\r\n\r\n        const queryPlan = preparedQuery.queryPlan;\r\n        const query = preparedQuery.query;\r\n\r\n        const skip = query.skip ? query.skip : 0;\r\n        const limit = query.limit ? query.limit : Infinity;\r\n        const skipPlusLimit = skip + limit;\r\n\r\n        let queryMatcher: QueryMatcher<RxDocumentData<RxDocType>> | false = false;\r\n        if (!queryPlan.selectorSatisfiedByIndex) {\r\n            queryMatcher = getQueryMatcher(\r\n                this.schema,\r\n                preparedQuery.query\r\n            );\r\n        }\r\n\r\n        const queryPlanFields: string[] = queryPlan.index;\r\n        const mustManuallyResort = !queryPlan.sortSatisfiedByIndex;\r\n        const index: string[] | undefined = queryPlanFields;\r\n        const lowerBound: any[] = queryPlan.startKeys;\r\n        const lowerBoundString = getStartIndexStringFromLowerBound(\r\n            this.schema,\r\n            index,\r\n            lowerBound\r\n        );\r\n\r\n        let upperBound: any[] = queryPlan.endKeys;\r\n        upperBound = upperBound;\r\n        const upperBoundString = getStartIndexStringFromUpperBound(\r\n            this.schema,\r\n            index,\r\n            upperBound\r\n        );\r\n        const indexName = getMemoryIndexName(index);\r\n\r\n        if (!this.internals.byIndex[indexName]) {\r\n            throw new Error('index does not exist ' + indexName);\r\n        }\r\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\r\n\r\n\r\n\r\n        let indexOfLower = (queryPlan.inclusiveStart ? boundGE : boundGT)(\r\n            docsWithIndex,\r\n            [\r\n                lowerBoundString\r\n            ] as any,\r\n            compareDocsWithIndex\r\n        );\r\n\r\n        const indexOfUpper = (queryPlan.inclusiveEnd ? boundLE : boundLT)(\r\n            docsWithIndex,\r\n            [\r\n                upperBoundString\r\n            ] as any,\r\n            compareDocsWithIndex\r\n        );\r\n\r\n        let rows: RxDocumentData<RxDocType>[] = [];\r\n        let done = false;\r\n        while (!done) {\r\n            const currentRow = docsWithIndex[indexOfLower];\r\n            if (\r\n                !currentRow ||\r\n                indexOfLower > indexOfUpper\r\n            ) {\r\n                break;\r\n            }\r\n            const currentDoc = currentRow[1];\r\n\r\n            if (!queryMatcher || queryMatcher(currentDoc)) {\r\n                rows.push(currentDoc);\r\n            }\r\n\r\n            if (\r\n                (rows.length >= skipPlusLimit && !mustManuallyResort)\r\n            ) {\r\n                done = true;\r\n            }\r\n\r\n            indexOfLower++;\r\n        }\r\n\r\n        if (mustManuallyResort) {\r\n            const sortComparator = getSortComparator(this.schema, preparedQuery.query);\r\n            rows = rows.sort(sortComparator);\r\n        }\r\n\r\n        // apply skip and limit boundaries.\r\n        rows = rows.slice(skip, skipPlusLimit);\r\n        return Promise.resolve({\r\n            documents: rows\r\n        });\r\n    }\r\n\r\n    async count(\r\n        preparedQuery: PreparedQuery<RxDocType>\r\n    ): Promise<RxStorageCountResult> {\r\n        this.ensurePersistence();\r\n        const result = await this.query(preparedQuery);\r\n        return {\r\n            count: result.documents.length,\r\n            mode: 'fast'\r\n        };\r\n    }\r\n\r\n    cleanup(minimumDeletedTime: number): Promise<boolean> {\r\n        this.ensurePersistence();\r\n        const maxDeletionTime = now() - minimumDeletedTime;\r\n        const index = ['_deleted', '_meta.lwt', this.primaryPath as any];\r\n        const indexName = getMemoryIndexName(index);\r\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\r\n\r\n        const lowerBoundString = getStartIndexStringFromLowerBound(\r\n            this.schema,\r\n            index,\r\n            [\r\n                true,\r\n                0,\r\n                ''\r\n            ]\r\n        );\r\n\r\n        let indexOfLower = boundGT(\r\n            docsWithIndex,\r\n            [\r\n                lowerBoundString\r\n            ] as any,\r\n            compareDocsWithIndex\r\n        );\r\n\r\n        let done = false;\r\n        while (!done) {\r\n            const currentDoc = docsWithIndex[indexOfLower];\r\n            if (!currentDoc || currentDoc[1]._meta.lwt > maxDeletionTime) {\r\n                done = true;\r\n            } else {\r\n                removeDocFromState(\r\n                    this.primaryPath as any,\r\n                    this.schema,\r\n                    this.internals,\r\n                    currentDoc[1]\r\n                );\r\n                indexOfLower++;\r\n            }\r\n        }\r\n        return PROMISE_RESOLVE_TRUE;\r\n    }\r\n\r\n    getAttachmentData(\r\n        documentId: string,\r\n        attachmentId: string,\r\n        digest: string\r\n    ): Promise<string> {\r\n        this.ensurePersistence();\r\n        ensureNotRemoved(this);\r\n        const key = attachmentMapKey(documentId, attachmentId);\r\n        const data = this.internals.attachments.get(key);\r\n\r\n        if (\r\n            !digest ||\r\n            !data ||\r\n            data.digest !== digest\r\n        ) {\r\n            throw new Error('attachment does not exist: ' + key);\r\n        }\r\n        return Promise.resolve(data.writeData.data);\r\n    }\r\n\r\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> {\r\n        ensureNotRemoved(this);\r\n        return this.internals.changes$.asObservable();\r\n    }\r\n\r\n    async remove(): Promise<void> {\r\n        if (this.closed) {\r\n            throw new Error('closed');\r\n        }\r\n        this.ensurePersistence();\r\n        ensureNotRemoved(this);\r\n\r\n        this.internals.removed = true;\r\n        this.storage.collectionStates.delete(\r\n            getMemoryCollectionKey(\r\n                this.databaseName,\r\n                this.collectionName,\r\n                this.schema.version\r\n            )\r\n        );\r\n        await this.close();\r\n    }\r\n\r\n    close(): Promise<void> {\r\n        OPEN_MEMORY_INSTANCES.delete(this);\r\n\r\n        this.ensurePersistence();\r\n        if (this.closed) {\r\n            return PROMISE_RESOLVE_VOID;\r\n        }\r\n        this.closed = true;\r\n\r\n        this.internals.refCount = this.internals.refCount - 1;\r\n        return PROMISE_RESOLVE_VOID;\r\n    }\r\n}\r\n\r\nexport function createMemoryStorageInstance<RxDocType>(\r\n    storage: RxStorageMemory,\r\n    params: RxStorageInstanceCreationParams<RxDocType, RxStorageMemoryInstanceCreationOptions>,\r\n    settings: RxStorageMemorySettings\r\n): Promise<RxStorageInstanceMemory<RxDocType>> {\r\n    const collectionKey = getMemoryCollectionKey(\r\n        params.databaseName,\r\n        params.collectionName,\r\n        params.schema.version\r\n    );\r\n\r\n    let internals = storage.collectionStates.get(collectionKey);\r\n    if (!internals) {\r\n        internals = {\r\n            id: randomToken(5),\r\n            schema: params.schema,\r\n            removed: false,\r\n            refCount: 1,\r\n            documents: new Map(),\r\n            attachments: params.schema.attachments ? new Map() : undefined as any,\r\n            byIndex: {},\r\n            changes$: new Subject()\r\n        };\r\n        addIndexesToInternalsState(internals, params.schema);\r\n        storage.collectionStates.set(collectionKey, internals);\r\n    } else {\r\n        /**\r\n         * Ensure that the storage was not already\r\n         * created with a different schema.\r\n         * This is very important because if this check\r\n         * does not exist here, we have hard-to-debug problems\r\n         * downstream.\r\n         */\r\n        if (\r\n            params.devMode &&\r\n            !deepEqual(internals.schema, params.schema)\r\n        ) {\r\n            throw new Error('storage was already created with a different schema');\r\n        }\r\n        internals.refCount = internals.refCount + 1;\r\n    }\r\n\r\n    const instance = new RxStorageInstanceMemory(\r\n        storage,\r\n        params.databaseName,\r\n        params.collectionName,\r\n        params.schema,\r\n        internals,\r\n        params.options,\r\n        settings,\r\n        params.devMode\r\n    );\r\n    return Promise.resolve(instance);\r\n}\r\n"],"mappings":"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","ignoreList":[]}