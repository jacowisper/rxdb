{"version":3,"file":"memory-types.js","names":[],"sources":["../../../../src/plugins/storage-memory/memory-types.ts"],"sourcesContent":["import { Subject } from 'rxjs';\r\nimport type {\r\n    CategorizeBulkWriteRowsOutput,\r\n    EventBulk,\r\n    RxAttachmentWriteData,\r\n    RxDocumentData,\r\n    RxJsonSchema,\r\n    RxStorage,\r\n    RxStorageChangeEvent,\r\n    RxStorageDefaultCheckpoint\r\n} from '../../types/index.d.ts';\r\n\r\nexport type RxStorageMemorySettings = {};\r\nexport type RxStorageMemoryInstanceCreationOptions = {};\r\nexport type RxStorageMemory = RxStorage<MemoryStorageInternals<any>, RxStorageMemoryInstanceCreationOptions> & {\r\n    /**\r\n     * State by collectionKey\r\n     */\r\n    collectionStates: Map<string, MemoryStorageInternals<any>>;\r\n};\r\n\r\nexport type MemoryStorageInternalsByIndex<RxDocType> = {\r\n    index: string[];\r\n    docsWithIndex: DocWithIndexString<RxDocType>[];\r\n    getIndexableString: (docData: RxDocumentData<RxDocType>) => string;\r\n};\r\n\r\n/**\r\n * The internals are shared between multiple storage instances\r\n * that have been created with the same [databaseName+collectionName] combination.\r\n */\r\nexport type MemoryStorageInternals<RxDocType> = {\r\n    // used to debug stuff and identify instances\r\n    id: string;\r\n\r\n    /**\r\n     * Schema of the first instance created with the given settings.\r\n     * Used to ensure that the same storage is not re-created with\r\n     * a different schema.\r\n     */\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>;\r\n\r\n    /**\r\n     * We reuse the memory state when multiple instances\r\n     * are created with the same params.\r\n     * If refCount becomes 0, we can delete the state.\r\n     */\r\n    refCount: number;\r\n    /**\r\n     * If this becomes true,\r\n     * it means that an instance has called remove()\r\n     * so all other instances should also not work anymore.\r\n     */\r\n    removed: boolean;\r\n    documents: Map<string, RxDocumentData<RxDocType>>;\r\n    /**\r\n     * Attachments data, indexed by a combined string\r\n     * consisting of [documentId + '||' + attachmentId]\r\n     */\r\n    attachments: Map<string, {\r\n        writeData: RxAttachmentWriteData;\r\n        digest: string;\r\n    }>;\r\n    byIndex: {\r\n        /**\r\n         * Because RxDB requires a deterministic sorting\r\n         * on all indexes, we can be sure that the composed index key\r\n         * of each document is unique, because it contains the primaryKey\r\n         * as last index part.\r\n         * So we do not have to store the index-position when we want to do fast\r\n         * writes. Instead we can do a binary search over the existing array\r\n         * because RxDB also knows the previous state of the document when we do a bulkWrite().\r\n         */\r\n        [indexName: string]: MemoryStorageInternalsByIndex<RxDocType>;\r\n    };\r\n\r\n    /**\r\n     * We need these to do lazy writes.\r\n     */\r\n    ensurePersistenceTask?: CategorizeBulkWriteRowsOutput<RxDocType>;\r\n    ensurePersistenceIdlePromise?: Promise<void>;\r\n\r\n    changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>>;\r\n};\r\n\r\nexport type DocWithIndexString<RxDocType> = [\r\n    string, // indexString, must be first because often we only need that one.\r\n    RxDocumentData<RxDocType>, // document\r\n    string, // id\r\n];\r\n"],"mappings":"","ignoreList":[]}