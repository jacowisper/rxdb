{"version":3,"file":"index.js","names":["pkg","AES","enc","cryptoEnc","wrapRxStorageInstance","newRxError","newRxTypeError","hasEncryption","b64DecodeUnicode","b64EncodeUnicode","clone","ensureNotFalsy","flatClone","getProperty","setProperty","MINIMUM_PASSWORD_LENGTH","encryptString","value","password","encrypted","encrypt","toString","decryptString","cipherText","args","decrypted","decrypt","ret","Utf8","wrappedKeyEncryptionCryptoJsStorage","Object","assign","storage","createStorageInstance","params","validatePassword","schema","retInstance","database","databaseName","collection","collectionName","schemaWithoutEncrypted","attachments","forEach","key","properties","type","instance","modifyToStorage","docData","cloneWithoutAttachments","path","stringValue","JSON","stringify","newAttachments","entries","_attachments","id","attachment","useAttachment","data","dataString","modifyFromStorage","decryptedParsed","parse","modifyAttachmentFromStorage","attachmentData","length","minPassLength"],"sources":["../../../../src/plugins/encryption-crypto-js/index.ts"],"sourcesContent":["/**\r\n * this plugin adds the encryption-capabilities to rxdb\r\n * It's using crypto-js/aes for password-encryption\r\n * @link https://github.com/brix/crypto-js\r\n */\r\nimport pkg from 'crypto-js';\r\nconst { AES, enc: cryptoEnc } = pkg;\r\n\r\nimport { wrapRxStorageInstance } from '../../plugin-helpers.ts';\r\nimport { newRxError, newRxTypeError } from '../../rx-error.ts';\r\nimport { hasEncryption } from '../../rx-storage-helper.ts';\r\nimport type {\r\n    InternalStoreDocType,\r\n    RxAttachmentWriteData,\r\n    RxDocumentData,\r\n    RxDocumentWriteData,\r\n    RxJsonSchema,\r\n    RxStorage,\r\n    RxStorageInstanceCreationParams\r\n} from '../../types/index.d.ts';\r\nimport {\r\n    b64DecodeUnicode,\r\n    b64EncodeUnicode,\r\n    clone,\r\n    ensureNotFalsy,\r\n    flatClone,\r\n    getProperty,\r\n    setProperty\r\n} from '../../plugins/utils/index.ts';\r\n\r\nexport const MINIMUM_PASSWORD_LENGTH: 8 = 8;\r\n\r\n\r\nexport function encryptString(value: string, password: string): string {\r\n    const encrypted = AES.encrypt(value, password);\r\n    return encrypted.toString();\r\n}\r\n\r\nexport function decryptString(cipherText: string, password: any): string {\r\n    /**\r\n     * Trying to decrypt non-strings\r\n     * will cause no errors and will be hard to debug.\r\n     * So instead we do this check here.\r\n     */\r\n    if (typeof cipherText !== 'string') {\r\n        throw newRxError('SNH', {\r\n            args: {\r\n                cipherText\r\n            }\r\n        });\r\n    }\r\n\r\n    const decrypted = AES.decrypt(cipherText, password);\r\n    const ret = decrypted.toString(cryptoEnc.Utf8);\r\n    return ret;\r\n}\r\n\r\nexport type InternalStorePasswordDocType = InternalStoreDocType<{\r\n    hash: string;\r\n}>;\r\n\r\nexport function wrappedKeyEncryptionCryptoJsStorage<Internals, InstanceCreationOptions>(\r\n    args: {\r\n        storage: RxStorage<Internals, InstanceCreationOptions>;\r\n    }\r\n): RxStorage<Internals, InstanceCreationOptions> {\r\n    return Object.assign(\r\n        {},\r\n        args.storage,\r\n        {\r\n            async createStorageInstance<RxDocType>(\r\n                params: RxStorageInstanceCreationParams<RxDocType, any>\r\n            ) {\r\n                if (typeof params.password !== 'undefined') {\r\n                    validatePassword(params.password as any);\r\n                }\r\n\r\n                if (!hasEncryption(params.schema)) {\r\n                    const retInstance = await args.storage.createStorageInstance(params);\r\n                    return retInstance;\r\n                }\r\n\r\n                if (!params.password) {\r\n                    throw newRxError('EN3', {\r\n                        database: params.databaseName,\r\n                        collection: params.collectionName,\r\n                        schema: params.schema\r\n                    });\r\n                }\r\n                const password = params.password;\r\n\r\n                const schemaWithoutEncrypted: RxJsonSchema<RxDocumentData<RxDocType>> = clone(params.schema);\r\n                delete schemaWithoutEncrypted.encrypted;\r\n                if (schemaWithoutEncrypted.attachments) {\r\n                    schemaWithoutEncrypted.attachments.encrypted = false;\r\n                }\r\n\r\n                /**\r\n                 * Encrypted data is always stored as string\r\n                 * so we have to change the schema to have \"type\": \"string\"\r\n                 * on encrypted fields.\r\n                 */\r\n                ensureNotFalsy(params.schema.encrypted).forEach(key => {\r\n                    (schemaWithoutEncrypted as any).properties[key].type = 'string';\r\n                    delete (schemaWithoutEncrypted as any).properties[key].properties;\r\n                });\r\n\r\n                const instance = await args.storage.createStorageInstance(\r\n                    Object.assign(\r\n                        {},\r\n                        params,\r\n                        {\r\n                            schema: schemaWithoutEncrypted\r\n                        }\r\n                    )\r\n                );\r\n\r\n                function modifyToStorage(docData: RxDocumentWriteData<RxDocType>) {\r\n                    docData = cloneWithoutAttachments(docData);\r\n                    ensureNotFalsy(params.schema.encrypted)\r\n                        .forEach(path => {\r\n                            const value = getProperty(docData, path);\r\n                            if (typeof value === 'undefined') {\r\n                                return;\r\n                            }\r\n\r\n                            const stringValue = JSON.stringify(value);\r\n                            const encrypted = encryptString(stringValue, password);\r\n                            setProperty(docData, path, encrypted);\r\n                        });\r\n\r\n                    // handle attachments\r\n                    if (\r\n                        params.schema.attachments &&\r\n                        params.schema.attachments.encrypted\r\n                    ) {\r\n                        const newAttachments: typeof docData._attachments = {};\r\n                        Object.entries(docData._attachments).forEach(([id, attachment]) => {\r\n                            const useAttachment: RxAttachmentWriteData = flatClone(attachment) as any;\r\n                            if (useAttachment.data) {\r\n                                const dataString = useAttachment.data;\r\n                                useAttachment.data = b64EncodeUnicode(encryptString(dataString, password));\r\n                            }\r\n                            newAttachments[id] = useAttachment;\r\n                        });\r\n                        docData._attachments = newAttachments;\r\n                    }\r\n                    return docData;\r\n                }\r\n                function modifyFromStorage(docData: RxDocumentData<any>): Promise<RxDocumentData<RxDocType>> {\r\n                    docData = cloneWithoutAttachments(docData);\r\n                    ensureNotFalsy(params.schema.encrypted)\r\n                        .forEach(path => {\r\n                            const value = getProperty(docData, path);\r\n                            if (typeof value === 'undefined') {\r\n                                return;\r\n                            }\r\n                            const decrypted = decryptString(value, password);\r\n                            const decryptedParsed = JSON.parse(decrypted);\r\n                            setProperty(docData, path, decryptedParsed);\r\n                        });\r\n                    return docData;\r\n                }\r\n\r\n                function modifyAttachmentFromStorage(attachmentData: string): string {\r\n                    if (\r\n                        params.schema.attachments &&\r\n                        params.schema.attachments.encrypted\r\n                    ) {\r\n                        const decrypted = decryptString(b64DecodeUnicode(attachmentData), password);\r\n                        return decrypted;\r\n                    } else {\r\n                        return attachmentData;\r\n                    }\r\n                }\r\n\r\n                return wrapRxStorageInstance(\r\n                    params.schema,\r\n                    instance,\r\n                    modifyToStorage,\r\n                    modifyFromStorage,\r\n                    modifyAttachmentFromStorage\r\n                );\r\n            }\r\n        }\r\n    );\r\n}\r\n\r\n\r\n\r\n\r\n\r\nfunction cloneWithoutAttachments<T>(data: RxDocumentWriteData<T>): RxDocumentData<T> {\r\n    const attachments = data._attachments;\r\n    data = flatClone(data);\r\n    delete (data as any)._attachments;\r\n    data = clone(data);\r\n    data._attachments = attachments;\r\n    return data as any;\r\n}\r\n\r\nfunction validatePassword(password: string) {\r\n    if (typeof password !== 'string') {\r\n        throw newRxTypeError('EN1', {\r\n            password\r\n        });\r\n    }\r\n    if (password.length < MINIMUM_PASSWORD_LENGTH) {\r\n        throw newRxError('EN2', {\r\n            minPassLength: MINIMUM_PASSWORD_LENGTH,\r\n            password\r\n        });\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]}