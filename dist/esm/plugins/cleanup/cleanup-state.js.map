{"version":3,"file":"cleanup-state.js","names":["PROMISE_RESOLVE_TRUE","REPLICATION_STATE_BY_COLLECTION","DEFAULT_CLEANUP_POLICY","initialCleanupWait","firstValueFrom","RXSTATE_CLEANUP_QUEUE","startCleanupForRxState","state","rxCollection","collection","rxDatabase","database","cleanupPolicy","Object","assign","closed","cleanupRxState","runCleanupAfterWrite","isDone","awaitReplicationsInSync","replicationStates","get","Promise","all","map","replicationState","isStopped","awaitInSync","then","requestIdlePromise","_cleanup","eventBulks$","catch","promiseWait","runEach"],"sources":["../../../../src/plugins/cleanup/cleanup-state.ts"],"sourcesContent":["import type { RxCleanupPolicy, RxState } from '../../types/index.d.ts';\r\nimport { PROMISE_RESOLVE_TRUE } from '../../plugins/utils/index.ts';\r\nimport { REPLICATION_STATE_BY_COLLECTION } from '../replication/index.ts';\r\nimport { DEFAULT_CLEANUP_POLICY } from './cleanup-helper.ts';\r\nimport { initialCleanupWait } from './cleanup.ts';\r\nimport { firstValueFrom } from 'rxjs';\r\n\r\nlet RXSTATE_CLEANUP_QUEUE: Promise<any> = PROMISE_RESOLVE_TRUE;\r\n\r\nexport async function startCleanupForRxState(state: RxState<unknown, unknown>) {\r\n    const rxCollection = state.collection;\r\n    const rxDatabase = rxCollection.database;\r\n    const cleanupPolicy = Object.assign(\r\n        {},\r\n        DEFAULT_CLEANUP_POLICY,\r\n        rxDatabase.cleanupPolicy ? rxDatabase.cleanupPolicy : {}\r\n    );\r\n\r\n    await initialCleanupWait(rxCollection, cleanupPolicy);\r\n    if (rxCollection.closed) {\r\n        return;\r\n    }\r\n\r\n    // initially cleanup the state\r\n    await cleanupRxState(state, cleanupPolicy);\r\n\r\n    /**\r\n     * Afterwards we listen to writes\r\n     * and only re-run the cleanup if there was a write\r\n     * to the state.\r\n     */\r\n    await runCleanupAfterWrite(state, cleanupPolicy);\r\n}\r\n/**\r\n * Runs the cleanup for a single RxState\r\n */\r\nexport async function cleanupRxState(\r\n    state: RxState<unknown, unknown>,\r\n    cleanupPolicy: RxCleanupPolicy\r\n) {\r\n    const rxCollection = state.collection;\r\n    const rxDatabase = rxCollection.database;\r\n\r\n    // run cleanup() until it returns true\r\n    let isDone = false;\r\n    while (!isDone && !rxCollection.closed) {\r\n        if (cleanupPolicy.awaitReplicationsInSync) {\r\n            const replicationStates = REPLICATION_STATE_BY_COLLECTION.get(rxCollection);\r\n            if (replicationStates) {\r\n                await Promise.all(\r\n                    replicationStates.map(replicationState => {\r\n                        if (!replicationState.isStopped()) {\r\n                            return replicationState.awaitInSync();\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n        }\r\n        if (rxCollection.closed) {\r\n            return;\r\n        }\r\n        RXSTATE_CLEANUP_QUEUE = RXSTATE_CLEANUP_QUEUE\r\n            .then(async () => {\r\n                if (rxCollection.closed) {\r\n                    return true;\r\n                }\r\n                await rxDatabase.requestIdlePromise();\r\n                return state._cleanup();\r\n            });\r\n        isDone = await RXSTATE_CLEANUP_QUEUE;\r\n    }\r\n}\r\n\r\nexport async function runCleanupAfterWrite(\r\n    state: RxState<unknown, unknown>,\r\n    cleanupPolicy: RxCleanupPolicy\r\n) {\r\n    const rxCollection = state.collection;\r\n    while (!rxCollection.closed) {\r\n        /**\r\n         * We only start the timer if there was actually a write\r\n         * to the collection. Otherwise the cleanup would\r\n         * just run on intervals even if nothing has changed.\r\n         */\r\n        await firstValueFrom(rxCollection.eventBulks$).catch(() => { });\r\n        await rxCollection.promiseWait(cleanupPolicy.runEach);\r\n        if (rxCollection.closed) {\r\n            return;\r\n        }\r\n        await cleanupRxState(state, cleanupPolicy);\r\n    }\r\n}\r\n"],"mappings":"AACA,SAASA,oBAAoB,QAAQ,8BAA8B;AACnE,SAASC,+BAA+B,QAAQ,yBAAyB;AACzE,SAASC,sBAAsB,QAAQ,qBAAqB;AAC5D,SAASC,kBAAkB,QAAQ,cAAc;AACjD,SAASC,cAAc,QAAQ,MAAM;AAErC,IAAIC,qBAAmC,GAAGL,oBAAoB;AAE9D,OAAO,eAAeM,sBAAsBA,CAACC,KAAgC,EAAE;EAC3E,IAAMC,YAAY,GAAGD,KAAK,CAACE,UAAU;EACrC,IAAMC,UAAU,GAAGF,YAAY,CAACG,QAAQ;EACxC,IAAMC,aAAa,GAAGC,MAAM,CAACC,MAAM,CAC/B,CAAC,CAAC,EACFZ,sBAAsB,EACtBQ,UAAU,CAACE,aAAa,GAAGF,UAAU,CAACE,aAAa,GAAG,CAAC,CAC3D,CAAC;EAED,MAAMT,kBAAkB,CAACK,YAAY,EAAEI,aAAa,CAAC;EACrD,IAAIJ,YAAY,CAACO,MAAM,EAAE;IACrB;EACJ;;EAEA;EACA,MAAMC,cAAc,CAACT,KAAK,EAAEK,aAAa,CAAC;;EAE1C;AACJ;AACA;AACA;AACA;EACI,MAAMK,oBAAoB,CAACV,KAAK,EAAEK,aAAa,CAAC;AACpD;AACA;AACA;AACA;AACA,OAAO,eAAeI,cAAcA,CAChCT,KAAgC,EAChCK,aAA8B,EAChC;EACE,IAAMJ,YAAY,GAAGD,KAAK,CAACE,UAAU;EACrC,IAAMC,UAAU,GAAGF,YAAY,CAACG,QAAQ;;EAExC;EACA,IAAIO,MAAM,GAAG,KAAK;EAClB,OAAO,CAACA,MAAM,IAAI,CAACV,YAAY,CAACO,MAAM,EAAE;IACpC,IAAIH,aAAa,CAACO,uBAAuB,EAAE;MACvC,IAAMC,iBAAiB,GAAGnB,+BAA+B,CAACoB,GAAG,CAACb,YAAY,CAAC;MAC3E,IAAIY,iBAAiB,EAAE;QACnB,MAAME,OAAO,CAACC,GAAG,CACbH,iBAAiB,CAACI,GAAG,CAACC,gBAAgB,IAAI;UACtC,IAAI,CAACA,gBAAgB,CAACC,SAAS,CAAC,CAAC,EAAE;YAC/B,OAAOD,gBAAgB,CAACE,WAAW,CAAC,CAAC;UACzC;QACJ,CAAC,CACL,CAAC;MACL;IACJ;IACA,IAAInB,YAAY,CAACO,MAAM,EAAE;MACrB;IACJ;IACAV,qBAAqB,GAAGA,qBAAqB,CACxCuB,IAAI,CAAC,YAAY;MACd,IAAIpB,YAAY,CAACO,MAAM,EAAE;QACrB,OAAO,IAAI;MACf;MACA,MAAML,UAAU,CAACmB,kBAAkB,CAAC,CAAC;MACrC,OAAOtB,KAAK,CAACuB,QAAQ,CAAC,CAAC;IAC3B,CAAC,CAAC;IACNZ,MAAM,GAAG,MAAMb,qBAAqB;EACxC;AACJ;AAEA,OAAO,eAAeY,oBAAoBA,CACtCV,KAAgC,EAChCK,aAA8B,EAChC;EACE,IAAMJ,YAAY,GAAGD,KAAK,CAACE,UAAU;EACrC,OAAO,CAACD,YAAY,CAACO,MAAM,EAAE;IACzB;AACR;AACA;AACA;AACA;IACQ,MAAMX,cAAc,CAACI,YAAY,CAACuB,WAAW,CAAC,CAACC,KAAK,CAAC,MAAM,CAAE,CAAC,CAAC;IAC/D,MAAMxB,YAAY,CAACyB,WAAW,CAACrB,aAAa,CAACsB,OAAO,CAAC;IACrD,IAAI1B,YAAY,CAACO,MAAM,EAAE;MACrB;IACJ;IACA,MAAMC,cAAc,CAACT,KAAK,EAAEK,aAAa,CAAC;EAC9C;AACJ","ignoreList":[]}