{"version":3,"file":"rx-migration-state.js","names":["Subject","filter","firstValueFrom","map","shareReplay","isBulkWriteConflictError","newRxError","MIGRATION_DEFAULT_BATCH_SIZE","addMigrationStateToDatabase","getOldCollectionMeta","migrateDocumentData","mustMigrate","PROMISE_RESOLVE_TRUE","RXJS_SHARE_REPLAY_DEFAULTS","clone","deepEqual","ensureNotFalsy","errorToPlainJson","getDefaultRevision","getDefaultRxDocumentMeta","getSingleDocument","hasEncryption","observeSingle","writeSingle","BroadcastChannel","createLeaderElection","META_INSTANCE_SCHEMA_TITLE","awaitRxStorageReplicationFirstInSync","cancelRxStorageReplication","defaultConflictHandler","getRxReplicationMetaInstanceSchema","replicateRxStorageInstance","rxStorageInstanceToReplicationHandler","overwritable","INTERNAL_CONTEXT_MIGRATION_STATUS","addConnectedStorageToCollection","getPrimaryKeyOfInternalDocument","normalizeMangoQuery","prepareQuery","RxMigrationState","collection","migrationStrategies","statusDocKey","name","schema","version","join","started","updateStatusHandlers","updateStatusQueue","database","oldCollectionMeta","statusDocId","$","internalStore","pipe","d","data","_proto","prototype","getStatus","startMigration","batchSize","must","broadcastChannel","undefined","multiInstance","leaderElector","awaitLeadership","oldStorageInstance","storage","createStorageInstance","databaseName","collectionName","databaseInstanceToken","token","options","password","devMode","isDevMode","connectedInstances","getConnectedStorageInstances","totalCount","countAllDoucments","concat","r","oldStorage","updateStatus","s","count","total","Promise","all","connectedInstance","newStorage","migrateStorage","close","storageInstance","originalStorageInstance","err","status","error","previous","document","Object","assign","_deleted","handler","push","then","length","useHandlers","newDoc","id","key","context","handled","percent","_meta","_rev","_attachments","oneHandler","Math","round","replicationMetaStorageInstance","replicationHandlerBase","replicationState","keepMeta","identifier","replicationHandler","masterChangesSince","resolve","checkpoint","documents","masterWrite","rows","row","newDocData","newDocumentState","title","docData","isCheckpoint","assumedMasterState","migratedDocData","newRow","result","masterChangeStream$","asObservable","forkInstance","metaInstance","pushBatchSize","pullBatchSize","conflictHandler","hashFunction","hasError","events","subscribe","processed","up","remove","storageInstances","ret","instance","preparedQuery","selector","countResult","connectedStorages","connectedStorage","Error","newSchema","jsonSchema","migratePromise","race"],"sources":["../../../../src/plugins/migration-schema/rx-migration-state.ts"],"sourcesContent":["import {\r\n    Observable,\r\n    Subject,\r\n    filter,\r\n    firstValueFrom,\r\n    map,\r\n    shareReplay\r\n} from 'rxjs';\r\nimport {\r\n    isBulkWriteConflictError,\r\n    newRxError\r\n} from '../../rx-error.ts';\r\nimport type {\r\n    NumberFunctionMap,\r\n    RxCollection,\r\n    RxDatabase,\r\n    RxError,\r\n    RxReplicationWriteToMasterRow,\r\n    RxStorageInstance,\r\n    RxTypeError\r\n} from '../../types/index.d.ts';\r\nimport {\r\n    MIGRATION_DEFAULT_BATCH_SIZE,\r\n    addMigrationStateToDatabase,\r\n    getOldCollectionMeta,\r\n    migrateDocumentData,\r\n    mustMigrate\r\n} from './migration-helpers.ts';\r\nimport {\r\n    PROMISE_RESOLVE_TRUE,\r\n    RXJS_SHARE_REPLAY_DEFAULTS,\r\n    clone,\r\n    deepEqual,\r\n    ensureNotFalsy,\r\n    errorToPlainJson,\r\n    getDefaultRevision,\r\n    getDefaultRxDocumentMeta\r\n} from '../utils/index.ts';\r\nimport type {\r\n    MigrationStatusUpdate,\r\n    RxMigrationStatus,\r\n    RxMigrationStatusDocument\r\n} from './migration-types.ts';\r\nimport {\r\n    getSingleDocument,\r\n    hasEncryption,\r\n    observeSingle,\r\n    writeSingle\r\n} from '../../rx-storage-helper.ts';\r\nimport {\r\n    BroadcastChannel,\r\n    createLeaderElection\r\n} from 'broadcast-channel';\r\nimport {\r\n    META_INSTANCE_SCHEMA_TITLE,\r\n    awaitRxStorageReplicationFirstInSync,\r\n    cancelRxStorageReplication,\r\n    defaultConflictHandler,\r\n    getRxReplicationMetaInstanceSchema,\r\n    replicateRxStorageInstance,\r\n    rxStorageInstanceToReplicationHandler\r\n} from '../../replication-protocol/index.ts';\r\nimport { overwritable } from '../../overwritable.ts';\r\nimport {\r\n    INTERNAL_CONTEXT_MIGRATION_STATUS,\r\n    addConnectedStorageToCollection,\r\n    getPrimaryKeyOfInternalDocument\r\n} from '../../rx-database-internal-store.ts';\r\nimport { normalizeMangoQuery, prepareQuery } from '../../rx-query-helper.ts';\r\n\r\n\r\n\r\nexport class RxMigrationState {\r\n\r\n    public database: RxDatabase;\r\n\r\n\r\n    private started: boolean = false;\r\n    public readonly oldCollectionMeta: ReturnType<typeof getOldCollectionMeta>;\r\n    public readonly mustMigrate: ReturnType<typeof mustMigrate>;\r\n    public readonly statusDocId: string;\r\n    public readonly $: Observable<RxMigrationStatus>;\r\n\r\n    constructor(\r\n        public readonly collection: RxCollection,\r\n        public readonly migrationStrategies: NumberFunctionMap,\r\n        public readonly statusDocKey = [\r\n            collection.name,\r\n            'v',\r\n            collection.schema.version\r\n        ].join('-'),\r\n    ) {\r\n        this.database = collection.database;\r\n        this.oldCollectionMeta = getOldCollectionMeta(this);\r\n        this.mustMigrate = mustMigrate(this);\r\n        this.statusDocId = getPrimaryKeyOfInternalDocument(\r\n            this.statusDocKey,\r\n            INTERNAL_CONTEXT_MIGRATION_STATUS\r\n        );\r\n        addMigrationStateToDatabase(this);\r\n\r\n        this.$ = observeSingle<RxMigrationStatusDocument>(\r\n            this.database.internalStore,\r\n            this.statusDocId\r\n        ).pipe(\r\n            filter(d => !!d),\r\n            map(d => ensureNotFalsy(d).data),\r\n            shareReplay(RXJS_SHARE_REPLAY_DEFAULTS)\r\n        );\r\n    }\r\n\r\n    getStatus() {\r\n        return firstValueFrom(this.$);\r\n    }\r\n\r\n\r\n    /**\r\n     * Starts the migration.\r\n     * Returns void so that people to not get the idea to await\r\n     * this function.\r\n     * Instead use migratePromise() if you want to await\r\n     * the migration. This ensures it works even if the migration\r\n     * is run on a different browser tab.\r\n     */\r\n    async startMigration(batchSize: number = MIGRATION_DEFAULT_BATCH_SIZE): Promise<void> {\r\n        const must = await this.mustMigrate;\r\n        if (!must) {\r\n            return;\r\n        }\r\n        if (this.started) {\r\n            throw newRxError('DM1');\r\n        }\r\n        this.started = true;\r\n\r\n\r\n        let broadcastChannel: BroadcastChannel | undefined = undefined;\r\n        /**\r\n         * To ensure that multiple tabs do not migrate the same collection,\r\n         * we use a new broadcastChannel/leaderElector for each collection.\r\n         * This is required because collections can be added dynamically and\r\n         * not all tabs might know about this collection.\r\n         */\r\n        if (this.database.multiInstance) {\r\n            broadcastChannel = new BroadcastChannel([\r\n                'rx-migration-state',\r\n                this.database.name,\r\n                this.collection.name,\r\n                this.collection.schema.version\r\n            ].join('|'));\r\n            const leaderElector = createLeaderElection(broadcastChannel);\r\n            await leaderElector.awaitLeadership();\r\n        }\r\n\r\n        /**\r\n         * Instead of writing a custom migration protocol,\r\n         * we do a push-only replication from the old collection data to the new one.\r\n         * This also ensure that restarting the replication works without problems.\r\n         */\r\n        const oldCollectionMeta = await this.oldCollectionMeta;\r\n        const oldStorageInstance = await this.database.storage.createStorageInstance({\r\n            databaseName: this.database.name,\r\n            collectionName: this.collection.name,\r\n            databaseInstanceToken: this.database.token,\r\n            multiInstance: this.database.multiInstance,\r\n            options: {},\r\n            schema: oldCollectionMeta.data.schema,\r\n            password: this.database.password,\r\n            devMode: overwritable.isDevMode()\r\n        });\r\n\r\n\r\n        const connectedInstances = await this.getConnectedStorageInstances();\r\n\r\n\r\n        /**\r\n         * Initially write the migration status into a meta document.\r\n         */\r\n        const totalCount = await this.countAllDoucments(\r\n            [oldStorageInstance].concat(connectedInstances.map(r => r.oldStorage))\r\n        );\r\n        await this.updateStatus(s => {\r\n            s.count.total = totalCount;\r\n            return s;\r\n        });\r\n\r\n\r\n        try {\r\n            /**\r\n             * First migrate the connected storages,\r\n             * afterwards migrate the normal collection.\r\n             */\r\n            await Promise.all(\r\n                connectedInstances.map(async (connectedInstance) => {\r\n                    await addConnectedStorageToCollection(\r\n                        this.collection,\r\n                        connectedInstance.newStorage.collectionName,\r\n                        connectedInstance.newStorage.schema\r\n                    );\r\n                    await this.migrateStorage(\r\n                        connectedInstance.oldStorage,\r\n                        connectedInstance.newStorage,\r\n                        batchSize\r\n                    );\r\n                    await connectedInstance.newStorage.close();\r\n                })\r\n            );\r\n\r\n            await this.migrateStorage(\r\n                oldStorageInstance,\r\n                /**\r\n                 * Use the originalStorageInstance here\r\n                 * so that the _meta.lwt time keeps the same\r\n                 * and our replication checkpoints still point to the\r\n                 * correct checkpoint.\r\n                 */\r\n                this.collection.storageInstance.originalStorageInstance,\r\n                batchSize\r\n            );\r\n        } catch (err) {\r\n            await oldStorageInstance.close();\r\n            await this.updateStatus(s => {\r\n                s.status = 'ERROR';\r\n                s.error = errorToPlainJson(err as Error);\r\n                return s;\r\n            });\r\n            return;\r\n        }\r\n\r\n\r\n        // remove old collection meta doc\r\n        await writeSingle(\r\n            this.database.internalStore,\r\n            {\r\n                previous: oldCollectionMeta,\r\n                document: Object.assign(\r\n                    {},\r\n                    oldCollectionMeta,\r\n                    {\r\n                        _deleted: true\r\n                    }\r\n                )\r\n            },\r\n            'rx-migration-remove-collection-meta'\r\n        );\r\n\r\n        await this.updateStatus(s => {\r\n            s.status = 'DONE';\r\n            return s;\r\n        });\r\n        if (broadcastChannel) {\r\n            await broadcastChannel.close();\r\n        }\r\n    }\r\n\r\n    public updateStatusHandlers: MigrationStatusUpdate[] = [];\r\n    public updateStatusQueue: Promise<any> = PROMISE_RESOLVE_TRUE;\r\n    public updateStatus(\r\n        handler: MigrationStatusUpdate\r\n    ) {\r\n        this.updateStatusHandlers.push(handler);\r\n        this.updateStatusQueue = this.updateStatusQueue.then(async () => {\r\n            if (this.updateStatusHandlers.length === 0) {\r\n                return;\r\n            }\r\n            // re-run until no conflict\r\n            const useHandlers = this.updateStatusHandlers;\r\n            this.updateStatusHandlers = [];\r\n            while (true) {\r\n                const previous = await getSingleDocument<RxMigrationStatusDocument>(\r\n                    this.database.internalStore,\r\n                    this.statusDocId\r\n                );\r\n                let newDoc = clone(previous);\r\n                if (!previous) {\r\n                    newDoc = {\r\n                        id: this.statusDocId,\r\n                        key: this.statusDocKey,\r\n                        context: INTERNAL_CONTEXT_MIGRATION_STATUS,\r\n                        data: {\r\n                            collectionName: this.collection.name,\r\n                            status: 'RUNNING',\r\n                            count: {\r\n                                total: 0,\r\n                                handled: 0,\r\n                                percent: 0\r\n                            }\r\n                        },\r\n                        _deleted: false,\r\n                        _meta: getDefaultRxDocumentMeta(),\r\n                        _rev: getDefaultRevision(),\r\n                        _attachments: {}\r\n                    };\r\n                }\r\n\r\n                let status = ensureNotFalsy(newDoc).data;\r\n                for (const oneHandler of useHandlers) {\r\n                    status = oneHandler(status);\r\n                }\r\n                status.count.percent = Math.round((status.count.handled / status.count.total) * 100);\r\n\r\n                if (\r\n                    newDoc && previous &&\r\n                    deepEqual(newDoc.data, previous.data)\r\n                ) {\r\n                    break;\r\n                }\r\n\r\n\r\n                try {\r\n                    await writeSingle<RxMigrationStatusDocument>(\r\n                        this.database.internalStore,\r\n                        {\r\n                            previous,\r\n                            document: ensureNotFalsy(newDoc)\r\n                        },\r\n                        INTERNAL_CONTEXT_MIGRATION_STATUS\r\n                    );\r\n\r\n                    // write successful\r\n                    break;\r\n                } catch (err) {\r\n                    // ignore conflicts\r\n                    if (!isBulkWriteConflictError(err)) {\r\n                        throw err;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return this.updateStatusQueue;\r\n    }\r\n\r\n\r\n    public async migrateStorage(\r\n        oldStorage: RxStorageInstance<any, any, any>,\r\n        newStorage: RxStorageInstance<any, any, any>,\r\n        batchSize: number\r\n    ) {\r\n        const replicationMetaStorageInstance = await this.database.storage.createStorageInstance({\r\n            databaseName: this.database.name,\r\n            collectionName: 'rx-migration-state-meta-' + this.collection.name + '-' + this.collection.schema.version,\r\n            databaseInstanceToken: this.database.token,\r\n            multiInstance: this.database.multiInstance,\r\n            options: {},\r\n            schema: getRxReplicationMetaInstanceSchema(oldStorage.schema, hasEncryption(oldStorage.schema)),\r\n            password: this.database.password,\r\n            devMode: overwritable.isDevMode()\r\n        });\r\n\r\n        const replicationHandlerBase = rxStorageInstanceToReplicationHandler(\r\n            newStorage,\r\n            /**\r\n             * Ignore push-conflicts.\r\n             * If this happens we drop the 'old' document state.\r\n             */\r\n            defaultConflictHandler,\r\n            this.database.token,\r\n            true\r\n        );\r\n\r\n        const replicationState = replicateRxStorageInstance({\r\n            keepMeta: true,\r\n            identifier: [\r\n                'rx-migration-state',\r\n                this.collection.name,\r\n                oldStorage.schema.version,\r\n                this.collection.schema.version\r\n            ].join('-'),\r\n            replicationHandler: {\r\n                masterChangesSince() {\r\n                    return Promise.resolve({\r\n                        checkpoint: null,\r\n                        documents: []\r\n                    });\r\n                },\r\n                masterWrite: async (rows) => {\r\n                    rows = await Promise.all(\r\n                        rows\r\n                            .map(async (row) => {\r\n                                let newDocData = row.newDocumentState;\r\n                                if (newStorage.schema.title === META_INSTANCE_SCHEMA_TITLE) {\r\n                                    newDocData = row.newDocumentState.docData;\r\n                                    if (row.newDocumentState.isCheckpoint === '1') {\r\n                                        return {\r\n                                            assumedMasterState: undefined,\r\n                                            newDocumentState: row.newDocumentState\r\n                                        };\r\n                                    }\r\n                                }\r\n                                const migratedDocData: RxReplicationWriteToMasterRow<any> = await migrateDocumentData(\r\n                                    this.collection,\r\n                                    oldStorage.schema.version,\r\n                                    newDocData\r\n                                );\r\n                                const newRow: RxReplicationWriteToMasterRow<any> = {\r\n                                    // drop the assumed master state, we do not have to care about conflicts here.\r\n                                    assumedMasterState: undefined,\r\n                                    newDocumentState: newStorage.schema.title === META_INSTANCE_SCHEMA_TITLE\r\n                                        ? Object.assign({}, row.newDocumentState, { docData: migratedDocData })\r\n                                        : migratedDocData\r\n                                };\r\n                                return newRow;\r\n                            })\r\n                    );\r\n\r\n                    // filter out the documents where the migration strategy returned null\r\n                    rows = rows.filter(row => !!row.newDocumentState);\r\n\r\n                    const result = await replicationHandlerBase.masterWrite(rows);\r\n                    return result;\r\n                },\r\n                masterChangeStream$: new Subject<any>().asObservable()\r\n            },\r\n            forkInstance: oldStorage,\r\n            metaInstance: replicationMetaStorageInstance,\r\n            pushBatchSize: batchSize,\r\n            pullBatchSize: 0,\r\n            conflictHandler: defaultConflictHandler,\r\n            hashFunction: this.database.hashFunction\r\n        });\r\n\r\n\r\n        let hasError: RxError | RxTypeError | false = false;\r\n        replicationState.events.error.subscribe(err => hasError = err);\r\n\r\n        // update replication status on each change\r\n        replicationState.events.processed.up.subscribe(() => {\r\n            this.updateStatus(status => {\r\n                status.count.handled = status.count.handled + 1;\r\n                return status;\r\n            });\r\n        });\r\n\r\n        await awaitRxStorageReplicationFirstInSync(replicationState);\r\n        await cancelRxStorageReplication(replicationState);\r\n\r\n        await this.updateStatusQueue;\r\n        if (hasError) {\r\n            await replicationMetaStorageInstance.close();\r\n            throw hasError;\r\n        }\r\n\r\n        // cleanup old storages\r\n        await Promise.all([\r\n            oldStorage.remove(),\r\n            replicationMetaStorageInstance.remove()\r\n        ]);\r\n    }\r\n\r\n    public async countAllDoucments(\r\n        storageInstances: RxStorageInstance<any, any, any>[]\r\n    ): Promise<number> {\r\n        let ret = 0;\r\n        await Promise.all(\r\n            storageInstances.map(async (instance) => {\r\n\r\n                const preparedQuery = prepareQuery(\r\n                    instance.schema,\r\n                    normalizeMangoQuery(\r\n                        instance.schema,\r\n                        {\r\n                            selector: {}\r\n                        }\r\n                    )\r\n                );\r\n                const countResult = await instance.count(preparedQuery);\r\n                ret += countResult.count;\r\n            })\r\n        );\r\n        return ret;\r\n    }\r\n\r\n    public async getConnectedStorageInstances() {\r\n        const oldCollectionMeta = await this.oldCollectionMeta;\r\n        const ret: {\r\n            oldStorage: RxStorageInstance<any, any, any>;\r\n            newStorage: RxStorageInstance<any, any, any>;\r\n        }[] = [];\r\n\r\n        await Promise.all(\r\n            await Promise.all(\r\n                oldCollectionMeta\r\n                    .data\r\n                    .connectedStorages\r\n                    .map(async (connectedStorage) => {\r\n\r\n                        // atm we can only migrate replication states.\r\n                        if (connectedStorage.schema.title !== META_INSTANCE_SCHEMA_TITLE) {\r\n                            throw new Error('unknown migration handling for schema');\r\n                        }\r\n\r\n                        const newSchema = getRxReplicationMetaInstanceSchema(\r\n                            clone(this.collection.schema.jsonSchema),\r\n                            hasEncryption(connectedStorage.schema)\r\n                        );\r\n                        newSchema.version = this.collection.schema.version;\r\n                        const [oldStorage, newStorage] = await Promise.all([\r\n                            this.database.storage.createStorageInstance({\r\n                                databaseInstanceToken: this.database.token,\r\n                                databaseName: this.database.name,\r\n                                devMode: overwritable.isDevMode(),\r\n                                multiInstance: this.database.multiInstance,\r\n                                options: {},\r\n                                schema: connectedStorage.schema,\r\n                                password: this.database.password,\r\n                                collectionName: connectedStorage.collectionName\r\n                            }),\r\n                            this.database.storage.createStorageInstance({\r\n                                databaseInstanceToken: this.database.token,\r\n                                databaseName: this.database.name,\r\n                                devMode: overwritable.isDevMode(),\r\n                                multiInstance: this.database.multiInstance,\r\n                                options: {},\r\n                                schema: newSchema,\r\n                                password: this.database.password,\r\n                                collectionName: connectedStorage.collectionName\r\n                            })\r\n                        ]);\r\n                        ret.push({ oldStorage, newStorage });\r\n                    })\r\n            )\r\n        );\r\n\r\n        return ret;\r\n    }\r\n\r\n\r\n\r\n    async migratePromise(batchSize?: number): Promise<RxMigrationStatus> {\r\n        this.startMigration(batchSize);\r\n        const must = await this.mustMigrate;\r\n        if (!must) {\r\n            return {\r\n                status: 'DONE',\r\n                collectionName: this.collection.name,\r\n                count: {\r\n                    handled: 0,\r\n                    percent: 0,\r\n                    total: 0\r\n                }\r\n            };\r\n        }\r\n\r\n        const result = await Promise.race([\r\n            firstValueFrom(\r\n                this.$.pipe(\r\n                    filter(d => d.status === 'DONE')\r\n                )\r\n            ),\r\n            firstValueFrom(\r\n                this.$.pipe(\r\n                    filter(d => d.status === 'ERROR')\r\n                )\r\n            )\r\n        ]);\r\n\r\n        if (result.status === 'ERROR') {\r\n            throw newRxError('DM4', {\r\n                collection: this.collection.name,\r\n                error: result.error\r\n            });\r\n        } else {\r\n            return result;\r\n        }\r\n\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]}