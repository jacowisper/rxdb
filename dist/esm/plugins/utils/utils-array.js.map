{"version":3,"file":"utils-array.js","names":["lastOfArray","ar","length","shuffleArray","arr","slice","sort","Math","random","randomOfArray","randomElement","floor","toArray","input","Array","isArray","batchArray","array","batchSize","ret","batch","splice","push","removeOneFromArrayIfMatches","condition","i","done","isMaybeReadonlyArray","x","isOneItemOfArrayInOtherArray","ar1","ar2","el","has","includes","arrayFilterNotEmpty","value","undefined","countUntilNotMatching","matchingFn","count","idx","item","matching","asyncFilter","predicate","filters","Promise","all","map","filter","index","sumNumberArray","maxOfNumbers","max","appendToArray","add","addSize","baseSize","uniqueArray","arrArg","elem","pos","indexOf","sortByObjectNumberProperty","property","a","b"],"sources":["../../../../src/plugins/utils/utils-array.ts"],"sourcesContent":["import type {\r\n    MaybePromise,\r\n    MaybeReadonly\r\n} from '../../types/index.d.ts';\r\n\r\nexport function lastOfArray<T>(ar: T[]): T | undefined {\r\n    return ar[ar.length - 1];\r\n}\r\n\r\n/**\r\n * shuffle the given array\r\n */\r\nexport function shuffleArray<T>(arr: T[]): T[] {\r\n    return arr.slice(0).sort(() => (Math.random() - 0.5));\r\n}\r\n\r\nexport function randomOfArray<T>(arr: T[]): T {\r\n    const randomElement = arr[Math.floor(Math.random() * arr.length)];\r\n    return randomElement;\r\n}\r\n\r\n\r\nexport function toArray<T>(input: T | T[] | Readonly<T> | Readonly<T[]>): T[] {\r\n    return Array.isArray(input) ? (input as any[]).slice(0) : ([input] as any);\r\n}\r\n\r\n/**\r\n * Split array with items into smaller arrays with items\r\n * @link https://stackoverflow.com/a/7273794/3443137\r\n */\r\nexport function batchArray<T>(array: T[], batchSize: number): T[][] {\r\n    array = array.slice(0);\r\n    const ret: T[][] = [];\r\n    while (array.length) {\r\n        const batch = array.splice(0, batchSize);\r\n        ret.push(batch);\r\n    }\r\n    return ret;\r\n}\r\n\r\n/**\r\n * @link https://stackoverflow.com/a/15996017\r\n */\r\nexport function removeOneFromArrayIfMatches<T>(ar: T[], condition: (x: T) => boolean): T[] {\r\n    ar = ar.slice();\r\n    let i = ar.length;\r\n    let done = false;\r\n    while (i-- && !done) {\r\n        if (condition(ar[i])) {\r\n            done = true;\r\n            ar.splice(i, 1);\r\n        }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/**\r\n * returns true if the supplied argument is either an Array<T> or a Readonly<Array<T>>\r\n */\r\nexport function isMaybeReadonlyArray(x: any): x is MaybeReadonly<any[]> {\r\n    // While this looks strange, it's a workaround for an issue in TypeScript:\r\n    // https://github.com/microsoft/TypeScript/issues/17002\r\n    //\r\n    // The problem is that `Array.isArray` as a type guard returns `false` for a readonly array,\r\n    // but at runtime the object is an array and the runtime call to `Array.isArray` would return `true`.\r\n    // The type predicate here allows for both `Array<T>` and `Readonly<Array<T>>` to pass a type check while\r\n    // still performing runtime type inspection.\r\n    return Array.isArray(x);\r\n}\r\n\r\n\r\n\r\nexport function isOneItemOfArrayInOtherArray<T>(ar1: T[], ar2: T[]): boolean {\r\n    for (let i = 0; i < ar1.length; i++) {\r\n        const el = ar1[i];\r\n        const has = ar2.includes(el);\r\n        if (has) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\n/**\r\n * Use this in array.filter() to remove all empty slots\r\n * and have the correct typings afterwards.\r\n * @link https://stackoverflow.com/a/46700791/3443137\r\n */\r\nexport function arrayFilterNotEmpty<TValue>(value: TValue | null | undefined): value is TValue {\r\n    if (value === null || value === undefined) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nexport function countUntilNotMatching<T>(\r\n    ar: T[],\r\n    matchingFn: (v: T, idx: number) => boolean\r\n): number {\r\n    let count = 0;\r\n    let idx = -1;\r\n    for (const item of ar) {\r\n        idx = idx + 1;\r\n        const matching = matchingFn(item, idx);\r\n        if (matching) {\r\n            count = count + 1;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    return count;\r\n}\r\n\r\nexport async function asyncFilter<T>(array: T[], predicate: (item: T, index: number, a: T[]) => MaybePromise<boolean>): Promise<T[]> {\r\n    const filters = await Promise.all(\r\n        array.map(predicate)\r\n    );\r\n\r\n    return array.filter((...[, index]) => filters[index]);\r\n}\r\n\r\n/**\r\n * @link https://stackoverflow.com/a/3762735\r\n */\r\nexport function sumNumberArray(array: number[]): number {\r\n    let count = 0;\r\n    for (let i = array.length; i--;) {\r\n        count += array[i];\r\n    }\r\n    return count;\r\n}\r\n\r\nexport function maxOfNumbers(arr: number[]): number {\r\n    return Math.max(...arr);\r\n}\r\n\r\n\r\n/**\r\n * Appends the given documents to the given array.\r\n * This will mutate the first given array.\r\n * Mostly used as faster alternative to Array.concat()\r\n * because .concat() is so slow.\r\n * @link https://www.measurethat.net/Benchmarks/Show/4223/0/array-concat-vs-spread-operator-vs-push#latest_results_block\r\n * \r\n * TODO it turns out that in mid 2024 v8 has optimized Array.concat()\r\n * so it might be faster to just use concat() again:\r\n * @link https://jsperf.app/qiqawa/10\r\n */\r\nexport function appendToArray<T>(ar: T[], add: T[] | readonly T[]): void {\r\n    /**\r\n     * Pre-increasing the array size has turned out\r\n     * to be way faster when big arrays must be handled.\r\n     * @link https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki\r\n     */\r\n    const addSize = add.length;\r\n    if (addSize === 0) {\r\n        return;\r\n    }\r\n    const baseSize = ar.length;\r\n    ar.length = baseSize + add.length;\r\n    for (let i = 0; i < addSize; ++i) {\r\n        ar[baseSize + i] = add[i];\r\n    }\r\n}\r\n\r\n/**\r\n * @link https://gist.github.com/telekosmos/3b62a31a5c43f40849bb\r\n */\r\nexport function uniqueArray(arrArg: string[]): string[] {\r\n    return arrArg.filter(function (elem, pos, arr) {\r\n        return arr.indexOf(elem) === pos;\r\n    });\r\n}\r\n\r\n\r\nexport function sortByObjectNumberProperty<T>(property: keyof T) {\r\n    return (a: T, b: T) => {\r\n        return (b as any)[property] - (a as any)[property];\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]}