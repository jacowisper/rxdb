{"version":3,"file":"conflicts.js","names":["getDefaultRevision","createRevision","now","flatClone","resolveConflictError","state","input","forkState","conflictHandler","isEqual","realMasterState","newDocumentState","undefined","resolved","resolve","resolvedDoc","Object","assign","_meta","_rev","_attachments","lwt","checkpointKey"],"sources":["../../../src/replication-protocol/conflicts.ts"],"sourcesContent":["import type {\r\n    RxConflictHandler,\r\n    RxConflictHandlerInput,\r\n    RxDocumentData,\r\n    RxStorageInstanceReplicationState\r\n} from '../types/index.d.ts';\r\nimport {\r\n    getDefaultRevision,\r\n    createRevision,\r\n    now,\r\n    flatClone\r\n} from '../plugins/utils/index.ts';\r\n\r\n/**\r\n * Resolves a conflict error or determines that the given document states are equal.\r\n * Returns the resolved document that must be written to the fork.\r\n * Then the new document state can be pushed upstream.\r\n * If document is not in conflict, returns undefined.\r\n * If error is non-409, it throws an error.\r\n * Conflicts are only solved in the upstream, never in the downstream.\r\n */\r\nexport async function resolveConflictError<RxDocType>(\r\n    state: RxStorageInstanceReplicationState<RxDocType>,\r\n    input: RxConflictHandlerInput<RxDocType>,\r\n    forkState: RxDocumentData<RxDocType>\r\n): Promise<RxDocumentData<RxDocType> | undefined> {\r\n    const conflictHandler: RxConflictHandler<RxDocType> = state.input.conflictHandler;\r\n\r\n    const isEqual = conflictHandler.isEqual(input.realMasterState, input.newDocumentState, 'replication-resolve-conflict');\r\n\r\n    if (isEqual) {\r\n        /**\r\n         * Documents are equal,\r\n         * so this is not a conflict -> do nothing.\r\n         */\r\n        return undefined;\r\n    } else {\r\n        const resolved = await conflictHandler.resolve(input, 'replication-resolve-conflict');\r\n        /**\r\n         * We have a resolved conflict,\r\n         * use the resolved document data.\r\n         */\r\n        const resolvedDoc: RxDocumentData<RxDocType> = Object.assign(\r\n            {},\r\n            resolved,\r\n            {\r\n                /**\r\n                 * Because the resolved conflict is written to the fork,\r\n                 * we have to keep/update the forks _meta data, not the masters.\r\n                 */\r\n                _meta: flatClone(forkState._meta),\r\n                _rev: getDefaultRevision(),\r\n                _attachments: flatClone(forkState._attachments)\r\n            }\r\n        ) as any;\r\n        resolvedDoc._meta.lwt = now();\r\n        resolvedDoc._rev = createRevision(\r\n            await state.checkpointKey,\r\n            forkState\r\n        );\r\n        return resolvedDoc;\r\n    }\r\n}\r\n"],"mappings":"AAMA,SACIA,kBAAkB,EAClBC,cAAc,EACdC,GAAG,EACHC,SAAS,QACN,2BAA2B;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeC,oBAAoBA,CACtCC,KAAmD,EACnDC,KAAwC,EACxCC,SAAoC,EACU;EAC9C,IAAMC,eAA6C,GAAGH,KAAK,CAACC,KAAK,CAACE,eAAe;EAEjF,IAAMC,OAAO,GAAGD,eAAe,CAACC,OAAO,CAACH,KAAK,CAACI,eAAe,EAAEJ,KAAK,CAACK,gBAAgB,EAAE,8BAA8B,CAAC;EAEtH,IAAIF,OAAO,EAAE;IACT;AACR;AACA;AACA;IACQ,OAAOG,SAAS;EACpB,CAAC,MAAM;IACH,IAAMC,QAAQ,GAAG,MAAML,eAAe,CAACM,OAAO,CAACR,KAAK,EAAE,8BAA8B,CAAC;IACrF;AACR;AACA;AACA;IACQ,IAAMS,WAAsC,GAAGC,MAAM,CAACC,MAAM,CACxD,CAAC,CAAC,EACFJ,QAAQ,EACR;MACI;AAChB;AACA;AACA;MACgBK,KAAK,EAAEf,SAAS,CAACI,SAAS,CAACW,KAAK,CAAC;MACjCC,IAAI,EAAEnB,kBAAkB,CAAC,CAAC;MAC1BoB,YAAY,EAAEjB,SAAS,CAACI,SAAS,CAACa,YAAY;IAClD,CACJ,CAAQ;IACRL,WAAW,CAACG,KAAK,CAACG,GAAG,GAAGnB,GAAG,CAAC,CAAC;IAC7Ba,WAAW,CAACI,IAAI,GAAGlB,cAAc,CAC7B,MAAMI,KAAK,CAACiB,aAAa,EACzBf,SACJ,CAAC;IACD,OAAOQ,WAAW;EACtB;AACJ","ignoreList":[]}