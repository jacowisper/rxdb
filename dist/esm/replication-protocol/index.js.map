{"version":3,"file":"index.js","names":["BehaviorSubject","combineLatest","filter","firstValueFrom","mergeMap","Subject","getPrimaryFieldOfPrimaryKey","clone","ensureNotFalsy","flatClone","PROMISE_RESOLVE_VOID","getCheckpointKey","startReplicationDownstream","docStateToWriteDoc","getUnderlyingPersistentStorage","writeDocToDocState","startReplicationUpstream","fillWriteDataForAttachmentsChange","getChangedDocumentsSince","newRxError","replicateRxStorageInstance","input","forkInstance","metaInstance","checkpointKeyPromise","state","primaryPath","schema","primaryKey","hasAttachments","attachments","checkpointKey","downstreamBulkWriteFlag","then","events","canceled","paused","active","down","up","processed","resolvedConflicts","error","stats","addNewTask","downstreamProcessChanges","downstreamResyncOnce","masterChangeStreamEmit","persistFromMaster","forkChangeStreamEmit","persistToMaster","persistToMasterConflictWrites","persistToMasterHadConflicts","processTasks","upstreamInitialSync","firstSyncDone","streamQueue","checkpointQueue","lastCheckpointDoc","awaitRxStorageReplicationFirstInSync","pipe","v","awaitRxStorageReplicationInSync","replicationState","Promise","all","awaitRxStorageReplicationIdle","rxStorageInstanceToReplicationHandler","instance","conflictHandler","databaseInstanceToken","keepMeta","replicationHandler","masterChangeStream$","changeStream","eventBulk","ret","checkpoint","documents","map","event","docData","documentData","undefined","masterChangesSince","batchSize","result","length","plainDocumentData","masterWrite","rows","rowById","forEach","row","docId","newDocumentState","ids","Object","keys","masterDocsStateList","findDocumentsById","masterDocsState","Map","doc","set","conflicts","writeRows","entries","id","masterState","get","push","document","assumedMasterState","isEqual","previous","bulkWrite","err","status","name","documentInDb","cancelRxStorageReplication","next","complete"],"sources":["../../../src/replication-protocol/index.ts"],"sourcesContent":["/**\r\n * These files contain the replication protocol.\r\n * It can be used to replicated RxStorageInstances or RxCollections\r\n * or even to do a client(s)-server replication.\r\n */\r\n\r\n\r\nimport {\r\n    BehaviorSubject,\r\n    combineLatest,\r\n    filter,\r\n    firstValueFrom,\r\n    mergeMap,\r\n    Subject\r\n} from 'rxjs';\r\nimport {\r\n    getPrimaryFieldOfPrimaryKey\r\n} from '../rx-schema-helper.ts';\r\nimport type {\r\n    BulkWriteRow,\r\n    ById,\r\n    DocumentsWithCheckpoint,\r\n    RxConflictHandler,\r\n    RxDocumentData,\r\n    RxReplicationHandler,\r\n    RxReplicationWriteToMasterRow,\r\n    RxStorageInstance,\r\n    RxStorageInstanceReplicationInput,\r\n    RxStorageInstanceReplicationState,\r\n    WithDeleted\r\n} from '../types/index.d.ts';\r\nimport {\r\n    clone,\r\n    ensureNotFalsy,\r\n    flatClone,\r\n    PROMISE_RESOLVE_VOID\r\n} from '../plugins/utils/index.ts';\r\nimport {\r\n    getCheckpointKey\r\n} from './checkpoint.ts';\r\nimport { startReplicationDownstream } from './downstream.ts';\r\nimport { docStateToWriteDoc, getUnderlyingPersistentStorage, writeDocToDocState } from './helper.ts';\r\nimport { startReplicationUpstream } from './upstream.ts';\r\nimport { fillWriteDataForAttachmentsChange } from '../plugins/attachments/index.ts';\r\nimport { getChangedDocumentsSince } from '../rx-storage-helper.ts';\r\nimport { newRxError } from '../rx-error.ts';\r\n\r\n\r\nexport * from './checkpoint.ts';\r\nexport * from './downstream.ts';\r\nexport * from './upstream.ts';\r\nexport * from './meta-instance.ts';\r\nexport * from './conflicts.ts';\r\nexport * from './helper.ts';\r\nexport * from './default-conflict-handler.ts';\r\n\r\n\r\nexport function replicateRxStorageInstance<RxDocType>(\r\n    input: RxStorageInstanceReplicationInput<RxDocType>\r\n): RxStorageInstanceReplicationState<RxDocType> {\r\n    input = flatClone(input);\r\n    input.forkInstance = getUnderlyingPersistentStorage(input.forkInstance);\r\n    input.metaInstance = getUnderlyingPersistentStorage(input.metaInstance);\r\n    const checkpointKeyPromise = getCheckpointKey(input);\r\n    const state: RxStorageInstanceReplicationState<RxDocType> = {\r\n        primaryPath: getPrimaryFieldOfPrimaryKey(input.forkInstance.schema.primaryKey),\r\n        hasAttachments: !!input.forkInstance.schema.attachments,\r\n        input,\r\n        checkpointKey: checkpointKeyPromise,\r\n        downstreamBulkWriteFlag: checkpointKeyPromise.then(checkpointKey => 'replication-downstream-' + checkpointKey),\r\n        events: {\r\n            canceled: new BehaviorSubject<boolean>(false),\r\n            paused: new BehaviorSubject<boolean>(false),\r\n            active: {\r\n                down: new BehaviorSubject<boolean>(true),\r\n                up: new BehaviorSubject<boolean>(true)\r\n            },\r\n            processed: {\r\n                down: new Subject(),\r\n                up: new Subject()\r\n            },\r\n            resolvedConflicts: new Subject(),\r\n            error: new Subject()\r\n        },\r\n        stats: {\r\n            down: {\r\n                addNewTask: 0,\r\n                downstreamProcessChanges: 0,\r\n                downstreamResyncOnce: 0,\r\n                masterChangeStreamEmit: 0,\r\n                persistFromMaster: 0\r\n            },\r\n            up: {\r\n                forkChangeStreamEmit: 0,\r\n                persistToMaster: 0,\r\n                persistToMasterConflictWrites: 0,\r\n                persistToMasterHadConflicts: 0,\r\n                processTasks: 0,\r\n                upstreamInitialSync: 0\r\n            }\r\n        },\r\n        firstSyncDone: {\r\n            down: new BehaviorSubject<boolean>(false),\r\n            up: new BehaviorSubject<boolean>(false)\r\n        },\r\n        streamQueue: {\r\n            down: PROMISE_RESOLVE_VOID,\r\n            up: PROMISE_RESOLVE_VOID\r\n        },\r\n        checkpointQueue: PROMISE_RESOLVE_VOID,\r\n        lastCheckpointDoc: {}\r\n    };\r\n\r\n    startReplicationDownstream(state);\r\n    startReplicationUpstream(state);\r\n    return state;\r\n}\r\n\r\nexport function awaitRxStorageReplicationFirstInSync(\r\n    state: RxStorageInstanceReplicationState<any>\r\n): Promise<void> {\r\n    return firstValueFrom(\r\n        combineLatest([\r\n            state.firstSyncDone.down.pipe(\r\n                filter(v => !!v)\r\n            ),\r\n            state.firstSyncDone.up.pipe(\r\n                filter(v => !!v)\r\n            )\r\n        ])\r\n    ).then(() => { });\r\n}\r\n\r\nexport function awaitRxStorageReplicationInSync(\r\n    replicationState: RxStorageInstanceReplicationState<any>\r\n) {\r\n    return Promise.all([\r\n        replicationState.streamQueue.up,\r\n        replicationState.streamQueue.down,\r\n        replicationState.checkpointQueue\r\n    ]);\r\n}\r\n\r\n\r\nexport async function awaitRxStorageReplicationIdle(\r\n    state: RxStorageInstanceReplicationState<any>\r\n) {\r\n    await awaitRxStorageReplicationFirstInSync(state);\r\n    while (true) {\r\n        const { down, up } = state.streamQueue;\r\n        await Promise.all([\r\n            up,\r\n            down\r\n        ]);\r\n        /**\r\n         * If the Promises have not been reassigned\r\n         * after awaiting them, we know that the replication\r\n         * is in idle state at this point in time.\r\n         */\r\n        if (\r\n            down === state.streamQueue.down &&\r\n            up === state.streamQueue.up\r\n        ) {\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport function rxStorageInstanceToReplicationHandler<RxDocType, MasterCheckpointType>(\r\n    instance: RxStorageInstance<RxDocType, any, any, MasterCheckpointType>,\r\n    conflictHandler: RxConflictHandler<RxDocType>,\r\n    databaseInstanceToken: string,\r\n    /**\r\n     * If set to true,\r\n     * the _meta.lwt from the pushed documents is kept.\r\n     * (Used in the migration to ensure checkpoints are still valid)\r\n     */\r\n    keepMeta: boolean = false\r\n): RxReplicationHandler<RxDocType, MasterCheckpointType> {\r\n    instance = getUnderlyingPersistentStorage(instance);\r\n\r\n    const hasAttachments = !!instance.schema.attachments;\r\n    const primaryPath = getPrimaryFieldOfPrimaryKey(instance.schema.primaryKey);\r\n    const replicationHandler: RxReplicationHandler<RxDocType, MasterCheckpointType> = {\r\n        masterChangeStream$: instance.changeStream().pipe(\r\n            mergeMap(async (eventBulk) => {\r\n                const ret: DocumentsWithCheckpoint<RxDocType, MasterCheckpointType> = {\r\n                    checkpoint: eventBulk.checkpoint,\r\n                    documents: await Promise.all(\r\n                        eventBulk.events.map(async (event) => {\r\n                            let docData = writeDocToDocState(event.documentData, hasAttachments, keepMeta);\r\n                            if (hasAttachments) {\r\n                                docData = await fillWriteDataForAttachmentsChange(\r\n                                    primaryPath,\r\n                                    instance,\r\n                                    clone(docData),\r\n                                    /**\r\n                                     * Notice that the master never knows\r\n                                     * the client state of the document.\r\n                                     * Therefore we always send all attachments data.\r\n                                     */\r\n                                    undefined\r\n                                );\r\n                            }\r\n                            return docData;\r\n                        })\r\n                    )\r\n                };\r\n                return ret;\r\n            })\r\n        ),\r\n        masterChangesSince(\r\n            checkpoint,\r\n            batchSize\r\n        ) {\r\n            return getChangedDocumentsSince(\r\n                instance,\r\n                batchSize,\r\n                checkpoint\r\n            ).then(async (result) => {\r\n                return {\r\n                    checkpoint: result.documents.length > 0 ? result.checkpoint : checkpoint,\r\n                    documents: await Promise.all(\r\n                        result.documents.map(async (plainDocumentData) => {\r\n                            let docData = writeDocToDocState(plainDocumentData, hasAttachments, keepMeta);\r\n                            if (hasAttachments) {\r\n                                docData = await fillWriteDataForAttachmentsChange(\r\n                                    primaryPath,\r\n                                    instance,\r\n                                    clone(docData),\r\n                                    /**\r\n                                     * Notice the the master never knows\r\n                                     * the client state of the document.\r\n                                     * Therefore we always send all attachments data.\r\n                                     */\r\n                                    undefined\r\n                                );\r\n                            }\r\n                            return docData;\r\n                        })\r\n                    )\r\n                };\r\n            });\r\n        },\r\n        async masterWrite(\r\n            rows\r\n        ) {\r\n            const rowById: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};\r\n            rows.forEach(row => {\r\n                const docId: string = (row.newDocumentState as any)[primaryPath];\r\n                rowById[docId] = row;\r\n            });\r\n            const ids = Object.keys(rowById);\r\n\r\n            const masterDocsStateList = await instance.findDocumentsById(\r\n                ids,\r\n                true\r\n            );\r\n            const masterDocsState = new Map<string, RxDocumentData<RxDocType>>();\r\n            masterDocsStateList.forEach(doc => masterDocsState.set((doc as any)[primaryPath], doc));\r\n            const conflicts: WithDeleted<RxDocType>[] = [];\r\n            const writeRows: BulkWriteRow<RxDocType>[] = [];\r\n            await Promise.all(\r\n                Object.entries(rowById)\r\n                    .map(([id, row]) => {\r\n                        const masterState = masterDocsState.get(id);\r\n                        if (!masterState) {\r\n                            writeRows.push({\r\n                                document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState)\r\n                            });\r\n                        } else if (\r\n                            masterState &&\r\n                            !row.assumedMasterState\r\n                        ) {\r\n                            conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\r\n                        } else if (\r\n                            conflictHandler.isEqual(\r\n                                writeDocToDocState(masterState, hasAttachments, keepMeta),\r\n                                ensureNotFalsy(row.assumedMasterState),\r\n                                'rxStorageInstanceToReplicationHandler-masterWrite'\r\n                            ) === true\r\n                        ) {\r\n                            writeRows.push({\r\n                                previous: masterState,\r\n                                document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState, masterState)\r\n                            });\r\n                        } else {\r\n                            conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\r\n                        }\r\n                    })\r\n            );\r\n\r\n            if (writeRows.length > 0) {\r\n                const result = await instance.bulkWrite(\r\n                    writeRows,\r\n                    'replication-master-write'\r\n                );\r\n\r\n                result.error.forEach(err => {\r\n                    if (err.status !== 409) {\r\n                        throw newRxError('SNH', {\r\n                            name: 'non conflict error',\r\n                            error: err as any\r\n                        });\r\n                    } else {\r\n                        conflicts.push(\r\n                            writeDocToDocState(ensureNotFalsy(err.documentInDb), hasAttachments, keepMeta)\r\n                        );\r\n                    }\r\n                });\r\n            }\r\n            return conflicts;\r\n        }\r\n    };\r\n\r\n    return replicationHandler;\r\n}\r\n\r\n\r\nexport async function cancelRxStorageReplication(\r\n    replicationState: RxStorageInstanceReplicationState<any>\r\n) {\r\n    replicationState.events.canceled.next(true);\r\n    replicationState.events.active.up.complete();\r\n    replicationState.events.active.down.complete();\r\n    replicationState.events.processed.up.complete();\r\n    replicationState.events.processed.down.complete();\r\n    replicationState.events.resolvedConflicts.complete();\r\n    replicationState.events.canceled.complete();\r\n    await replicationState.checkpointQueue;\r\n}\r\n"],"mappings":"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","ignoreList":[]}