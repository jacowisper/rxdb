{"version":3,"file":"checkpoint.js","names":["getComposedPrimaryKeyOfDocumentData","getWrittenDocumentsFromBulkWriteResponse","stackCheckpoints","createRevision","ensureNotFalsy","getDefaultRevision","getDefaultRxDocumentMeta","now","getLastCheckpointDoc","state","direction","checkpointDocId","input","metaInstance","schema","isCheckpoint","itemId","checkpointResult","findDocumentsById","checkpointDoc","lastCheckpointDoc","checkpointData","undefined","setCheckpoint","checkpoint","checkpointQueue","then","previousCheckpointDoc","events","canceled","getValue","JSON","stringify","newDoc","id","_deleted","_attachments","_meta","_rev","lwt","checkpointKey","writeRows","previous","document","result","bulkWrite","successDoc","primaryPath","error","status","documentInDb","getCheckpointKey","hash","hashFunction","identifier","forkInstance","databaseName","collectionName","join"],"sources":["../../../src/replication-protocol/checkpoint.ts"],"sourcesContent":["import { getComposedPrimaryKeyOfDocumentData } from '../rx-schema-helper.ts';\r\nimport { getWrittenDocumentsFromBulkWriteResponse, stackCheckpoints } from '../rx-storage-helper.ts';\r\nimport type {\r\n    RxDocumentData,\r\n    RxStorageInstanceReplicationInput,\r\n    RxStorageInstanceReplicationState,\r\n    RxStorageReplicationDirection,\r\n    RxStorageReplicationMeta\r\n} from '../types/index.d.ts';\r\nimport {\r\n    createRevision,\r\n    ensureNotFalsy,\r\n    getDefaultRevision,\r\n    getDefaultRxDocumentMeta,\r\n    now\r\n} from '../plugins/utils/index.ts';\r\n\r\nexport async function getLastCheckpointDoc<RxDocType, CheckpointType>(\r\n    state: RxStorageInstanceReplicationState<RxDocType>,\r\n    direction: RxStorageReplicationDirection\r\n): Promise<undefined | CheckpointType> {\r\n    const checkpointDocId = getComposedPrimaryKeyOfDocumentData(\r\n        state.input.metaInstance.schema,\r\n        {\r\n            isCheckpoint: '1',\r\n            itemId: direction\r\n        }\r\n    );\r\n    const checkpointResult = await state.input.metaInstance.findDocumentsById(\r\n        [\r\n            checkpointDocId\r\n        ],\r\n        false\r\n    );\r\n\r\n    const checkpointDoc = checkpointResult[0];\r\n    state.lastCheckpointDoc[direction] = checkpointDoc;\r\n    if (checkpointDoc) {\r\n        return checkpointDoc.checkpointData;\r\n    } else {\r\n        return undefined;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Sets the checkpoint,\r\n * automatically resolves conflicts that appear.\r\n */\r\nexport async function setCheckpoint<RxDocType, CheckpointType>(\r\n    state: RxStorageInstanceReplicationState<RxDocType>,\r\n    direction: RxStorageReplicationDirection,\r\n    checkpoint: CheckpointType\r\n) {\r\n    state.checkpointQueue = state.checkpointQueue.then(async () => {\r\n        let previousCheckpointDoc = state.lastCheckpointDoc[direction];\r\n        if (\r\n            checkpoint &&\r\n            /**\r\n             * If the replication is already canceled,\r\n             * we do not write a checkpoint\r\n             * because that could mean we write a checkpoint\r\n             * for data that has been fetched from the master\r\n             * but not been written to the child.\r\n             */\r\n            !state.events.canceled.getValue() &&\r\n            /**\r\n             * Only write checkpoint if it is different from before\r\n             * to have less writes to the storage.\r\n             */\r\n            (\r\n                !previousCheckpointDoc ||\r\n                JSON.stringify(previousCheckpointDoc.checkpointData) !== JSON.stringify(checkpoint)\r\n            )\r\n        ) {\r\n            const newDoc: RxDocumentData<RxStorageReplicationMeta<RxDocType, CheckpointType>> = {\r\n                id: '',\r\n                isCheckpoint: '1',\r\n                itemId: direction,\r\n                _deleted: false,\r\n                _attachments: {},\r\n                checkpointData: checkpoint,\r\n                _meta: getDefaultRxDocumentMeta(),\r\n                _rev: getDefaultRevision()\r\n            };\r\n            newDoc.id = getComposedPrimaryKeyOfDocumentData(\r\n                state.input.metaInstance.schema,\r\n                newDoc\r\n            );\r\n            while (!state.events.canceled.getValue()) {\r\n                /**\r\n                 * Instead of just storing the new checkpoint,\r\n                 * we have to stack up the checkpoint with the previous one.\r\n                 * This is required for plugins like the sharding RxStorage\r\n                 * where the changeStream events only contain a Partial of the\r\n                 * checkpoint.\r\n                 */\r\n                if (previousCheckpointDoc) {\r\n                    newDoc.checkpointData = stackCheckpoints([\r\n                        previousCheckpointDoc.checkpointData,\r\n                        newDoc.checkpointData\r\n                    ]);\r\n                }\r\n                newDoc._meta.lwt = now();\r\n                newDoc._rev = createRevision(\r\n                    await state.checkpointKey,\r\n                    previousCheckpointDoc\r\n                );\r\n\r\n                if (state.events.canceled.getValue()) {\r\n                    return;\r\n                }\r\n\r\n                const writeRows = [{\r\n                    previous: previousCheckpointDoc,\r\n                    document: newDoc\r\n                }];\r\n                const result = await state.input.metaInstance.bulkWrite(writeRows, 'replication-set-checkpoint');\r\n                const successDoc = getWrittenDocumentsFromBulkWriteResponse(\r\n                    state.primaryPath,\r\n                    writeRows,\r\n                    result\r\n                )[0];\r\n                if (successDoc) {\r\n                    state.lastCheckpointDoc[direction] = successDoc;\r\n                    return;\r\n                } else {\r\n                    const error = result.error[0];\r\n                    if (error.status !== 409) {\r\n                        throw error;\r\n                    } else {\r\n                        previousCheckpointDoc = ensureNotFalsy(error.documentInDb);\r\n                        newDoc._rev = createRevision(\r\n                            await state.checkpointKey,\r\n                            previousCheckpointDoc\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    });\r\n    await state.checkpointQueue;\r\n}\r\n\r\nexport async function getCheckpointKey<RxDocType>(\r\n    input: RxStorageInstanceReplicationInput<RxDocType>\r\n): Promise<string> {\r\n    const hash = await input.hashFunction([\r\n        input.identifier,\r\n        input.forkInstance.databaseName,\r\n        input.forkInstance.collectionName\r\n    ].join('||'));\r\n    return 'rx_storage_replication_' + hash;\r\n}\r\n"],"mappings":"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","ignoreList":[]}