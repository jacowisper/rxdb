{"version":3,"file":"rx-query-helper.js","names":["LOGICAL_OPERATORS","getQueryPlan","getPrimaryFieldOfPrimaryKey","clone","firstPropertyNameOfObject","toArray","isMaybeReadonlyArray","flatClone","objectPathMonad","compare","mingoSortComparator","newRxError","getMingoQuery","normalizeMangoQuery","schema","mangoQuery","primaryKey","normalizedMangoQuery","skip","selector","Object","entries","forEach","field","matcher","$eq","index","indexAr","includes","push","sort","map","indexes","fieldsWithLogicalOperator","Set","hasLogical","keys","find","operator","has","add","currentFieldsAmount","currentBestIndexForSort","useIndex","firstWrongIndex","findIndex","indexField","isPrimaryInSort","p","slice","getSortComparator","query","sortParts","sortBlock","key","direction","values","getValueFn","fun","a","b","i","length","sortPart","valueA","valueB","ret","getQueryMatcher","_schema","mingoQuery","doc","test","runQueryUpdateFunction","rxQuery","fn","docs","exec","Array","isArray","Promise","all","Map","result","prepareQuery","mutateableQuery","queryPlan"],"sources":["../../src/rx-query-helper.ts"],"sourcesContent":["import { LOGICAL_OPERATORS, getQueryPlan } from './query-planner.ts';\r\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper.ts';\r\nimport type {\r\n    DeepReadonly,\r\n    DeterministicSortComparator,\r\n    FilledMangoQuery,\r\n    MangoQuery,\r\n    MangoQuerySortDirection,\r\n    PreparedQuery,\r\n    QueryMatcher,\r\n    RxDocument,\r\n    RxDocumentData,\r\n    RxJsonSchema,\r\n    RxQuery\r\n} from './types/index.d.ts';\r\nimport {\r\n    clone,\r\n    firstPropertyNameOfObject,\r\n    toArray,\r\n    isMaybeReadonlyArray,\r\n    flatClone,\r\n    objectPathMonad,\r\n    ObjectPathMonadFunction\r\n} from './plugins/utils/index.ts';\r\nimport {\r\n    compare as mingoSortComparator\r\n} from 'mingo/util';\r\nimport { newRxError } from './rx-error.ts';\r\nimport { getMingoQuery } from './rx-query-mingo.ts';\r\n\r\n/**\r\n * Normalize the query to ensure we have all fields set\r\n * and queries that represent the same query logic are detected as equal by the caching.\r\n */\r\nexport function normalizeMangoQuery<RxDocType>(\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    mangoQuery: MangoQuery<RxDocType>\r\n): FilledMangoQuery<RxDocType> {\r\n    const primaryKey: string = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\r\n    mangoQuery = flatClone(mangoQuery);\r\n\r\n    const normalizedMangoQuery: FilledMangoQuery<RxDocType> = clone(mangoQuery) as any;\r\n    if (typeof normalizedMangoQuery.skip !== 'number') {\r\n        normalizedMangoQuery.skip = 0;\r\n    }\r\n\r\n    if (!normalizedMangoQuery.selector) {\r\n        normalizedMangoQuery.selector = {};\r\n    } else {\r\n        normalizedMangoQuery.selector = normalizedMangoQuery.selector;\r\n        /**\r\n         * In mango query, it is possible to have an\r\n         * equals comparison by directly assigning a value\r\n         * to a property, without the '$eq' operator.\r\n         * Like:\r\n         * selector: {\r\n         *   foo: 'bar'\r\n         * }\r\n         * For normalization, we have to normalize this\r\n         * so our checks can perform properly.\r\n         *\r\n         *\r\n         * TODO this must work recursive with nested queries that\r\n         * contain multiple selectors via $and or $or etc.\r\n         */\r\n        Object\r\n            .entries(normalizedMangoQuery.selector)\r\n            .forEach(([field, matcher]) => {\r\n                if (typeof matcher !== 'object' || matcher === null) {\r\n                    (normalizedMangoQuery as any).selector[field] = {\r\n                        $eq: matcher\r\n                    };\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Ensure that if an index is specified,\r\n     * the primaryKey is inside of it.\r\n     */\r\n    if (normalizedMangoQuery.index) {\r\n        const indexAr = toArray(normalizedMangoQuery.index);\r\n        if (!indexAr.includes(primaryKey)) {\r\n            indexAr.push(primaryKey);\r\n        }\r\n        normalizedMangoQuery.index = indexAr;\r\n    }\r\n\r\n    /**\r\n     * To ensure a deterministic sorting,\r\n     * we have to ensure the primary key is always part\r\n     * of the sort query.\r\n     * Primary sorting is added as last sort parameter,\r\n     * similar to how we add the primary key to indexes that do not have it.\r\n     *\r\n     */\r\n    if (!normalizedMangoQuery.sort) {\r\n        /**\r\n         * If no sort is given at all,\r\n         * we can assume that the user does not care about sort order at al.\r\n         *\r\n         * we cannot just use the primary key as sort parameter\r\n         * because it would likely cause the query to run over the primary key index\r\n         * which has a bad performance in most cases.\r\n         */\r\n        if (normalizedMangoQuery.index) {\r\n            normalizedMangoQuery.sort = normalizedMangoQuery.index.map((field: string) => {\r\n                return { [field as any]: 'asc' } as any;\r\n            });\r\n        } else {\r\n            /**\r\n             * Find the index that best matches the fields with the logical operators\r\n             */\r\n            if (schema.indexes) {\r\n                const fieldsWithLogicalOperator: Set<string> = new Set();\r\n                Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {\r\n                    let hasLogical = false;\r\n                    if (typeof matcher === 'object' && matcher !== null) {\r\n                        hasLogical = !!Object.keys(matcher).find(operator => LOGICAL_OPERATORS.has(operator));\r\n                    } else {\r\n                        hasLogical = true;\r\n                    }\r\n                    if (hasLogical) {\r\n                        fieldsWithLogicalOperator.add(field);\r\n                    }\r\n                });\r\n\r\n\r\n                let currentFieldsAmount = -1;\r\n                let currentBestIndexForSort: string[] | readonly string[] | undefined;\r\n                schema.indexes.forEach(index => {\r\n                    const useIndex = isMaybeReadonlyArray(index) ? index : [index];\r\n                    const firstWrongIndex = useIndex.findIndex(indexField => !fieldsWithLogicalOperator.has(indexField));\r\n                    if (\r\n                        firstWrongIndex > 0 &&\r\n                        firstWrongIndex > currentFieldsAmount\r\n                    ) {\r\n                        currentFieldsAmount = firstWrongIndex;\r\n                        currentBestIndexForSort = useIndex;\r\n                    }\r\n                });\r\n                if (currentBestIndexForSort) {\r\n                    normalizedMangoQuery.sort = currentBestIndexForSort.map((field: string) => {\r\n                        return { [field as any]: 'asc' } as any;\r\n                    });\r\n                }\r\n\r\n            }\r\n\r\n            /**\r\n             * Fall back to the primary key as sort order\r\n             * if no better one has been found\r\n             */\r\n            if (!normalizedMangoQuery.sort) {\r\n                normalizedMangoQuery.sort = [{ [primaryKey]: 'asc' }] as any;\r\n            }\r\n        }\r\n    } else {\r\n        const isPrimaryInSort = normalizedMangoQuery.sort\r\n            .find(p => firstPropertyNameOfObject(p) === primaryKey);\r\n        if (!isPrimaryInSort) {\r\n            normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);\r\n            normalizedMangoQuery.sort.push({ [primaryKey]: 'asc' } as any);\r\n        }\r\n    }\r\n\r\n    return normalizedMangoQuery;\r\n}\r\n\r\n/**\r\n * Returns the sort-comparator,\r\n * which is able to sort documents in the same way\r\n * a query over the db would do.\r\n */\r\nexport function getSortComparator<RxDocType>(\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    query: FilledMangoQuery<RxDocType>\r\n): DeterministicSortComparator<RxDocType> {\r\n    if (!query.sort) {\r\n        throw newRxError('SNH', { query });\r\n    }\r\n    const sortParts: {\r\n        key: string;\r\n        direction: MangoQuerySortDirection;\r\n        getValueFn: ObjectPathMonadFunction<RxDocType>;\r\n    }[] = [];\r\n    query.sort.forEach(sortBlock => {\r\n        const key = Object.keys(sortBlock)[0];\r\n        const direction = Object.values(sortBlock)[0];\r\n        sortParts.push({\r\n            key,\r\n            direction,\r\n            getValueFn: objectPathMonad(key)\r\n        });\r\n    });\r\n    const fun: DeterministicSortComparator<RxDocType> = (a: RxDocType, b: RxDocType) => {\r\n        for (let i = 0; i < sortParts.length; ++i) {\r\n            const sortPart = sortParts[i];\r\n            const valueA = sortPart.getValueFn(a);\r\n            const valueB = sortPart.getValueFn(b);\r\n            if (valueA !== valueB) {\r\n                const ret = sortPart.direction === 'asc' ? mingoSortComparator(valueA, valueB) : mingoSortComparator(valueB, valueA);\r\n                return ret as any;\r\n            }\r\n        }\r\n    };\r\n\r\n    return fun;\r\n}\r\n\r\n\r\n/**\r\n * Returns a function\r\n * that can be used to check if a document\r\n * matches the query.\r\n */\r\nexport function getQueryMatcher<RxDocType>(\r\n    _schema: RxJsonSchema<RxDocType> | RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    query: FilledMangoQuery<RxDocType>\r\n): QueryMatcher<RxDocumentData<RxDocType>> {\r\n    if (!query.sort) {\r\n        throw newRxError('SNH', { query });\r\n    }\r\n\r\n    const mingoQuery = getMingoQuery(query.selector as any);\r\n    const fun: QueryMatcher<RxDocumentData<RxDocType>> = (doc: RxDocumentData<RxDocType> | DeepReadonly<RxDocumentData<RxDocType>>) => {\r\n        return mingoQuery.test(doc);\r\n    };\r\n    return fun;\r\n}\r\n\r\n\r\nexport async function runQueryUpdateFunction<RxDocType, RxQueryResult>(\r\n    rxQuery: RxQuery<RxDocType, RxQueryResult>,\r\n    fn: (doc: RxDocument<RxDocType>) => Promise<RxDocument<RxDocType>>\r\n): Promise<RxQueryResult> {\r\n    const docs = await rxQuery.exec();\r\n    if (!docs) {\r\n        // only findOne() queries can return null\r\n        return null as any;\r\n    }\r\n    if (Array.isArray(docs)) {\r\n        return Promise.all(\r\n            docs.map(doc => fn(doc))\r\n        ) as any;\r\n    } else if (docs instanceof Map) {\r\n        return Promise.all(\r\n            [...docs.values()].map((doc) => fn(doc))\r\n        ) as any;\r\n    } else {\r\n        // via findOne()\r\n        const result = await fn(docs as any);\r\n        return result as any;\r\n    }\r\n}\r\n\r\n/**\r\n * @returns a format of the query that can be used with the storage\r\n * when calling RxStorageInstance().query()\r\n */\r\nexport function prepareQuery<RxDocType>(\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    mutateableQuery: FilledMangoQuery<RxDocType>\r\n): PreparedQuery<RxDocType> {\r\n    if (!mutateableQuery.sort) {\r\n        throw newRxError('SNH', {\r\n            query: mutateableQuery\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Store the query plan together with the\r\n     * prepared query to save performance.\r\n     */\r\n    const queryPlan = getQueryPlan(\r\n        schema,\r\n        mutateableQuery\r\n    );\r\n\r\n    return {\r\n        query: mutateableQuery,\r\n        queryPlan\r\n    };\r\n}\r\n"],"mappings":"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","ignoreList":[]}