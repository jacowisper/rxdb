{"version":3,"file":"replication.d.js","names":[],"sources":["../../../../src/types/plugins/replication.d.ts"],"sourcesContent":["import { Observable } from 'rxjs';\r\nimport type {\r\n    InternalStoreDocType,\r\n    MaybePromise,\r\n    RxCollection,\r\n    RxDocumentData,\r\n    RxReplicationPullStreamItem,\r\n    RxReplicationWriteToMasterRow,\r\n    WithDeleted\r\n} from '../../types/index.d.ts';\r\n\r\n\r\nexport type InternalStoreReplicationPushDocType = InternalStoreDocType<{\r\n    checkpoint: any;\r\n}>;\r\nexport type InternalStoreReplicationPullDocType<RxDocType> = InternalStoreDocType<{\r\n    lastPulledDoc: RxDocumentData<RxDocType>;\r\n}>;\r\n\r\nexport type ReplicationPullHandlerResult<RxDocType, CheckpointType> = {\r\n    checkpoint: CheckpointType | null;\r\n    documents: WithDeleted<RxDocType>[];\r\n};\r\n\r\nexport type ReplicationPushHandlerResult<RxDocType> = RxDocType[];\r\n\r\nexport type ReplicationPullHandler<RxDocType, CheckpointType> = (\r\n    lastPulledCheckpoint: CheckpointType | undefined,\r\n    batchSize: number\r\n) => Promise<ReplicationPullHandlerResult<RxDocType, CheckpointType>>;\r\nexport type ReplicationPullOptions<RxDocType, CheckpointType> = {\r\n    /**\r\n     * A handler that pulls the new remote changes\r\n     * from the remote actor.\r\n     */\r\n    handler: ReplicationPullHandler<RxDocType, CheckpointType>;\r\n\r\n\r\n    /**\r\n     * An observable that streams all document changes\r\n     * that are happening on the backend.\r\n     * Emits an document bulk together with the latest checkpoint of these documents.\r\n     * Also can emit a 'RESYNC' event when the client was offline and is online again.\r\n     *\r\n     * Not required for non-live replication.\r\n     */\r\n    stream$?: Observable<RxReplicationPullStreamItem<RxDocType, CheckpointType>>;\r\n\r\n    /**\r\n     * Amount of documents that the remote will send in one request.\r\n     * If the response contains less then [batchSize] documents,\r\n     * RxDB will assume there are no more changes on the backend\r\n     * that are not replicated.\r\n     * [default=100]\r\n     */\r\n    batchSize?: number;\r\n\r\n    /**\r\n     * A modifier that runs on all documents that are pulled,\r\n     * before they are used by RxDB.\r\n     * - the ones from the pull handler\r\n     * - the ones from the pull stream\r\n     */\r\n    modifier?: (docData: any) => MaybePromise<WithDeleted<RxDocType>>;\r\n\r\n    /**\r\n     * If set, the push replication\r\n     * will start from the given checkpoint.\r\n     */\r\n    initialCheckpoint?: any;\r\n};\r\n\r\n/**\r\n * Gets the new write rows.\r\n * Returns the current master state of all conflicting writes,\r\n * so that they can be resolved on the client.\r\n */\r\nexport type ReplicationPushHandler<RxDocType> = (\r\n    docs: RxReplicationWriteToMasterRow<RxDocType>[]\r\n) => Promise<WithDeleted<RxDocType>[]>;\r\nexport type ReplicationPushOptions<RxDocType> = {\r\n    /**\r\n     * A handler that sends the new local changes\r\n     * to the remote actor.\r\n     * On error, all documents are send again at later time.\r\n     */\r\n    handler: ReplicationPushHandler<RxDocType>;\r\n\r\n\r\n    /**\r\n     * A modifier that runs on all pushed documents before\r\n     * they are send into the push handler.\r\n     */\r\n    modifier?: (docData: WithDeleted<RxDocType>) => MaybePromise<any | null>;\r\n\r\n    /**\r\n     * How many local changes to process at once.\r\n     */\r\n    batchSize?: number;\r\n\r\n    /**\r\n     * If set, the push replication\r\n     * will start from the given checkpoint.\r\n     */\r\n    initialCheckpoint?: any;\r\n};\r\n\r\n\r\nexport type ReplicationOptions<RxDocType, CheckpointType> = {\r\n    /**\r\n     * An id for the replication to identify it\r\n     * and so that RxDB is able to resume the replication on app reload.\r\n     * If you replicate with a remote server, it is recommended to put the\r\n     * server url into the replicationIdentifier.\r\n     * Like 'my-rest-replication-to-https://example.com/api/sync'\r\n     */\r\n    replicationIdentifier: string;\r\n    collection: RxCollection<RxDocType, any, any, any>;\r\n    /**\r\n     * Define a custom property that is used\r\n     * to flag a document as being deleted.\r\n     * @default '_deleted'\r\n     */\r\n    deletedField?: '_deleted' | string;\r\n    pull?: ReplicationPullOptions<RxDocType, CheckpointType>;\r\n    push?: ReplicationPushOptions<RxDocType>;\r\n    /**\r\n     * By default it will do an ongoing realtime replication.\r\n     * By settings live: false the replication will run once until the local state\r\n     * is in sync with the remote state, then it will cancel itself.\r\n     * @default true\r\n     */\r\n    live?: boolean;\r\n    /**\r\n     * Time in milliseconds after when a failed backend request\r\n     * has to be retried.\r\n     * This time will be skipped if a offline->online switch is detected\r\n     * via `navigator.onLine`\r\n     * @default 5000\r\n     */\r\n    retryTime?: number;\r\n    /**\r\n     * When multiInstance is `true`, like when you use RxDB in multiple browser tabs,\r\n     * the replication should always run in only one of the open browser tabs.\r\n     * If waitForLeadership is `true`, it will wait until the current instance is leader.\r\n     * If waitForLeadership is `false`, it will start replicating, even if it is not leader.\r\n     * @default true\r\n     */\r\n    waitForLeadership?: boolean;\r\n\r\n    toggleOnDocumentVisible?: boolean;\r\n\r\n    /**\r\n     * If this is set to `false`,\r\n     * the replication will not start automatically\r\n     * but will wait for `replicationState.start()` being called.\r\n     * @default true\r\n     */\r\n    autoStart?: boolean;\r\n};\r\n"],"mappings":"","ignoreList":[]}