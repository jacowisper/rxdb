{"version":3,"file":"plugin-helpers.js","names":["filter","mergeMap","tap","getPrimaryFieldOfPrimaryKey","flatClone","getFromMapOrCreate","requestIdleCallbackIfAvailable","BehaviorSubject","firstValueFrom","VALIDATOR_CACHE_BY_VALIDATOR_KEY","Map","wrappedValidateStorageFactory","getValidator","validatorKey","VALIDATOR_CACHE","initValidator","schema","JSON","stringify","args","Object","assign","storage","name","createStorageInstance","params","instance","primaryPath","primaryKey","validatorCached","oldBulkWrite","bulkWrite","bind","documentWrites","context","errors","continueWrites","forEach","row","documentId","document","validationErrors","length","push","status","isError","writeRow","writePromise","Promise","resolve","error","success","then","writeResult","validationError","wrapRxStorageInstance","originalSchema","modifyToStorage","modifyFromStorage","modifyAttachmentFromStorage","v","toStorage","docData","fromStorage","errorFromStorage","ret","documentInDb","previous","processingChangesCount$","wrappedInstance","databaseName","internals","cleanup","options","close","collectionName","count","remove","originalStorageInstance","useRows","all","map","undefined","promises","err","pipe","query","preparedQuery","queryResult","documents","doc","getAttachmentData","attachmentId","digest","data","findDocumentsById","ids","deleted","findResult","getChangedDocumentsSince","limit","checkpoint","result","d","changeStream","next","getValue","eventBulk","useEvents","events","event","documentData","previousDocumentData","ev","operation","isLocal","id"],"sources":["../../src/plugin-helpers.ts"],"sourcesContent":["import { filter, mergeMap, tap } from 'rxjs/operators';\r\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper.ts';\r\nimport { WrappedRxStorageInstance } from './rx-storage-helper.ts';\r\nimport type {\r\n    BulkWriteRow,\r\n    EventBulk,\r\n    RxChangeEvent,\r\n    RxDocumentData,\r\n    RxDocumentWriteData,\r\n    RxJsonSchema,\r\n    RxStorage,\r\n    RxStorageWriteError,\r\n    RxStorageBulkWriteResponse,\r\n    RxStorageChangeEvent,\r\n    RxStorageInstance,\r\n    RxStorageInstanceCreationParams,\r\n    RxValidationError,\r\n    RxStorageWriteErrorConflict,\r\n    MaybePromise\r\n} from './types/index.d.ts';\r\nimport {\r\n    flatClone,\r\n    getFromMapOrCreate,\r\n    requestIdleCallbackIfAvailable\r\n} from './plugins/utils/index.ts';\r\nimport { BehaviorSubject, firstValueFrom } from 'rxjs';\r\n\r\n\r\ntype WrappedStorageFunction = <Internals, InstanceCreationOptions>(\r\n    args: {\r\n        storage: RxStorage<Internals, InstanceCreationOptions>;\r\n    }\r\n) => RxStorage<Internals, InstanceCreationOptions>;\r\n\r\n/**\r\n * Returns the validation errors.\r\n * If document is fully valid, returns an empty array.\r\n */\r\ntype ValidatorFunction = (docData: RxDocumentData<any>) => RxValidationError[];\r\n\r\n/**\r\n * cache the validators by the schema string\r\n * so we can reuse them when multiple collections have the same schema\r\n *\r\n * Notice: to make it easier and not dependent on a hash function,\r\n * we use the plain json string.\r\n */\r\nconst VALIDATOR_CACHE_BY_VALIDATOR_KEY: Map<string, Map<string, ValidatorFunction>> = new Map();\r\n\r\n/**\r\n * This factory is used in the validation plugins\r\n * so that we can reuse the basic storage wrapping code.\r\n */\r\nexport function wrappedValidateStorageFactory(\r\n    /**\r\n     * Returns a method that can be used to validate\r\n     * documents and throws when the document is not valid.\r\n     */\r\n    getValidator: (schema: RxJsonSchema<any>) => ValidatorFunction,\r\n    /**\r\n     * A string to identify the validation library.\r\n     */\r\n    validatorKey: string\r\n): WrappedStorageFunction {\r\n    const VALIDATOR_CACHE = getFromMapOrCreate(\r\n        VALIDATOR_CACHE_BY_VALIDATOR_KEY,\r\n        validatorKey,\r\n        () => new Map()\r\n    );\r\n\r\n    function initValidator(\r\n        schema: RxJsonSchema<any>\r\n    ): ValidatorFunction {\r\n        return getFromMapOrCreate(\r\n            VALIDATOR_CACHE,\r\n            JSON.stringify(schema),\r\n            () => getValidator(schema)\r\n        );\r\n    }\r\n\r\n    return (args) => {\r\n        return Object.assign(\r\n            {},\r\n            args.storage,\r\n            {\r\n                name: 'validate-' + validatorKey + '-' + args.storage.name,\r\n                async createStorageInstance<RxDocType>(\r\n                    params: RxStorageInstanceCreationParams<RxDocType, any>\r\n                ) {\r\n                    const instance = await args.storage.createStorageInstance(params);\r\n                    const primaryPath = getPrimaryFieldOfPrimaryKey(params.schema.primaryKey);\r\n\r\n                    /**\r\n                     * Lazy initialize the validator\r\n                     * to save initial page load performance.\r\n                     * Some libraries take really long to initialize the validator\r\n                     * from the schema.\r\n                     */\r\n                    let validatorCached: ValidatorFunction;\r\n                    requestIdleCallbackIfAvailable(() => validatorCached = initValidator(params.schema));\r\n\r\n                    const oldBulkWrite = instance.bulkWrite.bind(instance);\r\n                    instance.bulkWrite = (\r\n                        documentWrites: BulkWriteRow<RxDocType>[],\r\n                        context: string\r\n                    ) => {\r\n                        if (!validatorCached) {\r\n                            validatorCached = initValidator(params.schema);\r\n                        }\r\n                        const errors: RxStorageWriteError<RxDocType>[] = [];\r\n                        const continueWrites: typeof documentWrites = [];\r\n                        documentWrites.forEach(row => {\r\n                            const documentId: string = row.document[primaryPath] as any;\r\n                            const validationErrors = validatorCached(row.document);\r\n                            if (validationErrors.length > 0) {\r\n                                errors.push({\r\n                                    status: 422,\r\n                                    isError: true,\r\n                                    documentId,\r\n                                    writeRow: row,\r\n                                    validationErrors,\r\n                                    schema: instance.schema\r\n                                });\r\n                            } else {\r\n                                continueWrites.push(row);\r\n                            }\r\n                        });\r\n                        const writePromise: Promise<RxStorageBulkWriteResponse<RxDocType>> = continueWrites.length > 0 ?\r\n                            oldBulkWrite(continueWrites, context) :\r\n                            Promise.resolve({ error: [], success: [] });\r\n                        return writePromise.then(writeResult => {\r\n                            errors.forEach(validationError => {\r\n                                writeResult.error.push(validationError);\r\n                            });\r\n                            return writeResult;\r\n                        });\r\n                    };\r\n\r\n                    return instance;\r\n                }\r\n            }\r\n        );\r\n    };\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * Used in plugins to easily modify all in- and outgoing\r\n * data of that storage instance.\r\n */\r\nexport function wrapRxStorageInstance<RxDocType>(\r\n    originalSchema: RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    instance: RxStorageInstance<RxDocType, any, any>,\r\n    modifyToStorage: (docData: RxDocumentWriteData<RxDocType>) => MaybePromise<RxDocumentData<any>>,\r\n    modifyFromStorage: (docData: RxDocumentData<any>) => MaybePromise<RxDocumentData<RxDocType>>,\r\n    modifyAttachmentFromStorage: (attachmentData: string) => MaybePromise<string> = (v) => v\r\n): WrappedRxStorageInstance<RxDocType, any, any> {\r\n    async function toStorage(docData: RxDocumentWriteData<RxDocType>): Promise<RxDocumentData<any>> {\r\n        if (!docData) {\r\n            return docData;\r\n        }\r\n        return await modifyToStorage(docData);\r\n    }\r\n    async function fromStorage(docData: RxDocumentData<any> | null): Promise<RxDocumentData<RxDocType>> {\r\n        if (!docData) {\r\n            return docData;\r\n        }\r\n        return await modifyFromStorage(docData);\r\n    }\r\n    async function errorFromStorage(\r\n        error: RxStorageWriteError<any>\r\n    ): Promise<RxStorageWriteError<RxDocType>> {\r\n        const ret = flatClone(error);\r\n        ret.writeRow = flatClone(ret.writeRow);\r\n        if ((ret as RxStorageWriteErrorConflict<any>).documentInDb) {\r\n            (ret as RxStorageWriteErrorConflict<any>).documentInDb = await fromStorage((ret as RxStorageWriteErrorConflict<any>).documentInDb);\r\n        }\r\n        if (ret.writeRow.previous) {\r\n            ret.writeRow.previous = await fromStorage(ret.writeRow.previous);\r\n        }\r\n        ret.writeRow.document = await fromStorage(ret.writeRow.document);\r\n        return ret;\r\n    }\r\n\r\n\r\n    const processingChangesCount$ = new BehaviorSubject(0);\r\n\r\n    const wrappedInstance: WrappedRxStorageInstance<RxDocType, any, any> = {\r\n        databaseName: instance.databaseName,\r\n        internals: instance.internals,\r\n        cleanup: instance.cleanup.bind(instance),\r\n        options: instance.options,\r\n        close: instance.close.bind(instance),\r\n        schema: originalSchema,\r\n        collectionName: instance.collectionName,\r\n        count: instance.count.bind(instance),\r\n        remove: instance.remove.bind(instance),\r\n        originalStorageInstance: instance,\r\n        bulkWrite: async (\r\n            documentWrites: BulkWriteRow<RxDocType>[],\r\n            context: string\r\n        ) => {\r\n            const useRows: BulkWriteRow<any>[] = [];\r\n            await Promise.all(\r\n                documentWrites.map(async (row) => {\r\n                    const [previous, document] = await Promise.all([\r\n                        row.previous ? toStorage(row.previous) : undefined,\r\n                        toStorage(row.document)\r\n                    ]);\r\n                    useRows.push({ previous, document });\r\n                })\r\n            );\r\n\r\n            const writeResult = await instance.bulkWrite(useRows, context);\r\n            const ret: RxStorageBulkWriteResponse<RxDocType> = {\r\n                error: []\r\n            };\r\n            const promises: Promise<any>[] = [];\r\n            writeResult.error.forEach(error => {\r\n                promises.push(\r\n                    errorFromStorage(error).then(err => ret.error.push(err))\r\n                );\r\n            });\r\n            await Promise.all(promises);\r\n\r\n            /**\r\n             * By definition, all change events must be emitted\r\n             * BEFORE the write call resolves.\r\n             * To ensure that even when the modifiers are async,\r\n             * we wait here until the processing queue is empty.\r\n             */\r\n            await firstValueFrom(\r\n                processingChangesCount$.pipe(\r\n                    filter(v => v === 0)\r\n                )\r\n            );\r\n            return ret;\r\n        },\r\n        query: (preparedQuery) => {\r\n            return instance.query(preparedQuery)\r\n                .then(queryResult => {\r\n                    return Promise.all(queryResult.documents.map(doc => fromStorage(doc)));\r\n                })\r\n                .then(documents => ({ documents: documents as any }));\r\n        },\r\n        getAttachmentData: async (\r\n            documentId: string,\r\n            attachmentId: string,\r\n            digest: string\r\n        ) => {\r\n            let data = await instance.getAttachmentData(documentId, attachmentId, digest);\r\n            data = await modifyAttachmentFromStorage(data);\r\n            return data;\r\n        },\r\n        findDocumentsById: (ids, deleted) => {\r\n            return instance.findDocumentsById(ids, deleted)\r\n                .then(async (findResult) => {\r\n                    const ret: RxDocumentData<RxDocType>[] = [];\r\n                    await Promise.all(\r\n                        findResult\r\n                            .map(async (doc) => {\r\n                                ret.push(await fromStorage(doc));\r\n                            })\r\n                    );\r\n                    return ret;\r\n                });\r\n        },\r\n        getChangedDocumentsSince: !instance.getChangedDocumentsSince ? undefined : (limit, checkpoint) => {\r\n            return ((instance as any).getChangedDocumentsSince)(limit, checkpoint)\r\n                .then(async (result: any) => {\r\n                    return {\r\n                        checkpoint: result.checkpoint,\r\n                        documents: await Promise.all(\r\n                            result.documents.map((d: any) => fromStorage(d))\r\n                        )\r\n                    };\r\n                });\r\n        },\r\n        changeStream: () => {\r\n            return instance.changeStream().pipe(\r\n                tap(() => processingChangesCount$.next(processingChangesCount$.getValue() + 1)),\r\n                mergeMap(async (eventBulk) => {\r\n                    const useEvents = await Promise.all(\r\n                        eventBulk.events.map(async (event) => {\r\n                            const [\r\n                                documentData,\r\n                                previousDocumentData\r\n                            ] = await Promise.all([\r\n                                fromStorage(event.documentData),\r\n                                fromStorage(event.previousDocumentData)\r\n                            ]);\r\n                            const ev: RxChangeEvent<RxDocType> = {\r\n                                operation: event.operation,\r\n                                documentId: event.documentId,\r\n                                documentData: documentData as any,\r\n                                previousDocumentData: previousDocumentData as any,\r\n                                isLocal: false\r\n                            };\r\n                            return ev;\r\n                        })\r\n                    );\r\n                    const ret: EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, any> = {\r\n                        id: eventBulk.id,\r\n                        events: useEvents,\r\n                        checkpoint: eventBulk.checkpoint,\r\n                        context: eventBulk.context\r\n                    };\r\n                    return ret;\r\n                }),\r\n                tap(() => processingChangesCount$.next(processingChangesCount$.getValue() - 1))\r\n            );\r\n        },\r\n    };\r\n\r\n    return wrappedInstance;\r\n}\r\n"],"mappings":"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","ignoreList":[]}