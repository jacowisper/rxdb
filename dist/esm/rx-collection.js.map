{"version":3,"file":"rx-collection.js","names":["filter","map","mergeMap","ucfirst","flatClone","promiseSeries","pluginMissing","ensureNotFalsy","getFromMapOrThrow","PROMISE_RESOLVE_FALSE","PROMISE_RESOLVE_VOID","NON_PREMIUM_COLLECTION_LIMIT","hasPremiumFlag","fillObjectDataBeforeInsert","createRxCollectionStorageInstance","removeCollectionStorages","ensureRxCollectionIsNotClosed","createRxQuery","_getDefaultQuery","newRxError","newRxTypeError","DocumentCache","mapDocumentsDataToCacheDocs","createQueryCache","defaultCacheReplacementPolicy","createChangeEventBuffer","runAsyncPluginHooks","runPluginHooks","createNewRxDocument","getRxDocumentConstructor","getWrappedStorageInstance","getWrittenDocumentsFromBulkWriteResponse","throwIfIsStorageWriteError","IncrementalWriteQueue","beforeDocumentUpdateWrite","overwritable","defaultConflictHandler","rxChangeEventBulkToRxChangeEvents","HOOKS_WHEN","HOOKS_KEYS","hooksApplied","OPEN_COLLECTIONS","Set","RxCollectionBase","database","name","schema","internalStorageInstance","instanceCreationOptions","migrationStrategies","methods","attachments","options","cacheReplacementPolicy","statics","conflictHandler","storageInstance","timeouts","incrementalWriteQueue","awaitBeforeReads","_incrementalUpsertQueues","Map","synced","hooks","_subs","_docCache","_queryCache","$","checkpoint$","_changeEventBuffer","eventBulks$","onClose","closed","onRemove","_applyHookFunctions","asRxCollection","pipe","changeEventBulk","collectionName","add","_proto","prototype","prepare","count","size","promiseWait","collection","args","existing","Array","from","values","c","db","jsonSchema","primaryPath","newData","oldData","result","_runHooks","checkpoint","documentConstructor","bulk","isLocal","events","docData","listenToRemoveSub","internalStore","changeStream","key","version","found","find","event","documentData","context","operation","subscribe","close","Promise","all","fn","push","databaseStorageToken","storageToken","subDocs","eventBulk","id","internal","databaseToken","token","$emit","cleanup","_minimumDeletedTime","migrationNeeded","getMigrationState","startMigration","batchSize","migratePromise","insert","json","writeResult","bulkInsert","isError","error","insertResult","success","insertIfNotExists","length","status","conflictDocData","documentInDb","docsData","ids","insertRows","hasHooks","useDocData","then","document","index","documents","results","bulkWrite","rxDocuments","ret","docsMap","forEach","row","doc","set","get","primary","bulkRemove","idsOrDocs","rxDocumentMap","findByIds","exec","d","rxDocument","data","toMutableJSON","removeDocs","writeDoc","_deleted","previous","deletedRxDocuments","successIds","getCachedRxDocument","bulkUpsert","insertData","useJsonByDocId","useJson","slice","err","documentId","writeData","docDataInDb","getCachedRxDocuments","newDoc","incrementalModify","upsert","bulkResult","incrementalUpsert","queue","_incrementalUpsertEnsureRxDocumentExists","wasInserted","inserted","_incrementalUpsertUpdate","queryObj","op","query","findOne","selector","limit","mangoQuery","$in","exportJSON","importJSON","_exportedJSON","insertCRDT","_updateObj","addPipeline","_options","addHook","when","fun","parallel","includes","boundFun","bind","runName","series","getHooks","instance","tasks","hook","_runHooksSync","time","res","timeout","setTimeout","delete","clearTimeout","requestIdlePromise","sub","unsubscribe","collections","remove","storage","multiInstance","password","hashFunction","_createClass","cE","colProto","Object","getPrototypeOf","fnName","_innerDoc","rxCollection","docDataFromCache","getLatestDocumentDataIfExists","resolve","createRxCollection","autoMigrate","localDocuments","storageInstanceCreationParams","databaseInstanceToken","databaseName","devMode","isDevMode","entries","funName","defineProperty","creator","catch","reject","isRxCollection","obj"],"sources":["../../src/rx-collection.ts"],"sourcesContent":["import {\r\n    filter,\r\n    map,\r\n    mergeMap\r\n} from 'rxjs';\r\n\r\nimport {\r\n    ucfirst,\r\n    flatClone,\r\n    promiseSeries,\r\n    pluginMissing,\r\n    ensureNotFalsy,\r\n    getFromMapOrThrow,\r\n    PROMISE_RESOLVE_FALSE,\r\n    PROMISE_RESOLVE_VOID,\r\n    NON_PREMIUM_COLLECTION_LIMIT,\r\n    hasPremiumFlag\r\n} from './plugins/utils/index.ts';\r\nimport {\r\n    fillObjectDataBeforeInsert,\r\n    createRxCollectionStorageInstance,\r\n    removeCollectionStorages,\r\n    ensureRxCollectionIsNotClosed\r\n} from './rx-collection-helper.ts';\r\nimport {\r\n    createRxQuery,\r\n    _getDefaultQuery\r\n} from './rx-query.ts';\r\nimport {\r\n    newRxError,\r\n    newRxTypeError\r\n} from './rx-error.ts';\r\nimport type {\r\n    RxMigrationState\r\n} from './plugins/migration-schema/index.ts';\r\nimport {\r\n    DocumentCache,\r\n    mapDocumentsDataToCacheDocs\r\n} from './doc-cache.ts';\r\nimport {\r\n    QueryCache,\r\n    createQueryCache,\r\n    defaultCacheReplacementPolicy\r\n} from './query-cache.ts';\r\nimport {\r\n    ChangeEventBuffer,\r\n    createChangeEventBuffer\r\n} from './change-event-buffer.ts';\r\nimport {\r\n    runAsyncPluginHooks,\r\n    runPluginHooks\r\n} from './hooks.ts';\r\n\r\nimport {\r\n    Subscription,\r\n    Observable\r\n} from 'rxjs';\r\n\r\nimport type {\r\n    KeyFunctionMap,\r\n    RxCollection,\r\n    RxDatabase,\r\n    RxQuery,\r\n    RxDocument,\r\n    RxDumpCollection,\r\n    RxDumpCollectionAny,\r\n    MangoQuery,\r\n    MangoQueryNoLimit,\r\n    RxCacheReplacementPolicy,\r\n    RxStorageWriteError,\r\n    RxDocumentData,\r\n    RxStorageInstanceCreationParams,\r\n    BulkWriteRow,\r\n    RxChangeEvent,\r\n    RxChangeEventInsert,\r\n    RxChangeEventUpdate,\r\n    RxChangeEventDelete,\r\n    RxStorageInstance,\r\n    CollectionsOfDatabase,\r\n    RxChangeEventBulk,\r\n    RxLocalDocumentData,\r\n    RxDocumentBase,\r\n    RxConflictHandler,\r\n    MaybePromise,\r\n    CRDTEntry,\r\n    MangoQuerySelectorAndIndex,\r\n    MigrationStrategies\r\n} from './types/index.d.ts';\r\n\r\nimport {\r\n    RxSchema\r\n} from './rx-schema.ts';\r\n\r\nimport {\r\n    createNewRxDocument,\r\n    getRxDocumentConstructor\r\n} from './rx-document-prototype-merge.ts';\r\nimport {\r\n    getWrappedStorageInstance,\r\n    getWrittenDocumentsFromBulkWriteResponse,\r\n    throwIfIsStorageWriteError,\r\n    WrappedRxStorageInstance\r\n} from './rx-storage-helper.ts';\r\nimport { IncrementalWriteQueue } from './incremental-write.ts';\r\nimport { beforeDocumentUpdateWrite } from './rx-document.ts';\r\nimport { overwritable } from './overwritable.ts';\r\nimport type { RxPipeline, RxPipelineOptions } from './plugins/pipeline/index.ts';\r\nimport { defaultConflictHandler } from './replication-protocol/default-conflict-handler.ts';\r\nimport { rxChangeEventBulkToRxChangeEvents } from './rx-change-event.ts';\r\n\r\nconst HOOKS_WHEN = ['pre', 'post'] as const;\r\ntype HookWhenType = typeof HOOKS_WHEN[number];\r\nconst HOOKS_KEYS = ['insert', 'save', 'remove', 'create'] as const;\r\ntype HookKeyType = typeof HOOKS_KEYS[number];\r\nlet hooksApplied = false;\r\n\r\nexport const OPEN_COLLECTIONS = new Set<RxCollectionBase<any, any, any>>();\r\n\r\nexport class RxCollectionBase<\r\n    InstanceCreationOptions,\r\n    RxDocumentType = { [prop: string]: any; },\r\n    OrmMethods = {},\r\n    StaticMethods = { [key: string]: any; },\r\n    Reactivity = any\r\n> {\r\n\r\n\r\n    /**\r\n     * Stores all 'normal' documents\r\n     */\r\n    public storageInstance: WrappedRxStorageInstance<RxDocumentType, any, InstanceCreationOptions> = {} as any;\r\n    public readonly timeouts: Set<ReturnType<typeof setTimeout>> = new Set();\r\n    public incrementalWriteQueue: IncrementalWriteQueue<RxDocumentType> = {} as any;\r\n\r\n\r\n    /**\r\n     * Before reads, all these methods are awaited. Used to \"block\" reads\r\n     * depending on other processes, like when the RxPipeline is running.\r\n     */\r\n    public readonly awaitBeforeReads = new Set<() => MaybePromise<any>>();\r\n\r\n    constructor(\r\n        public readonly database: RxDatabase<CollectionsOfDatabase, any, InstanceCreationOptions, Reactivity>,\r\n        public name: string,\r\n        public schema: RxSchema<RxDocumentType>,\r\n        public internalStorageInstance: RxStorageInstance<RxDocumentType, any, InstanceCreationOptions>,\r\n        public instanceCreationOptions: InstanceCreationOptions = {} as any,\r\n        public migrationStrategies: MigrationStrategies = {},\r\n        public methods: KeyFunctionMap = {},\r\n        public attachments: KeyFunctionMap = {},\r\n        public options: any = {},\r\n        public cacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicy,\r\n        public statics: KeyFunctionMap = {},\r\n        public conflictHandler: RxConflictHandler<RxDocumentType> = defaultConflictHandler\r\n    ) {\r\n        _applyHookFunctions(this.asRxCollection);\r\n\r\n\r\n        if (database) { // might be falsy on pseudoInstance\r\n            this.eventBulks$ = database.eventBulks$.pipe(\r\n                filter(changeEventBulk => changeEventBulk.collectionName === this.name)\r\n            );\r\n        } else { }\r\n\r\n\r\n        /**\r\n         * Must be last because the hooks might throw on dev-mode\r\n         * checks and we do not want to have broken collections here.\r\n         * RxCollection instances created for testings do not have a database\r\n         * so we do not add these to the list.\r\n         */\r\n        if (this.database) {\r\n            OPEN_COLLECTIONS.add(this);\r\n        }\r\n    }\r\n\r\n    get insert$(): Observable<RxChangeEventInsert<RxDocumentType>> {\r\n        return this.$.pipe(\r\n            filter(cE => cE.operation === 'INSERT')\r\n        ) as any;\r\n    }\r\n    get update$(): Observable<RxChangeEventUpdate<RxDocumentType>> {\r\n        return this.$.pipe(\r\n            filter(cE => cE.operation === 'UPDATE')\r\n        ) as any;\r\n    }\r\n    get remove$(): Observable<RxChangeEventDelete<RxDocumentType>> {\r\n        return this.$.pipe(\r\n            filter(cE => cE.operation === 'DELETE')\r\n        ) as any;\r\n    }\r\n\r\n    public _incrementalUpsertQueues: Map<string, Promise<any>> = new Map();\r\n    // defaults\r\n    public synced: boolean = false;\r\n    public hooks: {\r\n        [key in HookKeyType]: {\r\n            [when in HookWhenType]: {\r\n                series: Function[];\r\n                parallel: Function[];\r\n            };\r\n        }\r\n    } = {} as any;\r\n    public _subs: Subscription[] = [];\r\n\r\n    public _docCache: DocumentCache<RxDocumentType, OrmMethods> = {} as any;\r\n\r\n    public _queryCache: QueryCache = createQueryCache();\r\n    public $: Observable<RxChangeEvent<RxDocumentType>> = {} as any;\r\n    public checkpoint$: Observable<any> = {} as any;\r\n    public _changeEventBuffer: ChangeEventBuffer<RxDocumentType> = {} as ChangeEventBuffer<RxDocumentType>;\r\n\r\n    /**\r\n     * Internally only use eventBulks$\r\n     * Do not use .$ or .observable$ because that has to transform\r\n     * the events which decreases performance.\r\n     */\r\n    public readonly eventBulks$: Observable<RxChangeEventBulk<any>> = {} as any;\r\n\r\n\r\n    /**\r\n     * When the collection is closed,\r\n     * these functions will be called an awaited.\r\n     * Used to automatically clean up stuff that\r\n     * belongs to this collection.\r\n    */\r\n    public onClose: (() => MaybePromise<any>)[] = [];\r\n    public closed = false;\r\n\r\n    public onRemove: (() => MaybePromise<any>)[] = [];\r\n\r\n    public async prepare(): Promise<void> {\r\n\r\n        if (!(await hasPremiumFlag())) {\r\n\r\n            /**\r\n             * When used in a test suite, we often open and close many databases with collections\r\n             * while not awaiting the database.close() call to improve the test times.\r\n             * So when reopening collections and the OPEN_COLLECTIONS size is full,\r\n             * we retry after some times to account for this.\r\n             */\r\n            let count = 0;\r\n            while (count < 10 && OPEN_COLLECTIONS.size > NON_PREMIUM_COLLECTION_LIMIT) {\r\n                count++;\r\n                await this.promiseWait(30);\r\n            }\r\n            if (OPEN_COLLECTIONS.size > NON_PREMIUM_COLLECTION_LIMIT) {\r\n                throw newRxError('COL23', {\r\n                    database: this.database.name,\r\n                    collection: this.name,\r\n                    args: {\r\n                        existing: Array.from(OPEN_COLLECTIONS.values()).map(c => ({\r\n                            db: c.database ? c.database.name : '',\r\n                            c: c.name\r\n                        }))\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n\r\n        this.storageInstance = getWrappedStorageInstance(\r\n            this.database,\r\n            this.internalStorageInstance,\r\n            this.schema.jsonSchema\r\n        );\r\n        this.incrementalWriteQueue = new IncrementalWriteQueue<RxDocumentType>(\r\n            this.storageInstance,\r\n            this.schema.primaryPath,\r\n            (newData, oldData) => beforeDocumentUpdateWrite(this as any, newData, oldData),\r\n            result => this._runHooks('post', 'save', result)\r\n        );\r\n\r\n        this.$ = this.eventBulks$.pipe(\r\n            mergeMap(changeEventBulk => rxChangeEventBulkToRxChangeEvents(changeEventBulk)),\r\n        );\r\n        this.checkpoint$ = this.eventBulks$.pipe(\r\n            map(changeEventBulk => changeEventBulk.checkpoint),\r\n        );\r\n\r\n        this._changeEventBuffer = createChangeEventBuffer<RxDocumentType>(this.asRxCollection);\r\n        let documentConstructor: any;\r\n        this._docCache = new DocumentCache(\r\n            this.schema.primaryPath,\r\n            this.eventBulks$.pipe(\r\n                filter(bulk => !bulk.isLocal),\r\n                map(bulk => bulk.events)\r\n            ),\r\n            docData => {\r\n                if (!documentConstructor) {\r\n                    documentConstructor = getRxDocumentConstructor(this.asRxCollection);\r\n                }\r\n                return createNewRxDocument(this.asRxCollection, documentConstructor, docData);\r\n            }\r\n        );\r\n\r\n\r\n        const listenToRemoveSub = this.database.internalStore.changeStream().pipe(\r\n            filter(bulk => {\r\n                const key = this.name + '-' + this.schema.version;\r\n                const found = bulk.events.find(event => {\r\n                    return (\r\n                        event.documentData.context === 'collection' &&\r\n                        event.documentData.key === key &&\r\n                        event.operation === 'DELETE'\r\n                    );\r\n                });\r\n                return !!found;\r\n            })\r\n        ).subscribe(async () => {\r\n            await this.close();\r\n            await Promise.all(this.onRemove.map(fn => fn()));\r\n        });\r\n        this._subs.push(listenToRemoveSub);\r\n\r\n\r\n        const databaseStorageToken = await this.database.storageToken;\r\n        const subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\r\n            const changeEventBulk: RxChangeEventBulk<RxDocumentType | RxLocalDocumentData> = {\r\n                id: eventBulk.id,\r\n                isLocal: false,\r\n                internal: false,\r\n                collectionName: this.name,\r\n                storageToken: databaseStorageToken,\r\n                events: eventBulk.events,\r\n                databaseToken: this.database.token,\r\n                checkpoint: eventBulk.checkpoint,\r\n                context: eventBulk.context\r\n            };\r\n            this.database.$emit(changeEventBulk);\r\n        });\r\n        this._subs.push(subDocs);\r\n\r\n        return PROMISE_RESOLVE_VOID;\r\n    }\r\n\r\n\r\n    /**\r\n     * Manually call the cleanup function of the storage.\r\n     * @link https://rxdb.info/cleanup.html\r\n     */\r\n    cleanup(_minimumDeletedTime?: number): Promise<boolean> {\r\n        ensureRxCollectionIsNotClosed(this);\r\n        throw pluginMissing('cleanup');\r\n    }\r\n\r\n    // overwritten by migration-plugin\r\n    migrationNeeded(): Promise<boolean> {\r\n        throw pluginMissing('migration-schema');\r\n    }\r\n    getMigrationState(): RxMigrationState {\r\n        throw pluginMissing('migration-schema');\r\n    }\r\n    startMigration(batchSize: number = 10): Promise<void> {\r\n        ensureRxCollectionIsNotClosed(this);\r\n        return this.getMigrationState().startMigration(batchSize);\r\n    }\r\n    migratePromise(batchSize: number = 10): Promise<any> {\r\n        return this.getMigrationState().migratePromise(batchSize);\r\n    }\r\n\r\n    async insert(\r\n        json: RxDocumentType | RxDocument\r\n    ): Promise<RxDocument<RxDocumentType, OrmMethods>> {\r\n        ensureRxCollectionIsNotClosed(this);\r\n        const writeResult = await this.bulkInsert([json as any]);\r\n\r\n        const isError = writeResult.error[0];\r\n        throwIfIsStorageWriteError(this as any, (json as any)[this.schema.primaryPath] as any, json, isError as any);\r\n        const insertResult = ensureNotFalsy(writeResult.success[0]);\r\n        return insertResult;\r\n    }\r\n\r\n    async insertIfNotExists(\r\n        json: RxDocumentType | RxDocument\r\n    ): Promise<RxDocument<RxDocumentType, OrmMethods>> {\r\n        const writeResult = await this.bulkInsert([json as any]);\r\n        if (writeResult.error.length > 0) {\r\n            const error = writeResult.error[0];\r\n            if (error.status === 409) {\r\n                const conflictDocData = error.documentInDb;\r\n                return mapDocumentsDataToCacheDocs(this._docCache, [conflictDocData])[0];\r\n\r\n            } else {\r\n                throw error;\r\n            }\r\n        }\r\n        return writeResult.success[0];\r\n    }\r\n\r\n    async bulkInsert(\r\n        docsData: RxDocumentType[]\r\n    ): Promise<{\r\n        success: RxDocument<RxDocumentType, OrmMethods>[];\r\n        error: RxStorageWriteError<RxDocumentType>[];\r\n    }> {\r\n        ensureRxCollectionIsNotClosed(this);\r\n        /**\r\n         * Optimization shortcut,\r\n         * do nothing when called with an empty array\r\n        */\r\n        if (docsData.length === 0) {\r\n            return {\r\n                success: [],\r\n                error: []\r\n            };\r\n        }\r\n\r\n        const primaryPath = this.schema.primaryPath;\r\n\r\n        const ids = new Set<string>();\r\n\r\n        /**\r\n         * This code is a bit redundant for better performance.\r\n         * Instead of iterating multiple times,\r\n         * we directly transform the input to a write-row array.\r\n         */\r\n        let insertRows: BulkWriteRow<RxDocumentType>[];\r\n        if (this.hasHooks('pre', 'insert')) {\r\n            insertRows = await Promise.all(\r\n                docsData.map(docData => {\r\n                    const useDocData = fillObjectDataBeforeInsert(this.schema, docData);\r\n                    return this._runHooks('pre', 'insert', useDocData)\r\n                        .then(() => {\r\n                            ids.add((useDocData as any)[primaryPath]);\r\n                            return { document: useDocData };\r\n                        });\r\n                })\r\n            );\r\n        } else {\r\n            insertRows = new Array(docsData.length);\r\n            const schema = this.schema;\r\n            for (let index = 0; index < docsData.length; index++) {\r\n                const docData = docsData[index];\r\n                const useDocData = fillObjectDataBeforeInsert(schema, docData);\r\n                ids.add((useDocData as any)[primaryPath]);\r\n                insertRows[index] = { document: useDocData };\r\n            }\r\n        }\r\n\r\n\r\n        if (ids.size !== docsData.length) {\r\n            throw newRxError('COL22', {\r\n                collection: this.name,\r\n                args: {\r\n                    documents: docsData\r\n                }\r\n            });\r\n        }\r\n\r\n        const results = await this.storageInstance.bulkWrite(\r\n            insertRows,\r\n            'rx-collection-bulk-insert'\r\n        );\r\n\r\n\r\n        /**\r\n         * Often the user does not need to access the RxDocuments of the bulkInsert() call.\r\n         * So we transform the data to RxDocuments only if needed to use less CPU performance.\r\n         */\r\n        let rxDocuments: RxDocument<RxDocumentType, OrmMethods>[];\r\n        const collection = this;\r\n        const ret = {\r\n            get success() {\r\n                if (!rxDocuments) {\r\n                    const success = getWrittenDocumentsFromBulkWriteResponse(\r\n                        collection.schema.primaryPath,\r\n                        insertRows,\r\n                        results\r\n                    );\r\n                    rxDocuments = mapDocumentsDataToCacheDocs<RxDocumentType, OrmMethods>(collection._docCache, success);\r\n                }\r\n                return rxDocuments;\r\n            },\r\n            error: results.error\r\n        };\r\n\r\n        if (this.hasHooks('post', 'insert')) {\r\n            const docsMap: Map<string, RxDocumentType> = new Map();\r\n            insertRows.forEach(row => {\r\n                const doc = row.document;\r\n                docsMap.set((doc as any)[primaryPath] as any, doc);\r\n            });\r\n            await Promise.all(\r\n                ret.success.map(doc => {\r\n                    return this._runHooks(\r\n                        'post',\r\n                        'insert',\r\n                        docsMap.get(doc.primary),\r\n                        doc\r\n                    );\r\n                })\r\n            );\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    async bulkRemove(\r\n        /**\r\n         * You can either remove the documents by their ids\r\n         * or by directly providing the RxDocument instances\r\n         * if you have them already. This improves performance a bit.\r\n         */\r\n        idsOrDocs: string[] | RxDocument<RxDocumentType>[]\r\n    ): Promise<{\r\n        success: RxDocument<RxDocumentType, OrmMethods>[];\r\n        error: RxStorageWriteError<RxDocumentType>[];\r\n    }> {\r\n        ensureRxCollectionIsNotClosed(this);\r\n        const primaryPath = this.schema.primaryPath;\r\n        /**\r\n         * Optimization shortcut,\r\n         * do nothing when called with an empty array\r\n         */\r\n        if (idsOrDocs.length === 0) {\r\n            return {\r\n                success: [],\r\n                error: []\r\n            };\r\n        }\r\n\r\n        let rxDocumentMap: Map<string, RxDocument<RxDocumentType, OrmMethods>>;\r\n        if (typeof idsOrDocs[0] === 'string') {\r\n            rxDocumentMap = await this.findByIds(idsOrDocs as string[]).exec();\r\n        } else {\r\n            rxDocumentMap = new Map();\r\n            (idsOrDocs as RxDocument<RxDocumentType, OrmMethods>[]).forEach(d => rxDocumentMap.set(d.primary, d));\r\n        }\r\n\r\n        const docsData: RxDocumentData<RxDocumentType>[] = [];\r\n        const docsMap: Map<string, RxDocumentData<RxDocumentType>> = new Map();\r\n        Array.from(rxDocumentMap.values()).forEach(rxDocument => {\r\n            const data: RxDocumentData<RxDocumentType> = rxDocument.toMutableJSON(true) as any;\r\n            docsData.push(data);\r\n            docsMap.set(rxDocument.primary, data);\r\n        });\r\n\r\n        await Promise.all(\r\n            docsData.map(doc => {\r\n                const primary = (doc as any)[this.schema.primaryPath];\r\n                return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\r\n            })\r\n        );\r\n        const removeDocs: BulkWriteRow<RxDocumentType>[] = docsData.map(doc => {\r\n            const writeDoc = flatClone(doc);\r\n            writeDoc._deleted = true;\r\n            return {\r\n                previous: doc,\r\n                document: writeDoc\r\n            };\r\n        });\r\n        const results = await this.storageInstance.bulkWrite(\r\n            removeDocs,\r\n            'rx-collection-bulk-remove'\r\n        );\r\n\r\n\r\n        const success = getWrittenDocumentsFromBulkWriteResponse(\r\n            this.schema.primaryPath,\r\n            removeDocs,\r\n            results\r\n        );\r\n\r\n        const deletedRxDocuments: RxDocument<RxDocumentType, OrmMethods>[] = [];\r\n        const successIds: string[] = success.map(d => {\r\n            const id = d[primaryPath] as string;\r\n            const doc = this._docCache.getCachedRxDocument(d);\r\n            deletedRxDocuments.push(doc);\r\n            return id;\r\n        });\r\n\r\n        // run hooks\r\n        await Promise.all(\r\n            successIds.map(id => {\r\n                return this._runHooks(\r\n                    'post',\r\n                    'remove',\r\n                    docsMap.get(id),\r\n                    rxDocumentMap.get(id)\r\n                );\r\n            })\r\n        );\r\n\r\n\r\n        return {\r\n            success: deletedRxDocuments,\r\n            error: results.error\r\n        };\r\n    }\r\n\r\n    /**\r\n     * same as bulkInsert but overwrites existing document with same primary\r\n     */\r\n    async bulkUpsert(docsData: Partial<RxDocumentType>[]): Promise<{\r\n        success: RxDocument<RxDocumentType, OrmMethods>[];\r\n        error: RxStorageWriteError<RxDocumentType>[];\r\n    }> {\r\n        ensureRxCollectionIsNotClosed(this);\r\n        const insertData: RxDocumentType[] = [];\r\n        const useJsonByDocId: Map<string, RxDocumentType> = new Map();\r\n        docsData.forEach(docData => {\r\n            const useJson = fillObjectDataBeforeInsert(this.schema, docData);\r\n            const primary: string = useJson[this.schema.primaryPath] as any;\r\n            if (!primary) {\r\n                throw newRxError('COL3', {\r\n                    primaryPath: this.schema.primaryPath as string,\r\n                    data: useJson,\r\n                    schema: this.schema.jsonSchema\r\n                });\r\n            }\r\n            useJsonByDocId.set(primary, useJson);\r\n            insertData.push(useJson);\r\n        });\r\n\r\n        const insertResult = await this.bulkInsert(insertData);\r\n        const success = insertResult.success.slice(0);\r\n        const error: RxStorageWriteError<RxDocumentType>[] = [];\r\n\r\n        // update the ones that existed already\r\n        await Promise.all(\r\n            insertResult.error.map(async (err) => {\r\n                if (err.status !== 409) {\r\n                    error.push(err);\r\n                } else {\r\n                    const id = err.documentId;\r\n                    const writeData = getFromMapOrThrow(useJsonByDocId, id);\r\n                    const docDataInDb = ensureNotFalsy(err.documentInDb);\r\n                    const doc = this._docCache.getCachedRxDocuments([docDataInDb])[0];\r\n                    const newDoc = await doc.incrementalModify(() => writeData);\r\n                    success.push(newDoc);\r\n                }\r\n            })\r\n        );\r\n        return {\r\n            error,\r\n            success\r\n        };\r\n    }\r\n\r\n    /**\r\n     * same as insert but overwrites existing document with same primary\r\n     */\r\n    async upsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\r\n        ensureRxCollectionIsNotClosed(this);\r\n        const bulkResult = await this.bulkUpsert([json]);\r\n        throwIfIsStorageWriteError<RxDocumentType>(\r\n            this.asRxCollection,\r\n            (json as any)[this.schema.primaryPath],\r\n            json as any,\r\n            bulkResult.error[0]\r\n        );\r\n        return bulkResult.success[0];\r\n    }\r\n\r\n    /**\r\n     * upserts to a RxDocument, uses incrementalModify if document already exists\r\n     */\r\n    incrementalUpsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\r\n        ensureRxCollectionIsNotClosed(this);\r\n        const useJson = fillObjectDataBeforeInsert(this.schema, json);\r\n        const primary: string = useJson[this.schema.primaryPath] as any;\r\n        if (!primary) {\r\n            throw newRxError('COL4', {\r\n                data: json\r\n            });\r\n        }\r\n\r\n        // ensure that it won't try 2 parallel runs\r\n        let queue = this._incrementalUpsertQueues.get(primary);\r\n        if (!queue) {\r\n            queue = PROMISE_RESOLVE_VOID;\r\n        }\r\n        queue = queue\r\n            .then(() => _incrementalUpsertEnsureRxDocumentExists(this as any, primary as any, useJson))\r\n            .then((wasInserted) => {\r\n                if (!wasInserted.inserted) {\r\n                    return _incrementalUpsertUpdate(wasInserted.doc, useJson);\r\n                } else {\r\n                    return wasInserted.doc;\r\n                }\r\n            });\r\n        this._incrementalUpsertQueues.set(primary, queue);\r\n        return queue;\r\n    }\r\n\r\n    find(queryObj?: MangoQuery<RxDocumentType>): RxQuery<\r\n        RxDocumentType,\r\n        RxDocument<RxDocumentType, OrmMethods>[],\r\n        OrmMethods,\r\n        Reactivity\r\n    > {\r\n        ensureRxCollectionIsNotClosed(this);\r\n\r\n        runPluginHooks('prePrepareRxQuery', {\r\n            op: 'find',\r\n            queryObj,\r\n            collection: this\r\n        });\r\n\r\n        if (!queryObj) {\r\n            queryObj = _getDefaultQuery();\r\n        }\r\n\r\n        const query = createRxQuery('find', queryObj, this as any);\r\n        return query as any;\r\n    }\r\n\r\n    findOne(\r\n        queryObj?: MangoQueryNoLimit<RxDocumentType> | string\r\n    ): RxQuery<\r\n        RxDocumentType,\r\n        RxDocument<RxDocumentType, OrmMethods> | null,\r\n        OrmMethods,\r\n        Reactivity\r\n    > {\r\n        ensureRxCollectionIsNotClosed(this);\r\n\r\n        runPluginHooks('prePrepareRxQuery', {\r\n            op: 'findOne',\r\n            queryObj,\r\n            collection: this\r\n        });\r\n\r\n        let query;\r\n\r\n        if (typeof queryObj === 'string') {\r\n            query = createRxQuery('findOne', {\r\n                selector: {\r\n                    [this.schema.primaryPath]: queryObj\r\n                },\r\n                limit: 1\r\n            }, this as any);\r\n        } else {\r\n            if (!queryObj) {\r\n                queryObj = _getDefaultQuery();\r\n            }\r\n\r\n            // cannot have limit on findOne queries because it will be overwritten\r\n            if ((queryObj as MangoQuery).limit) {\r\n                throw newRxError('QU6');\r\n            }\r\n\r\n            queryObj = flatClone(queryObj);\r\n            (queryObj as any).limit = 1;\r\n            query = createRxQuery<RxDocumentType>('findOne', queryObj, this as any);\r\n        }\r\n\r\n\r\n        return query as any;\r\n    }\r\n\r\n    count(queryObj?: MangoQuerySelectorAndIndex<RxDocumentType>): RxQuery<\r\n        RxDocumentType,\r\n        number,\r\n        OrmMethods,\r\n        Reactivity\r\n    > {\r\n        ensureRxCollectionIsNotClosed(this);\r\n        if (!queryObj) {\r\n            queryObj = _getDefaultQuery();\r\n        }\r\n        const query = createRxQuery('count', queryObj, this as any);\r\n        return query as any;\r\n    }\r\n\r\n    /**\r\n     * find a list documents by their primary key\r\n     * has way better performance then running multiple findOne() or a find() with a complex $or-selected\r\n     */\r\n    findByIds(\r\n        ids: string[]\r\n    ): RxQuery<\r\n        RxDocumentType,\r\n        Map<string, RxDocument<RxDocumentType, OrmMethods>>,\r\n        OrmMethods,\r\n        Reactivity\r\n    > {\r\n        ensureRxCollectionIsNotClosed(this);\r\n        const mangoQuery: MangoQuery<RxDocumentType> = {\r\n            selector: {\r\n                [this.schema.primaryPath]: {\r\n                    $in: ids.slice(0)\r\n                }\r\n            } as any\r\n        };\r\n        const query = createRxQuery('findByIds', mangoQuery, this as any);\r\n        return query as any;\r\n    }\r\n\r\n    /**\r\n     * Export collection to a JSON friendly format.\r\n     */\r\n    exportJSON(): Promise<RxDumpCollection<RxDocumentType>>;\r\n    exportJSON(): Promise<RxDumpCollectionAny<RxDocumentType>>;\r\n    exportJSON(): Promise<any> {\r\n        throw pluginMissing('json-dump');\r\n    }\r\n\r\n    /**\r\n     * Import the parsed JSON export into the collection.\r\n     * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\r\n     */\r\n    importJSON(_exportedJSON: RxDumpCollectionAny<RxDocumentType>): Promise<void> {\r\n        throw pluginMissing('json-dump');\r\n    }\r\n\r\n    insertCRDT(_updateObj: CRDTEntry<any> | CRDTEntry<any>[]): RxDocument<RxDocumentType, OrmMethods> {\r\n        throw pluginMissing('crdt');\r\n    }\r\n\r\n\r\n    addPipeline(_options: RxPipelineOptions<RxDocumentType>): Promise<RxPipeline<RxDocumentType>> {\r\n        throw pluginMissing('pipeline');\r\n    }\r\n\r\n    /**\r\n     * HOOKS\r\n     */\r\n    addHook(when: HookWhenType, key: HookKeyType, fun: any, parallel = false) {\r\n        if (typeof fun !== 'function') {\r\n            throw newRxTypeError('COL7', {\r\n                key,\r\n                when\r\n            });\r\n        }\r\n\r\n        if (!HOOKS_WHEN.includes(when)) {\r\n            throw newRxTypeError('COL8', {\r\n                key,\r\n                when\r\n            });\r\n        }\r\n\r\n        if (!HOOKS_KEYS.includes(key)) {\r\n            throw newRxError('COL9', {\r\n                key\r\n            });\r\n        }\r\n\r\n        if (when === 'post' && key === 'create' && parallel === true) {\r\n            throw newRxError('COL10', {\r\n                when,\r\n                key,\r\n                parallel\r\n            });\r\n        }\r\n\r\n        // bind this-scope to hook-function\r\n        const boundFun = fun.bind(this);\r\n\r\n        const runName = parallel ? 'parallel' : 'series';\r\n\r\n        this.hooks[key] = this.hooks[key] || {};\r\n        this.hooks[key][when] = this.hooks[key][when] || {\r\n            series: [],\r\n            parallel: []\r\n        };\r\n        this.hooks[key][when][runName].push(boundFun);\r\n    }\r\n\r\n    getHooks(when: HookWhenType, key: HookKeyType) {\r\n        if (\r\n            !this.hooks[key] ||\r\n            !this.hooks[key][when]\r\n        ) {\r\n            return {\r\n                series: [],\r\n                parallel: []\r\n            };\r\n        }\r\n        return this.hooks[key][when];\r\n    }\r\n\r\n    hasHooks(when: HookWhenType, key: HookKeyType) {\r\n        /**\r\n         * Performance shortcut\r\n         * so that we not have to build the empty object.\r\n         */\r\n        if (\r\n            !this.hooks[key] ||\r\n            !this.hooks[key][when]\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        const hooks = this.getHooks(when, key);\r\n        if (!hooks) {\r\n            return false;\r\n        }\r\n        return hooks.series.length > 0 || hooks.parallel.length > 0;\r\n    }\r\n\r\n    _runHooks(when: HookWhenType, key: HookKeyType, data: any, instance?: any): Promise<any> {\r\n        const hooks = this.getHooks(when, key);\r\n\r\n        if (!hooks) {\r\n            return PROMISE_RESOLVE_VOID;\r\n        }\r\n\r\n        // run parallel: false\r\n        const tasks = hooks.series.map((hook: any) => () => hook(data, instance));\r\n        return promiseSeries(tasks)\r\n            // run parallel: true\r\n            .then(() => Promise.all(\r\n                hooks.parallel\r\n                    .map((hook: any) => hook(data, instance))\r\n            ));\r\n    }\r\n\r\n    /**\r\n     * does the same as ._runHooks() but with non-async-functions\r\n     */\r\n    _runHooksSync(when: HookWhenType, key: HookKeyType, data: any, instance: any) {\r\n        if (!this.hasHooks(when, key)) {\r\n            return;\r\n        }\r\n        const hooks = this.getHooks(when, key);\r\n        if (!hooks) return;\r\n        hooks.series.forEach((hook: any) => hook(data, instance));\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves after the given time.\r\n     * Ensures that is properly cleans up when the collection is closed\r\n     * so that no running timeouts prevent the exit of the JavaScript process.\r\n     */\r\n    promiseWait(time: number): Promise<void> {\r\n        const ret = new Promise<void>(res => {\r\n            const timeout = setTimeout(() => {\r\n                this.timeouts.delete(timeout);\r\n                res();\r\n            }, time);\r\n            this.timeouts.add(timeout);\r\n        });\r\n        return ret;\r\n    }\r\n\r\n    async close(): Promise<boolean> {\r\n        if (this.closed) {\r\n            return PROMISE_RESOLVE_FALSE;\r\n        }\r\n\r\n        OPEN_COLLECTIONS.delete(this);\r\n\r\n\r\n        await Promise.all(this.onClose.map(fn => fn()));\r\n\r\n        /**\r\n         * Settings closed = true\r\n         * must be the first thing to do,\r\n         * so for example the replication can directly stop\r\n         * instead of sending requests to a closed storage.\r\n         */\r\n        this.closed = true;\r\n\r\n\r\n        Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\r\n        if (this._changeEventBuffer) {\r\n            this._changeEventBuffer.close();\r\n        }\r\n        /**\r\n         * First wait until the whole database is idle.\r\n         * This ensures that the storage does not get closed\r\n         * while some operation is running.\r\n         * It is important that we do not intercept a running call\r\n         * because it might lead to undefined behavior like when a doc is written\r\n         * but the change is not added to the changes collection.\r\n         */\r\n        return this.database.requestIdlePromise()\r\n            .then(() => this.storageInstance.close())\r\n            .then(() => {\r\n                /**\r\n                 * Unsubscribing must be done AFTER the storageInstance.close()\r\n                 * Because the conflict handling is part of the subscriptions and\r\n                 * otherwise there might be open conflicts to be resolved which\r\n                 * will then stuck and never resolve.\r\n                 */\r\n                this._subs.forEach(sub => sub.unsubscribe());\r\n\r\n                delete this.database.collections[this.name];\r\n                return runAsyncPluginHooks('postCloseRxCollection', this).then(() => true);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * remove all data of the collection\r\n     */\r\n    async remove(): Promise<any> {\r\n        await this.close();\r\n        await Promise.all(this.onRemove.map(fn => fn()));\r\n        /**\r\n         * TODO here we should pass the already existing\r\n         * storage instances instead of creating new ones.\r\n         */\r\n        await removeCollectionStorages(\r\n            this.database.storage,\r\n            this.database.internalStore,\r\n            this.database.token,\r\n            this.database.name,\r\n            this.name,\r\n            this.database.multiInstance,\r\n            this.database.password,\r\n            this.database.hashFunction\r\n        );\r\n    }\r\n\r\n    get asRxCollection(): RxCollection<RxDocumentType, OrmMethods, StaticMethods, any, Reactivity> {\r\n        return this as any;\r\n    }\r\n}\r\n\r\n/**\r\n * adds the hook-functions to the collections prototype\r\n * this runs only once\r\n */\r\nfunction _applyHookFunctions(\r\n    collection: RxCollection<any, any>\r\n) {\r\n    if (hooksApplied) return; // already run\r\n    hooksApplied = true;\r\n    const colProto = Object.getPrototypeOf(collection);\r\n    HOOKS_KEYS.forEach(key => {\r\n        HOOKS_WHEN.map(when => {\r\n            const fnName = when + ucfirst(key);\r\n            colProto[fnName] = function (fun: string, parallel: boolean) {\r\n                return this.addHook(when, key, fun, parallel);\r\n            };\r\n        });\r\n    });\r\n}\r\n\r\nfunction _incrementalUpsertUpdate<RxDocType>(\r\n    doc: RxDocumentBase<RxDocType>,\r\n    json: RxDocumentData<RxDocType>\r\n): Promise<RxDocumentBase<RxDocType>> {\r\n    return doc.incrementalModify((_innerDoc) => {\r\n        return json;\r\n    });\r\n}\r\n\r\n/**\r\n * ensures that the given document exists\r\n * @return promise that resolves with new doc and flag if inserted\r\n */\r\nfunction _incrementalUpsertEnsureRxDocumentExists<RxDocType>(\r\n    rxCollection: RxCollection<RxDocType>,\r\n    primary: string,\r\n    json: any\r\n): Promise<\r\n    {\r\n        doc: RxDocument<RxDocType>;\r\n        inserted: boolean;\r\n    }\r\n> {\r\n    /**\r\n     * Optimisation shortcut,\r\n     * first try to find the document in the doc-cache\r\n     */\r\n    const docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);\r\n    if (docDataFromCache) {\r\n        return Promise.resolve({\r\n            doc: rxCollection._docCache.getCachedRxDocuments([docDataFromCache])[0],\r\n            inserted: false\r\n        });\r\n    }\r\n    return rxCollection.findOne(primary).exec()\r\n        .then(doc => {\r\n            if (!doc) {\r\n                return rxCollection.insert(json).then(newDoc => ({\r\n                    doc: newDoc,\r\n                    inserted: true\r\n                }));\r\n            } else {\r\n                return {\r\n                    doc,\r\n                    inserted: false\r\n                };\r\n            }\r\n        });\r\n}\r\n\r\n/**\r\n * creates and prepares a new collection\r\n */\r\nexport function createRxCollection(\r\n    {\r\n        database,\r\n        name,\r\n        schema,\r\n        instanceCreationOptions = {},\r\n        migrationStrategies = {},\r\n        autoMigrate = true,\r\n        statics = {},\r\n        methods = {},\r\n        attachments = {},\r\n        options = {},\r\n        localDocuments = false,\r\n        cacheReplacementPolicy = defaultCacheReplacementPolicy,\r\n        conflictHandler = defaultConflictHandler\r\n    }: any\r\n): Promise<RxCollection> {\r\n    const storageInstanceCreationParams: RxStorageInstanceCreationParams<any, any> = {\r\n        databaseInstanceToken: database.token,\r\n        databaseName: database.name,\r\n        collectionName: name,\r\n        schema: schema.jsonSchema,\r\n        options: instanceCreationOptions,\r\n        multiInstance: database.multiInstance,\r\n        password: database.password,\r\n        devMode: overwritable.isDevMode()\r\n    };\r\n\r\n    runPluginHooks(\r\n        'preCreateRxStorageInstance',\r\n        storageInstanceCreationParams\r\n    );\r\n\r\n    return createRxCollectionStorageInstance(\r\n        database,\r\n        storageInstanceCreationParams\r\n    ).then(storageInstance => {\r\n        const collection = new RxCollectionBase(\r\n            database,\r\n            name,\r\n            schema,\r\n            storageInstance,\r\n            instanceCreationOptions,\r\n            migrationStrategies,\r\n            methods,\r\n            attachments,\r\n            options,\r\n            cacheReplacementPolicy,\r\n            statics,\r\n            conflictHandler\r\n        );\r\n\r\n        return collection\r\n            .prepare()\r\n            .then(() => {\r\n                // ORM add statics\r\n                Object\r\n                    .entries(statics)\r\n                    .forEach(([funName, fun]) => {\r\n                        Object.defineProperty(collection, funName, {\r\n                            get: () => (fun as any).bind(collection)\r\n                        });\r\n                    });\r\n\r\n                let ret = PROMISE_RESOLVE_VOID;\r\n                if (autoMigrate && collection.schema.version !== 0) {\r\n                    ret = collection.migratePromise();\r\n                }\r\n                return ret;\r\n            })\r\n            .then(() => {\r\n                runPluginHooks('createRxCollection', {\r\n                    collection,\r\n                    creator: {\r\n                        name,\r\n                        schema,\r\n                        storageInstance,\r\n                        instanceCreationOptions,\r\n                        migrationStrategies,\r\n                        methods,\r\n                        attachments,\r\n                        options,\r\n                        cacheReplacementPolicy,\r\n                        localDocuments,\r\n                        statics\r\n                    }\r\n                });\r\n                return collection as any;\r\n            })\r\n            /**\r\n             * If the collection creation fails,\r\n             * we yet have to close the storage instances.\r\n             */\r\n            .catch(err => {\r\n                OPEN_COLLECTIONS.delete(collection);\r\n                return storageInstance.close()\r\n                    .then(() => Promise.reject(err as Error));\r\n            });\r\n    });\r\n}\r\n\r\nexport function isRxCollection(obj: any): boolean {\r\n    return obj instanceof RxCollectionBase;\r\n}\r\n"],"mappings":"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","ignoreList":[]}