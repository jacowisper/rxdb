{"version":3,"file":"custom-index.js","names":["getSchemaByObjectPath","ensureNotFalsy","objectPathMonad","INDEX_MAX","INDEX_MIN","getIndexMeta","schema","index","fieldNameProperties","map","fieldName","schemaPart","Error","type","parsedLengths","getStringLengthOfIndexNumber","getValue","maxLength","getIndexStringPart","docData","fieldValue","padEnd","getNumberIndexString","ret","getIndexableStringMonad","fieldNamePropertiesAmount","length","indexPartsFunctions","r","str","i","minimum","Math","floor","maximum","ceil","multipleOf","valueSpan","nonDecimals","toString","multipleOfParts","split","decimals","roundedMinimum","getIndexStringLength","forEach","props","getPrimaryKeyFromIndexableString","indexableString","primaryKeyLength","paddedPrimaryKey","slice","primaryKey","trim","nonDecimalsValueAsString","padStart","splitByDecimalPoint","decimalValueAsString","getStartIndexStringFromLowerBound","lowerBound","idx","bound","boolToStr","fillChar","repeat","add","getStartIndexStringFromUpperBound","upperBound","changeIndexableStringByOneQuantum","direction","lastChar","charCode","charCodeAt","withoutLastChar","String","fromCharCode"],"sources":["../../src/custom-index.ts"],"sourcesContent":["/**\r\n * For some RxStorage implementations,\r\n * we need to use our custom crafted indexes\r\n * so we can easily iterate over them. And sort plain arrays of document data.\r\n *\r\n * We really often have to craft an index string for a given document.\r\n * Performance of everything in this file is very important\r\n * which is why the code sometimes looks strange.\r\n * Run performance tests before and after you touch anything here!\r\n */\r\n\r\nimport {\r\n    getSchemaByObjectPath\r\n} from './rx-schema-helper.ts';\r\nimport type {\r\n    JsonSchema,\r\n    RxDocumentData,\r\n    RxJsonSchema\r\n} from './types/index.ts';\r\nimport {\r\n    ensureNotFalsy,\r\n    objectPathMonad,\r\n    ObjectPathMonadFunction\r\n} from './plugins/utils/index.ts';\r\nimport {\r\n    INDEX_MAX,\r\n    INDEX_MIN\r\n} from './query-planner.ts';\r\n\r\n\r\n/**\r\n * Prepare all relevant information\r\n * outside of the returned function\r\n * from getIndexableStringMonad()\r\n * to save performance when the returned\r\n * function is called many times.\r\n */\r\ntype IndexMetaField<RxDocType> = {\r\n    fieldName: string;\r\n    schemaPart: JsonSchema;\r\n    /*\r\n     * Only in number fields.\r\n     */\r\n    parsedLengths?: ParsedLengths;\r\n    getValue: ObjectPathMonadFunction<RxDocType>;\r\n    getIndexStringPart: (docData: RxDocumentData<RxDocType>) => string;\r\n};\r\n\r\nexport function getIndexMeta<RxDocType>(\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    index: string[]\r\n): IndexMetaField<RxDocType>[] {\r\n    const fieldNameProperties: IndexMetaField<RxDocType>[] = index.map(fieldName => {\r\n        const schemaPart = getSchemaByObjectPath(\r\n            schema,\r\n            fieldName\r\n        );\r\n        if (!schemaPart) {\r\n            throw new Error('not in schema: ' + fieldName);\r\n        }\r\n        const type = schemaPart.type;\r\n        let parsedLengths: ParsedLengths | undefined;\r\n        if (type === 'number' || type === 'integer') {\r\n            parsedLengths = getStringLengthOfIndexNumber(\r\n                schemaPart\r\n            );\r\n        }\r\n\r\n        const getValue = objectPathMonad(fieldName);\r\n        const maxLength = schemaPart.maxLength ? schemaPart.maxLength : 0;\r\n\r\n        let getIndexStringPart: (docData: RxDocumentData<RxDocType>) => string;\r\n        if (type === 'string') {\r\n            getIndexStringPart = docData => {\r\n                let fieldValue = getValue(docData);\r\n                if (!fieldValue) {\r\n                    fieldValue = '';\r\n                }\r\n                return fieldValue.padEnd(maxLength, ' ');\r\n            };\r\n        } else if (type === 'boolean') {\r\n            getIndexStringPart = docData => {\r\n                const fieldValue = getValue(docData);\r\n                return fieldValue ? '1' : '0';\r\n            };\r\n        } else { // number\r\n            getIndexStringPart = docData => {\r\n                const fieldValue = getValue(docData);\r\n                return getNumberIndexString(\r\n                    parsedLengths as any,\r\n                    fieldValue\r\n                );\r\n            };\r\n        }\r\n\r\n        const ret: IndexMetaField<RxDocType> = {\r\n            fieldName,\r\n            schemaPart,\r\n            parsedLengths,\r\n            getValue,\r\n            getIndexStringPart\r\n        };\r\n        return ret;\r\n    });\r\n    return fieldNameProperties;\r\n}\r\n\r\n\r\n/**\r\n * Crafts an indexable string that can be used\r\n * to check if a document would be sorted below or above\r\n * another documents, dependent on the index values.\r\n * @monad for better performance\r\n *\r\n * IMPORTANT: Performance is really important here\r\n * which is why we code so 'strange'.\r\n * Always run performance tests when you want to\r\n * change something in this method.\r\n */\r\nexport function getIndexableStringMonad<RxDocType>(\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    index: string[]\r\n): (docData: RxDocumentData<RxDocType>) => string {\r\n    const fieldNameProperties = getIndexMeta(schema, index);\r\n    const fieldNamePropertiesAmount = fieldNameProperties.length;\r\n    const indexPartsFunctions = fieldNameProperties.map(r => r.getIndexStringPart);\r\n\r\n\r\n    /**\r\n     * @hotPath Performance of this function is very critical!\r\n     */\r\n    const ret = function (docData: RxDocumentData<RxDocType>): string {\r\n        let str = '';\r\n        for (let i = 0; i < fieldNamePropertiesAmount; ++i) {\r\n            str += indexPartsFunctions[i](docData);\r\n        }\r\n        return str;\r\n    };\r\n    return ret;\r\n}\r\n\r\n\r\ndeclare type ParsedLengths = {\r\n    minimum: number;\r\n    maximum: number;\r\n    nonDecimals: number;\r\n    decimals: number;\r\n    roundedMinimum: number;\r\n};\r\nexport function getStringLengthOfIndexNumber(\r\n    schemaPart: JsonSchema\r\n): ParsedLengths {\r\n    const minimum = Math.floor(schemaPart.minimum as number);\r\n    const maximum = Math.ceil(schemaPart.maximum as number);\r\n    const multipleOf: number = schemaPart.multipleOf as number;\r\n\r\n    const valueSpan = maximum - minimum;\r\n    const nonDecimals = valueSpan.toString().length;\r\n\r\n    const multipleOfParts = multipleOf.toString().split('.');\r\n    let decimals = 0;\r\n    if (multipleOfParts.length > 1) {\r\n        decimals = multipleOfParts[1].length;\r\n    }\r\n    return {\r\n        minimum,\r\n        maximum,\r\n        nonDecimals,\r\n        decimals,\r\n        roundedMinimum: minimum\r\n    };\r\n}\r\n\r\nexport function getIndexStringLength<RxDocType>(\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    index: string[]\r\n): number {\r\n    const fieldNameProperties = getIndexMeta(schema, index);\r\n    let length = 0;\r\n    fieldNameProperties.forEach(props => {\r\n        const schemaPart = props.schemaPart;\r\n        const type = schemaPart.type;\r\n\r\n        if (type === 'string') {\r\n            length += schemaPart.maxLength as number;\r\n        } else if (type === 'boolean') {\r\n            length += 1;\r\n        } else {\r\n            const parsedLengths = props.parsedLengths as ParsedLengths;\r\n            length = length + parsedLengths.nonDecimals + parsedLengths.decimals;\r\n        }\r\n\r\n    });\r\n    return length;\r\n}\r\n\r\n\r\nexport function getPrimaryKeyFromIndexableString(\r\n    indexableString: string,\r\n    primaryKeyLength: number\r\n): string {\r\n    const paddedPrimaryKey = indexableString.slice(primaryKeyLength * -1);\r\n    // we can safely trim here because the primary key is not allowed to start or end with a space char.\r\n    const primaryKey = paddedPrimaryKey.trim();\r\n    return primaryKey;\r\n}\r\n\r\n\r\nexport function getNumberIndexString(\r\n    parsedLengths: ParsedLengths,\r\n    fieldValue: number\r\n): string {\r\n    /**\r\n     * Ensure that the given value is in the boundaries\r\n     * of the schema, otherwise it would create a broken index string.\r\n     * This can happen for example if you have a minimum of 0\r\n     * and run a query like\r\n     * selector {\r\n     *  numField: { $gt: -1000 }\r\n     * }\r\n     */\r\n    if (typeof fieldValue === 'undefined') {\r\n        fieldValue = 0;\r\n    }\r\n    if (fieldValue < parsedLengths.minimum) {\r\n        fieldValue = parsedLengths.minimum;\r\n    }\r\n    if (fieldValue > parsedLengths.maximum) {\r\n        fieldValue = parsedLengths.maximum;\r\n    }\r\n\r\n    const nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();\r\n    let str = nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, '0');\r\n\r\n    if (parsedLengths.decimals > 0) {\r\n        const splitByDecimalPoint = fieldValue.toString().split('.');\r\n        const decimalValueAsString = splitByDecimalPoint.length > 1 ? splitByDecimalPoint[1] : '0';\r\n        str += decimalValueAsString.padEnd(parsedLengths.decimals, '0');\r\n    }\r\n    return str;\r\n}\r\n\r\nexport function getStartIndexStringFromLowerBound(\r\n    schema: RxJsonSchema<any>,\r\n    index: string[],\r\n    lowerBound: (string | boolean | number | null | undefined)[]\r\n): string {\r\n    let str = '';\r\n    index.forEach((fieldName, idx) => {\r\n        const schemaPart = getSchemaByObjectPath(\r\n            schema,\r\n            fieldName\r\n        );\r\n        const bound = lowerBound[idx];\r\n        const type = schemaPart.type;\r\n\r\n        switch (type) {\r\n            case 'string':\r\n                const maxLength = ensureNotFalsy(schemaPart.maxLength, 'maxLength not set');\r\n                if (typeof bound === 'string') {\r\n                    str += (bound as string).padEnd(maxLength, ' ');\r\n                } else {\r\n                    // str += ''.padStart(maxLength, inclusiveStart ? ' ' : INDEX_MAX);\r\n                    str += ''.padEnd(maxLength, ' ');\r\n                }\r\n                break;\r\n            case 'boolean':\r\n                if (bound === null) {\r\n                    str += '0';\r\n                } else if (bound === INDEX_MIN) {\r\n                    str += '0';\r\n                } else if (bound === INDEX_MAX) {\r\n                    str += '1';\r\n                } else {\r\n                    const boolToStr = bound ? '1' : '0';\r\n                    str += boolToStr;\r\n                }\r\n                break;\r\n            case 'number':\r\n            case 'integer':\r\n                const parsedLengths = getStringLengthOfIndexNumber(\r\n                    schemaPart\r\n                );\r\n                if (bound === null || bound === INDEX_MIN) {\r\n                    const fillChar = '0';\r\n                    str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\r\n                } else if (bound === INDEX_MAX) {\r\n                    str += getNumberIndexString(\r\n                        parsedLengths,\r\n                        parsedLengths.maximum\r\n                    );\r\n                } else {\r\n                    const add = getNumberIndexString(\r\n                        parsedLengths,\r\n                        bound as number\r\n                    );\r\n                    str += add;\r\n                }\r\n                break;\r\n            default:\r\n                throw new Error('unknown index type ' + type);\r\n        }\r\n    });\r\n    return str;\r\n}\r\n\r\n\r\nexport function getStartIndexStringFromUpperBound(\r\n    schema: RxJsonSchema<any>,\r\n    index: string[],\r\n    upperBound: (string | boolean | number | null | undefined)[]\r\n): string {\r\n    let str = '';\r\n    index.forEach((fieldName, idx) => {\r\n        const schemaPart = getSchemaByObjectPath(\r\n            schema,\r\n            fieldName\r\n        );\r\n        const bound = upperBound[idx];\r\n        const type = schemaPart.type;\r\n\r\n        switch (type) {\r\n            case 'string':\r\n                const maxLength = ensureNotFalsy(schemaPart.maxLength, 'maxLength not set');\r\n                if (typeof bound === 'string' && bound !== INDEX_MAX) {\r\n                    str += (bound as string).padEnd(maxLength, ' ');\r\n                } else if (bound === INDEX_MIN) {\r\n                    str += ''.padEnd(maxLength, ' ');\r\n                } else {\r\n                    str += ''.padEnd(maxLength, INDEX_MAX);\r\n                }\r\n                break;\r\n            case 'boolean':\r\n                if (bound === null) {\r\n                    str += '1';\r\n                } else {\r\n                    const boolToStr = bound ? '1' : '0';\r\n                    str += boolToStr;\r\n                }\r\n                break;\r\n            case 'number':\r\n            case 'integer':\r\n                const parsedLengths = getStringLengthOfIndexNumber(\r\n                    schemaPart\r\n                );\r\n                if (bound === null || bound === INDEX_MAX) {\r\n                    const fillChar = '9';\r\n                    str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\r\n                } else if (bound === INDEX_MIN) {\r\n                    const fillChar = '0';\r\n                    str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\r\n                } else {\r\n                    str += getNumberIndexString(\r\n                        parsedLengths,\r\n                        bound as number\r\n                    );\r\n                }\r\n                break;\r\n            default:\r\n                throw new Error('unknown index type ' + type);\r\n        }\r\n    });\r\n    return str;\r\n}\r\n\r\n/**\r\n * Used in storages where it is not possible\r\n * to define inclusiveEnd/inclusiveStart\r\n */\r\nexport function changeIndexableStringByOneQuantum(str: string, direction: 1 | -1): string {\r\n    const lastChar = str.slice(-1);\r\n    let charCode = lastChar.charCodeAt(0);\r\n    charCode = charCode + direction;\r\n    const withoutLastChar = str.slice(0, -1);\r\n    return withoutLastChar + String.fromCharCode(charCode);\r\n}\r\n"],"mappings":"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","ignoreList":[]}