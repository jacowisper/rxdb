{"version":3,"file":"rx-database-internal-store.js","names":["isBulkWriteConflictError","newRxError","fillWithDefaultSettings","getComposedPrimaryKeyOfDocumentData","getSingleDocument","getWrittenDocumentsFromBulkWriteResponse","writeSingle","clone","ensureNotFalsy","getDefaultRevision","getDefaultRxDocumentMeta","randomToken","prepareQuery","INTERNAL_CONTEXT_COLLECTION","INTERNAL_CONTEXT_STORAGE_TOKEN","INTERNAL_CONTEXT_MIGRATION_STATUS","INTERNAL_CONTEXT_PIPELINE_CHECKPOINT","INTERNAL_STORE_SCHEMA_TITLE","INTERNAL_STORE_SCHEMA","version","title","primaryKey","key","fields","separator","type","properties","id","maxLength","context","enum","data","additionalProperties","indexes","required","sharding","shards","mode","getPrimaryKeyOfInternalDocument","getAllCollectionDocuments","storageInstance","getAllQueryPrepared","schema","selector","_deleted","$eq","sort","skip","queryResult","query","allDocs","documents","STORAGE_TOKEN_DOCUMENT_KEY","STORAGE_TOKEN_DOCUMENT_ID","ensureStorageTokenDocumentExists","rxDatabase","storageToken","passwordHash","password","hashFunction","JSON","stringify","undefined","docData","rxdbVersion","token","instanceToken","_meta","_rev","_attachments","writeRows","document","writeResult","internalStore","bulkWrite","error","isError","conflictError","isDatabaseStateVersionCompatibleWithDatabaseCode","documentInDb","args","database","name","databaseStateVersion","codeVersion","existingPasswordHash","storageTokenDocInDb","stateMajor","split","codeMajor","addConnectedStorageToCollection","collection","storageCollectionName","collectionNameWithVersion","_collectionNamePrimary","jsonSchema","collectionDocId","collectionDoc","saveData","alreadyThere","connectedStorages","find","row","collectionName","push","previous","err","removeConnectedStorageFromCollection","isThere","filter","item"],"sources":["../../src/rx-database-internal-store.ts"],"sourcesContent":["import {\r\n    isBulkWriteConflictError,\r\n    newRxError\r\n} from './rx-error.ts';\r\nimport {\r\n    fillWithDefaultSettings,\r\n    getComposedPrimaryKeyOfDocumentData\r\n} from './rx-schema-helper.ts';\r\nimport { getSingleDocument, getWrittenDocumentsFromBulkWriteResponse, writeSingle } from './rx-storage-helper.ts';\r\nimport type {\r\n    CollectionsOfDatabase,\r\n    InternalStoreCollectionDocType,\r\n    InternalStoreDocType,\r\n    InternalStoreStorageTokenDocType,\r\n    RxCollection,\r\n    RxDatabase,\r\n    RxDocumentData,\r\n    RxJsonSchema,\r\n    RxStorageInstance,\r\n    RxStorageWriteErrorConflict\r\n} from './types/index.d.ts';\r\nimport {\r\n    clone,\r\n    ensureNotFalsy,\r\n    getDefaultRevision,\r\n    getDefaultRxDocumentMeta,\r\n    randomToken\r\n} from './plugins/utils/index.ts';\r\nimport { prepareQuery } from './rx-query-helper.ts';\r\n\r\nexport const INTERNAL_CONTEXT_COLLECTION = 'collection';\r\nexport const INTERNAL_CONTEXT_STORAGE_TOKEN = 'storage-token';\r\nexport const INTERNAL_CONTEXT_MIGRATION_STATUS = 'rx-migration-status';\r\nexport const INTERNAL_CONTEXT_PIPELINE_CHECKPOINT = 'rx-pipeline-checkpoint';\r\n\r\n/**\r\n * Do not change the title,\r\n * we have to flag the internal schema so that\r\n * some RxStorage implementations are able\r\n * to detect if the created RxStorageInstance\r\n * is from the internals or not,\r\n * to do some optimizations in some cases.\r\n */\r\nexport const INTERNAL_STORE_SCHEMA_TITLE = 'RxInternalDocument';\r\n\r\nexport const INTERNAL_STORE_SCHEMA: RxJsonSchema<RxDocumentData<InternalStoreDocType<any>>> = fillWithDefaultSettings({\r\n    version: 0,\r\n    title: INTERNAL_STORE_SCHEMA_TITLE,\r\n    primaryKey: {\r\n        key: 'id',\r\n        fields: [\r\n            'context',\r\n            'key'\r\n        ],\r\n        separator: '|'\r\n    },\r\n    type: 'object',\r\n    properties: {\r\n        id: {\r\n            type: 'string',\r\n            maxLength: 200\r\n        },\r\n        key: {\r\n            type: 'string'\r\n        },\r\n        context: {\r\n            type: 'string',\r\n            enum: [\r\n                INTERNAL_CONTEXT_COLLECTION,\r\n                INTERNAL_CONTEXT_STORAGE_TOKEN,\r\n                INTERNAL_CONTEXT_MIGRATION_STATUS,\r\n                INTERNAL_CONTEXT_PIPELINE_CHECKPOINT,\r\n                'OTHER'\r\n            ]\r\n        },\r\n        data: {\r\n            type: 'object',\r\n            additionalProperties: true\r\n        }\r\n    },\r\n    indexes: [],\r\n    required: [\r\n        'key',\r\n        'context',\r\n        'data'\r\n    ],\r\n    additionalProperties: false,\r\n    /**\r\n     * If the sharding plugin is used,\r\n     * it must not shard on the internal RxStorageInstance\r\n     * because that one anyway has only a small amount of documents\r\n     * and also its creation is in the hot path of the initial page load,\r\n     * so we should spend less time creating multiple RxStorageInstances.\r\n     */\r\n    sharding: {\r\n        shards: 1,\r\n        mode: 'collection'\r\n    }\r\n});\r\n\r\n\r\nexport function getPrimaryKeyOfInternalDocument(\r\n    key: string,\r\n    context: string\r\n): string {\r\n    return getComposedPrimaryKeyOfDocumentData<InternalStoreDocType>(\r\n        INTERNAL_STORE_SCHEMA,\r\n        {\r\n            key,\r\n            context\r\n        }\r\n    );\r\n}\r\n\r\n/**\r\n * Returns all internal documents\r\n * with context 'collection'\r\n */\r\nexport async function getAllCollectionDocuments(\r\n    storageInstance: RxStorageInstance<InternalStoreDocType<any>, any, any>\r\n): Promise<RxDocumentData<InternalStoreCollectionDocType>[]> {\r\n    const getAllQueryPrepared = prepareQuery<InternalStoreDocType<any>>(\r\n        storageInstance.schema,\r\n        {\r\n            selector: {\r\n                context: INTERNAL_CONTEXT_COLLECTION,\r\n                _deleted: {\r\n                    $eq: false\r\n                }\r\n            },\r\n            sort: [{ id: 'asc' }],\r\n            skip: 0\r\n        }\r\n    );\r\n    const queryResult = await storageInstance.query(getAllQueryPrepared);\r\n    const allDocs = queryResult.documents;\r\n    return allDocs;\r\n}\r\n\r\n/**\r\n * to not confuse multiInstance-messages with other databases that have the same\r\n * name and adapter, but do not share state with this one (for example in-memory-instances),\r\n * we set a storage-token and use it in the broadcast-channel\r\n */\r\nexport const STORAGE_TOKEN_DOCUMENT_KEY = 'storageToken';\r\n\r\nexport const STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(\r\n    STORAGE_TOKEN_DOCUMENT_KEY,\r\n    INTERNAL_CONTEXT_STORAGE_TOKEN\r\n);\r\n\r\nexport async function ensureStorageTokenDocumentExists<Collections extends CollectionsOfDatabase = any>(\r\n    rxDatabase: RxDatabase<Collections>\r\n): Promise<RxDocumentData<InternalStoreStorageTokenDocType>> {\r\n\r\n    /**\r\n     * To have less read-write cycles,\r\n     * we just try to insert a new document\r\n     * and only fetch the existing one if a conflict happened.\r\n     */\r\n    const storageToken = randomToken(10);\r\n\r\n    const passwordHash = rxDatabase.password ?\r\n        await rxDatabase.hashFunction(JSON.stringify(rxDatabase.password)) :\r\n        undefined;\r\n\r\n    const docData: RxDocumentData<InternalStoreStorageTokenDocType> = {\r\n        id: STORAGE_TOKEN_DOCUMENT_ID,\r\n        context: INTERNAL_CONTEXT_STORAGE_TOKEN,\r\n        key: STORAGE_TOKEN_DOCUMENT_KEY,\r\n        data: {\r\n            rxdbVersion: rxDatabase.rxdbVersion,\r\n            token: storageToken,\r\n            /**\r\n             * We add the instance token here\r\n             * to be able to detect if a given RxDatabase instance\r\n             * is the first instance that was ever created\r\n             * or if databases have existed earlier on that storage\r\n             * with the same database name.\r\n             */\r\n            instanceToken: rxDatabase.token,\r\n            passwordHash\r\n        },\r\n        _deleted: false,\r\n        _meta: getDefaultRxDocumentMeta(),\r\n        _rev: getDefaultRevision(),\r\n        _attachments: {}\r\n    };\r\n\r\n    const writeRows = [{ document: docData }];\r\n    const writeResult = await rxDatabase.internalStore.bulkWrite(\r\n        writeRows,\r\n        'internal-add-storage-token'\r\n    );\r\n    if (!writeResult.error[0]) {\r\n        return getWrittenDocumentsFromBulkWriteResponse(\r\n            'id',\r\n            writeRows,\r\n            writeResult\r\n        )[0];\r\n    }\r\n\r\n    /**\r\n     * If we get a 409 error,\r\n     * it means another instance already inserted the storage token.\r\n     * So we get that token from the database and return that one.\r\n     */\r\n    const error = ensureNotFalsy(writeResult.error[0]);\r\n    if (\r\n        error.isError &&\r\n        isBulkWriteConflictError(error)\r\n    ) {\r\n        const conflictError = (error as RxStorageWriteErrorConflict<InternalStoreStorageTokenDocType>);\r\n\r\n        if (\r\n            !isDatabaseStateVersionCompatibleWithDatabaseCode(\r\n                conflictError.documentInDb.data.rxdbVersion,\r\n                rxDatabase.rxdbVersion\r\n            )\r\n        ) {\r\n            throw newRxError('DM5', {\r\n                args: {\r\n                    database: rxDatabase.name,\r\n                    databaseStateVersion: conflictError.documentInDb.data.rxdbVersion,\r\n                    codeVersion: rxDatabase.rxdbVersion\r\n                }\r\n            });\r\n        }\r\n\r\n        if (\r\n            passwordHash &&\r\n            passwordHash !== conflictError.documentInDb.data.passwordHash\r\n        ) {\r\n            throw newRxError('DB1', {\r\n                passwordHash,\r\n                existingPasswordHash: conflictError.documentInDb.data.passwordHash\r\n            });\r\n        }\r\n\r\n        const storageTokenDocInDb = conflictError.documentInDb;\r\n        return ensureNotFalsy(storageTokenDocInDb);\r\n    }\r\n    throw error;\r\n}\r\n\r\n\r\nexport function isDatabaseStateVersionCompatibleWithDatabaseCode(\r\n    databaseStateVersion: string,\r\n    codeVersion: string\r\n): boolean {\r\n    if (!databaseStateVersion) {\r\n        return false;\r\n    }\r\n\r\n    const stateMajor = databaseStateVersion.split('.')[0];\r\n    const codeMajor = codeVersion.split('.')[0];\r\n\r\n    /**\r\n     * Version v15 data must be upwards compatible to v16\r\n     */\r\n    if (stateMajor === '15' && codeMajor === '16') {\r\n        return true;\r\n    }\r\n\r\n    if (stateMajor !== codeMajor) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n\r\n\r\n\r\nexport async function addConnectedStorageToCollection(\r\n    collection: RxCollection<any>,\r\n    storageCollectionName: string,\r\n    schema: RxJsonSchema<any>\r\n) {\r\n\r\n    if (collection.schema.version !== schema.version) {\r\n        throw newRxError('SNH', {\r\n            schema,\r\n            version: collection.schema.version,\r\n            name: collection.name,\r\n            collection,\r\n            args: {\r\n                storageCollectionName\r\n            }\r\n        });\r\n    }\r\n\r\n    const collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\r\n    const collectionDocId = getPrimaryKeyOfInternalDocument(\r\n        collectionNameWithVersion,\r\n        INTERNAL_CONTEXT_COLLECTION\r\n    );\r\n\r\n    while (true) {\r\n        const collectionDoc = await getSingleDocument(\r\n            collection.database.internalStore,\r\n            collectionDocId\r\n        );\r\n        const saveData: RxDocumentData<InternalStoreCollectionDocType> = clone(ensureNotFalsy(collectionDoc));\r\n\r\n        // do nothing if already in array\r\n        const alreadyThere = saveData.data.connectedStorages\r\n            .find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\r\n        if (alreadyThere) {\r\n            return;\r\n        }\r\n\r\n        // otherwise add to array and save\r\n        saveData.data.connectedStorages.push({\r\n            collectionName: storageCollectionName,\r\n            schema\r\n        });\r\n        try {\r\n            await writeSingle(\r\n                collection.database.internalStore,\r\n                {\r\n                    previous: ensureNotFalsy(collectionDoc),\r\n                    document: saveData\r\n                },\r\n                'add-connected-storage-to-collection'\r\n            );\r\n        } catch (err) {\r\n            if (!isBulkWriteConflictError(err)) {\r\n                throw err;\r\n            }\r\n            // retry on conflict\r\n        }\r\n    }\r\n}\r\n\r\nexport async function removeConnectedStorageFromCollection(\r\n    collection: RxCollection<any>,\r\n    storageCollectionName: string,\r\n    schema: RxJsonSchema<any>\r\n) {\r\n    if (collection.schema.version !== schema.version) {\r\n        throw newRxError('SNH', {\r\n            schema,\r\n            version: collection.schema.version,\r\n            name: collection.name,\r\n            collection,\r\n            args: {\r\n                storageCollectionName\r\n            }\r\n        });\r\n    }\r\n\r\n    const collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\r\n    const collectionDocId = getPrimaryKeyOfInternalDocument(\r\n        collectionNameWithVersion,\r\n        INTERNAL_CONTEXT_COLLECTION\r\n    );\r\n\r\n    while (true) {\r\n        const collectionDoc = await getSingleDocument(\r\n            collection.database.internalStore,\r\n            collectionDocId\r\n        );\r\n        const saveData: RxDocumentData<InternalStoreCollectionDocType> = clone(ensureNotFalsy(collectionDoc));\r\n\r\n        // do nothing if not there\r\n        const isThere = saveData.data.connectedStorages\r\n            .find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\r\n        if (!isThere) {\r\n            return;\r\n        }\r\n\r\n        // otherwise remove from array and save\r\n        saveData.data.connectedStorages = saveData.data.connectedStorages.filter(item => item.collectionName !== storageCollectionName);\r\n        try {\r\n            await writeSingle(\r\n                collection.database.internalStore,\r\n                {\r\n                    previous: ensureNotFalsy(collectionDoc),\r\n                    document: saveData\r\n                },\r\n                'remove-connected-storage-from-collection'\r\n            );\r\n        } catch (err) {\r\n            if (!isBulkWriteConflictError(err)) {\r\n                throw err;\r\n            }\r\n            // retry on conflict\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * returns the primary for a given collection-data\r\n * used in the internal store of a RxDatabase\r\n */\r\nexport function _collectionNamePrimary(name: string, schema: RxJsonSchema<any>) {\r\n    return name + '-' + schema.version;\r\n}\r\n"],"mappings":"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","ignoreList":[]}