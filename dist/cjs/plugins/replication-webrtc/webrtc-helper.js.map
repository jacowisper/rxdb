{"version":3,"file":"webrtc-helper.js","names":["_rxjs","require","isMasterInWebRTCReplication","hashFunction","ownStorageToken","otherStorageToken","isMaster","join","sendMessageAndAwaitAnswer","handler","peer","message","requestId","id","answerPromise","firstValueFrom","response$","pipe","filter","d","response","map","send"],"sources":["../../../../src/plugins/replication-webrtc/webrtc-helper.ts"],"sourcesContent":["import type {\r\n    HashFunction\r\n} from '../../types/index.d.ts';\r\nimport type {\r\n    WebRTCConnectionHandler,\r\n    WebRTCMessage,\r\n    WebRTCResponse\r\n} from './webrtc-types.ts';\r\nimport { filter, firstValueFrom, map } from 'rxjs';\r\n\r\n\r\n\r\n/**\r\n * To deterministically define which peer is master and\r\n * which peer is fork, we compare the storage tokens.\r\n * But we have to hash them before, to ensure that\r\n * a storageToken like 'aaaaaa' is not always the master\r\n * for all peers.\r\n */\r\nexport async function isMasterInWebRTCReplication(\r\n    hashFunction: HashFunction,\r\n    ownStorageToken: string,\r\n    otherStorageToken: string\r\n): Promise<boolean> {\r\n    const isMaster =\r\n        await hashFunction([ownStorageToken, otherStorageToken].join('|'))\r\n        >\r\n        await hashFunction([otherStorageToken, ownStorageToken].join('|'));\r\n    return isMaster;\r\n}\r\n\r\n/**\r\n * Send a message to the peer and await the answer.\r\n * @throws with an EmptyErrorImpl if the peer connection\r\n * was closed before an answer was received.\r\n */\r\nexport function sendMessageAndAwaitAnswer<PeerType>(\r\n    handler: WebRTCConnectionHandler<PeerType>,\r\n    peer: PeerType,\r\n    message: WebRTCMessage\r\n): Promise<WebRTCResponse> {\r\n\r\n\r\n    const requestId = message.id;\r\n    const answerPromise = firstValueFrom(\r\n        handler.response$.pipe(\r\n            filter(d => d.peer === peer),\r\n            filter(d => d.response.id === requestId),\r\n            map(d => d.response)\r\n        )\r\n    );\r\n    handler.send(peer, message);\r\n    return answerPromise;\r\n}\r\n"],"mappings":";;;;;;;AAQA,IAAAA,KAAA,GAAAC,OAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAeC,2BAA2BA,CAC7CC,YAA0B,EAC1BC,eAAuB,EACvBC,iBAAyB,EACT;EAChB,IAAMC,QAAQ,GACV,OAAMH,YAAY,CAAC,CAACC,eAAe,EAAEC,iBAAiB,CAAC,CAACE,IAAI,CAAC,GAAG,CAAC,CAAC,KAElE,MAAMJ,YAAY,CAAC,CAACE,iBAAiB,EAAED,eAAe,CAAC,CAACG,IAAI,CAAC,GAAG,CAAC,CAAC;EACtE,OAAOD,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACO,SAASE,yBAAyBA,CACrCC,OAA0C,EAC1CC,IAAc,EACdC,OAAsB,EACC;EAGvB,IAAMC,SAAS,GAAGD,OAAO,CAACE,EAAE;EAC5B,IAAMC,aAAa,GAAG,IAAAC,oBAAc,EAChCN,OAAO,CAACO,SAAS,CAACC,IAAI,CAClB,IAAAC,YAAM,EAACC,CAAC,IAAIA,CAAC,CAACT,IAAI,KAAKA,IAAI,CAAC,EAC5B,IAAAQ,YAAM,EAACC,CAAC,IAAIA,CAAC,CAACC,QAAQ,CAACP,EAAE,KAAKD,SAAS,CAAC,EACxC,IAAAS,SAAG,EAACF,CAAC,IAAIA,CAAC,CAACC,QAAQ,CACvB,CACJ,CAAC;EACDX,OAAO,CAACa,IAAI,CAACZ,IAAI,EAAEC,OAAO,CAAC;EAC3B,OAAOG,aAAa;AACxB","ignoreList":[]}