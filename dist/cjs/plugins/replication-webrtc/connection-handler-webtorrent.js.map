{"version":3,"file":"connection-handler-webtorrent.js","names":[],"sources":["../../../../src/plugins/replication-webrtc/connection-handler-webtorrent.ts"],"sourcesContent":["// /**\r\n//  * Uses the Webtorrent servers as signaling server, works similar to p2pt.\r\n//  * We could not use p2pt directly because it has so many bugs and behaves wrong in\r\n//  * cases with more then 2 peers.\r\n//  * @link https://github.com/subins2000/p2pt/blob/master/p2pt.js\r\n//  */\r\n\r\n// import { Subject } from 'rxjs';\r\n// import { PROMISE_RESOLVE_VOID, randomToken } from '../../util';\r\n// import { P2PConnectionHandler, P2PConnectionHandlerCreator, P2PMessage, P2PPeer, PeerWithMessage, PeerWithResponse } from './p2p-types';\r\n// const wrtc = require('wrtc');\r\n\r\n// const WebSocketTracker = require('bittorrent-tracker/lib/client/websocket-tracker');\r\n// const Client = require('bittorrent-tracker');\r\n// const randombytes = require('randombytes');\r\n// const EventEmitter = require('events');\r\n// const sha1 = require('simple-sha1');\r\n// const debug = require('debug')('p2pt');\r\n\r\n\r\n// export const P2PT_DEFAULT_TRACKERS = [\r\n//     'wss://tracker.files.fm:7073/announce',\r\n//     'wss://tracker.btorrent.xyz',\r\n//     'wss://spacetradersapi-chatbox.herokuapp.com:443/announce',\r\n//     'wss://qot.abiir.top:443/announce'\r\n// ];\r\n\r\n// export function getConnectionHandlerWebtorrent(\r\n//     trackers: string[] = P2PT_DEFAULT_TRACKERS,\r\n//     /**\r\n//      * Port is only required in Node.js,\r\n//      * not on browsers.\r\n//      */\r\n//     torrentClientPort = 18669\r\n// ): P2PConnectionHandlerCreator {\r\n//     const creator: P2PConnectionHandlerCreator = (options) => {\r\n//         /**\r\n//          * @link https://github.com/webtorrent/bittorrent-tracker#client\r\n//          */\r\n//         const requiredOpts = {\r\n//             infoHash: sha1.sync(options.topic).toLowerCase(),\r\n//             peerId: randombytes(20),\r\n//             announce: trackers,\r\n//             port: torrentClientPort,\r\n//             wrtc\r\n//         }\r\n//         const client = new Client(requiredOpts);\r\n\r\n//         const connect$ = new Subject<P2PPeer>();\r\n//         const disconnect$ = new Subject<P2PPeer>();\r\n//         const message$ = new Subject<PeerWithMessage>();\r\n//         const response$ = new Subject<PeerWithResponse>();\r\n\r\n\r\n//         client.on('error', function (err) {\r\n//             console.error('fatal client error! ' + requiredOpts.peerId.toString('hex'));\r\n//             console.log(err.message)\r\n//         })\r\n\r\n//         client.on('warning', function (err) {\r\n//             // a tracker was unavailable or sent bad data to the client. you can probably ignore it\r\n//             console.log(err.message)\r\n//         })\r\n\r\n//         client.on('update', function (data) {\r\n//             console.log('got an announce response from tracker: ' + data.announce)\r\n//             console.log('number of seeders in the swarm: ' + data.complete)\r\n//             console.log('number of leechers in the swarm: ' + data.incomplete)\r\n//         });\r\n\r\n//         const knownPeers = new Set<string>();\r\n//         client.on('peer', function (peer: P2PPeer) {\r\n//             console.log('found a peer: ' + peer.id + '    ' + requiredOpts.peerId.toString('hex')) // 85.10.239.191:48623\r\n//             if (knownPeers.has(peer.id)) {\r\n//                 return;\r\n//             }\r\n//             knownPeers.add(peer.id);\r\n//             peer.once('connect', () => {\r\n//                 connect$.next(peer);\r\n//             });\r\n//             peer.on('data', (data: Buffer) => {\r\n//                 console.log('# GOT DATA FROM PEER:');\r\n//                 const messageOrResponse = JSON.parse(data as any);\r\n//                 console.dir(messageOrResponse);\r\n//                 if (messageOrResponse.result) {\r\n//                     response$.next({\r\n//                         peer: peer as any,\r\n//                         response: messageOrResponse\r\n//                     });\r\n//                 } else {\r\n//                     message$.next({\r\n//                         peer,\r\n//                         message: JSON.parse(data)\r\n//                     });\r\n//                 }\r\n//             });\r\n//             peer.on('signal', (signal) => {\r\n//                 console.log('GOT SIGNAL: ' + requiredOpts.peerId.toString('hex'));\r\n//                 console.dir(signal);\r\n//                 client.signal(signal);\r\n//                 client.update();\r\n//                 client.scrape();\r\n//             });\r\n//         });\r\n\r\n//         client.on('scrape', function (data) {\r\n//             console.log('number of leechers in the swarm: ' + data.incomplete)\r\n//         })\r\n\r\n//         const handler: P2PConnectionHandler = {\r\n//             connect$,\r\n//             disconnect$,\r\n//             message$,\r\n//             response$,\r\n//             async send(peer: P2PPeer, message: P2PMessage) {\r\n//                 await peer.send(JSON.stringify(message));\r\n//             },\r\n//             close() {\r\n//                 client.close();\r\n//                 connect$.complete();\r\n//                 disconnect$.complete();\r\n//                 message$.complete();\r\n//                 response$.complete();\r\n//                 return PROMISE_RESOLVE_VOID;\r\n//             }\r\n//         }\r\n//         client.start();\r\n//         client.update();\r\n//         client.scrape();\r\n//         setInterval(() => {\r\n//             // client.update();\r\n//         }, 10000);\r\n//         return handler;\r\n//     };\r\n\r\n//     return creator;\r\n// }\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA","ignoreList":[]}