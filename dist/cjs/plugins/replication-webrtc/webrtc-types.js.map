{"version":3,"file":"webrtc-types.js","names":[],"sources":["../../../../src/plugins/replication-webrtc/webrtc-types.ts"],"sourcesContent":["import { Observable, Subscription } from 'rxjs';\r\nimport type {\r\n    MaybePromise,\r\n    ReplicationOptions,\r\n    ReplicationPullOptions,\r\n    ReplicationPushOptions,\r\n    RxError,\r\n    RxReplicationHandler,\r\n    RxStorageDefaultCheckpoint,\r\n    RxTypeError,\r\n    StringKeys\r\n} from '../../types/index.d.ts';\r\nimport { RxReplicationState } from '../replication/index.ts';\r\nimport { WebsocketMessageResponseType, WebsocketMessageType } from '../replication-websocket/index.ts';\r\n\r\nexport type WebRTCReplicationCheckpoint = RxStorageDefaultCheckpoint;\r\n\r\n\r\nexport type WebRTCMessage = Omit<WebsocketMessageType, 'method' | 'collection'> & {\r\n    method: StringKeys<RxReplicationHandler<any, any>> | 'token';\r\n};\r\nexport type WebRTCResponse = Omit<WebsocketMessageResponseType, 'collection'>;\r\nexport type PeerWithMessage<PeerType> = {\r\n    peer: PeerType;\r\n    message: WebRTCMessage;\r\n};\r\nexport type PeerWithResponse<PeerType> = {\r\n    peer: PeerType;\r\n    response: WebRTCResponse;\r\n};\r\n\r\nexport type WebRTCConnectionHandler<PeerType> = {\r\n    connect$: Observable<PeerType>;\r\n    disconnect$: Observable<PeerType>;\r\n    message$: Observable<PeerWithMessage<PeerType>>;\r\n    response$: Observable<PeerWithResponse<PeerType>>;\r\n    error$: Observable<RxError | RxTypeError>;\r\n    send(peer: PeerType, message: WebRTCMessage | WebRTCResponse): Promise<void>;\r\n    close(): Promise<void>;\r\n};\r\n\r\nexport type WebRTCConnectionHandlerCreator<PeerType> = (\r\n    opts: SyncOptionsWebRTC<any, PeerType>\r\n) => Promise<WebRTCConnectionHandler<PeerType>>;\r\n\r\nexport type WebRTCSyncPushOptions<RxDocType> = Omit<\r\n    ReplicationPushOptions<RxDocType>,\r\n    'handler'\r\n> & {};\r\n\r\nexport type WebRTCSyncPullOptions<RxDocType> = Omit<\r\n    ReplicationPullOptions<RxDocType, WebRTCReplicationCheckpoint>,\r\n    'handler' | 'stream$'\r\n> & {};\r\n\r\nexport type SyncOptionsWebRTC<RxDocType, PeerType> = Omit<\r\n    ReplicationOptions<RxDocType, WebRTCReplicationCheckpoint>,\r\n    'pull' |\r\n    'push' |\r\n    'replicationIdentifier' |\r\n    'deletedField' |\r\n    'live' |\r\n    'autostart' |\r\n    'waitForLeadership'\r\n> & {\r\n    /**\r\n     * It will only replicate with other instances\r\n     * that use the same topic.\r\n     */\r\n    topic: string;\r\n    connectionHandlerCreator: WebRTCConnectionHandlerCreator<PeerType>;\r\n    /**\r\n     * Run on new peers so that bad peers can be blocked.\r\n     * If returns true, the peer is valid and it will replicate.\r\n     * If returns false, it will drop the peer.\r\n     */\r\n    isPeerValid?: (peer: PeerType) => MaybePromise<boolean>;\r\n    pull?: WebRTCSyncPullOptions<RxDocType>;\r\n    push?: WebRTCSyncPushOptions<RxDocType>;\r\n};\r\n\r\nexport type RxWebRTCReplicationState<RxDocType> = RxReplicationState<RxDocType, WebRTCReplicationCheckpoint>;\r\n\r\n\r\nexport type WebRTCPeerState<RxDocType, PeerType> = {\r\n    peer: PeerType;\r\n    // only exists when the peer was picked as master and the own client was picked as fork.\r\n    replicationState?: RxWebRTCReplicationState<RxDocType>;\r\n    // clean this up when removing the peer\r\n    subs: Subscription[];\r\n};\r\n"],"mappings":"","ignoreList":[]}