{"version":3,"file":"index.js","names":["path","_interopRequireWildcard","require","_rxjs","_index","_fileUtil","Object","keys","forEach","key","prototype","hasOwnProperty","call","_exportNames","exports","defineProperty","enumerable","get","_rxStorageHelper","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","n","__proto__","a","getOwnPropertyDescriptor","u","i","set","backupSingleDocument","rxDocument","options","data","toJSON","writtenFiles","docFolder","documentFolder","primary","clearFolder","fileLocation","join","writeJsonToFile","push","attachments","attachmentsFolder","ensureFolderExists","allAttachments","Promise","all","map","attachment","content","getData","attachmentFileLocation","id","writeToFile","BACKUP_STATES_BY_DB","addToBackupStates","db","state","ar","getFromMapOrCreate","RxBackupState","database","isStopped","subs","persistRunning","PROMISE_RESOLVE_VOID","initialReplicationDone$","BehaviorSubject","internalWriteEvents$","Subject","writeEvents$","asObservable","batchSize","prepareFolders","_proto","persistOnce","then","_persistOnce","_this","meta","getMeta","entries","collections","collectionName","collection","primaryKey","schema","primaryPath","processedDocuments","Set","requestIdlePromise","collectionStates","lastCheckpoint","checkpoint","hasMore","_loop","changesResult","getChangedDocumentsSince","storageInstance","documents","length","docIds","doc","filter","add","elem","pos","arr","indexOf","docs","findByIds","exec","size","Array","from","values","next","name","documentId","files","deleted","docId","deleteFolder","setMeta","getValue","watchForChanges","changes$","changeStream","sub","subscribe","awaitInitialBackup","firstValueFrom","pipe","v","cancel","PROMISE_RESOLVE_FALSE","unsubscribe","PROMISE_RESOLVE_TRUE","backup","backupState","live","RxDBBackupPlugin","rxdb","prototypes","RxDatabase","proto","hooks","preCloseRxDatabase","after","states"],"sources":["../../../../src/plugins/backup/index.ts"],"sourcesContent":["import * as path from 'node:path';\r\nimport {\r\n    BehaviorSubject,\r\n    firstValueFrom,\r\n    Observable,\r\n    Subject,\r\n    Subscription\r\n} from 'rxjs';\r\nimport {\r\n    filter,\r\n    map\r\n} from 'rxjs';\r\nimport type {\r\n    BackupOptions,\r\n    RxBackupWriteEvent,\r\n    RxCollection,\r\n    RxDatabase,\r\n    RxDocument,\r\n    RxPlugin\r\n} from '../../types/index.d.ts';\r\nimport {\r\n    getFromMapOrCreate,\r\n    PROMISE_RESOLVE_FALSE,\r\n    PROMISE_RESOLVE_TRUE,\r\n    PROMISE_RESOLVE_VOID\r\n} from '../../plugins/utils/index.ts';\r\nimport {\r\n    clearFolder,\r\n    deleteFolder,\r\n    documentFolder,\r\n    ensureFolderExists,\r\n    getMeta,\r\n    prepareFolders,\r\n    setMeta,\r\n    writeJsonToFile,\r\n    writeToFile\r\n} from './file-util.ts';\r\nimport { getChangedDocumentsSince } from '../../rx-storage-helper.ts';\r\n\r\n\r\n/**\r\n * Backups a single documents,\r\n * returns the paths to all written files\r\n */\r\nexport async function backupSingleDocument(\r\n    rxDocument: RxDocument<any, any>,\r\n    options: BackupOptions\r\n): Promise<string[]> {\r\n    const data = rxDocument.toJSON(true);\r\n    const writtenFiles: string[] = [];\r\n\r\n    const docFolder = documentFolder(options, rxDocument.primary);\r\n    await clearFolder(docFolder);\r\n\r\n    const fileLocation = path.join(\r\n        docFolder,\r\n        'document.json'\r\n    );\r\n    await writeJsonToFile(fileLocation, data);\r\n    writtenFiles.push(fileLocation);\r\n\r\n    if (options.attachments) {\r\n        const attachmentsFolder = path.join(\r\n            docFolder,\r\n            'attachments'\r\n        );\r\n        ensureFolderExists(attachmentsFolder);\r\n        const attachments = (rxDocument as RxDocument).allAttachments();\r\n        await Promise.all(\r\n            attachments\r\n                .map(async (attachment) => {\r\n                    const content = await attachment.getData();\r\n                    const attachmentFileLocation = path.join(\r\n                        attachmentsFolder,\r\n                        attachment.id\r\n                    );\r\n                    await writeToFile(attachmentFileLocation, content);\r\n                    writtenFiles.push(attachmentFileLocation);\r\n                })\r\n        );\r\n    }\r\n\r\n    return writtenFiles;\r\n}\r\n\r\nconst BACKUP_STATES_BY_DB: WeakMap<RxDatabase, RxBackupState[]> = new WeakMap();\r\nfunction addToBackupStates(db: RxDatabase, state: RxBackupState) {\r\n    const ar = getFromMapOrCreate(\r\n        BACKUP_STATES_BY_DB,\r\n        db,\r\n        () => []\r\n    );\r\n    ar.push(state);\r\n}\r\n\r\nexport class RxBackupState {\r\n    public isStopped: boolean = false;\r\n    private subs: Subscription[] = [];\r\n    private persistRunning: Promise<void> = PROMISE_RESOLVE_VOID;\r\n    private initialReplicationDone$: BehaviorSubject<boolean> = new BehaviorSubject(false as any);\r\n\r\n    private readonly internalWriteEvents$: Subject<RxBackupWriteEvent> = new Subject();\r\n    public readonly writeEvents$: Observable<RxBackupWriteEvent> = this.internalWriteEvents$.asObservable();\r\n\r\n    constructor(\r\n        public readonly database: RxDatabase,\r\n        public readonly options: BackupOptions\r\n    ) {\r\n        if (!this.options.batchSize) {\r\n            this.options.batchSize = 10;\r\n        }\r\n        addToBackupStates(database, this);\r\n        prepareFolders(database, options);\r\n    }\r\n\r\n    /**\r\n     * Persists all data from all collections,\r\n     * beginning from the oldest sequence checkpoint\r\n     * to the newest one.\r\n     * Do not call this while it is already running.\r\n     * Returns true if there are more documents to process\r\n     */\r\n    public persistOnce() {\r\n        return this.persistRunning = this.persistRunning.then(() => this._persistOnce());\r\n    }\r\n\r\n    public async _persistOnce() {\r\n        const meta = await getMeta(this.options);\r\n\r\n        await Promise.all(\r\n            Object\r\n                .entries(this.database.collections)\r\n                .map(async ([collectionName, collection]) => {\r\n                    const primaryKey = collection.schema.primaryPath;\r\n                    const processedDocuments: Set<string> = new Set();\r\n\r\n                    await this.database.requestIdlePromise();\r\n\r\n                    if (!meta.collectionStates[collectionName]) {\r\n                        meta.collectionStates[collectionName] = {};\r\n                    }\r\n                    let lastCheckpoint = meta.collectionStates[collectionName].checkpoint;\r\n\r\n                    let hasMore = true;\r\n                    while (hasMore && !this.isStopped) {\r\n                        await this.database.requestIdlePromise();\r\n                        const changesResult = await getChangedDocumentsSince(\r\n                            collection.storageInstance,\r\n                            this.options.batchSize ? this.options.batchSize : 0,\r\n                            lastCheckpoint\r\n                        );\r\n                        lastCheckpoint = changesResult.documents.length > 0 ? changesResult.checkpoint : lastCheckpoint;\r\n                        meta.collectionStates[collectionName].checkpoint = lastCheckpoint;\r\n\r\n                        const docIds: string[] = changesResult.documents\r\n                            .map(doc => doc[primaryKey])\r\n                            .filter(id => {\r\n                                if (\r\n                                    processedDocuments.has(id)\r\n                                ) {\r\n                                    return false;\r\n                                } else {\r\n                                    processedDocuments.add(id);\r\n                                    return true;\r\n                                }\r\n                            })\r\n                            .filter((elem, pos, arr) => arr.indexOf(elem) === pos); // unique\r\n                        await this.database.requestIdlePromise();\r\n\r\n                        const docs: Map<string, RxDocument> = await collection.findByIds(docIds).exec();\r\n                        if (docs.size === 0) {\r\n                            hasMore = false;\r\n                            continue;\r\n                        }\r\n                        await Promise.all(\r\n                            Array\r\n                                .from(docs.values())\r\n                                .map(async (doc) => {\r\n                                    const writtenFiles = await backupSingleDocument(doc, this.options);\r\n                                    this.internalWriteEvents$.next({\r\n                                        collectionName: collection.name,\r\n                                        documentId: doc.primary,\r\n                                        files: writtenFiles,\r\n                                        deleted: false\r\n                                    });\r\n                                })\r\n                        );\r\n                        // handle deleted documents\r\n                        await Promise.all(\r\n                            docIds\r\n                                .filter(docId => !docs.has(docId))\r\n                                .map(async (docId) => {\r\n                                    await deleteFolder(documentFolder(this.options, docId));\r\n                                    this.internalWriteEvents$.next({\r\n                                        collectionName: collection.name,\r\n                                        documentId: docId,\r\n                                        files: [],\r\n                                        deleted: true\r\n                                    });\r\n                                })\r\n                        );\r\n                    }\r\n                    meta.collectionStates[collectionName].checkpoint = lastCheckpoint;\r\n                    await setMeta(this.options, meta);\r\n                })\r\n        );\r\n\r\n        if (!this.initialReplicationDone$.getValue()) {\r\n            this.initialReplicationDone$.next(true);\r\n        }\r\n    }\r\n\r\n    public watchForChanges() {\r\n        const collections: RxCollection[] = Object.values(this.database.collections);\r\n        collections.forEach(collection => {\r\n            const changes$ = collection.storageInstance.changeStream();\r\n            const sub = changes$.subscribe(() => {\r\n                this.persistOnce();\r\n            });\r\n            this.subs.push(sub);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when the initial backup is done\r\n     * and the filesystem is in sync with the database state\r\n     */\r\n    public awaitInitialBackup(): Promise<boolean> {\r\n        return firstValueFrom(\r\n            this.initialReplicationDone$.pipe(\r\n                filter(v => !!v),\r\n                map(() => true)\r\n            )\r\n        );\r\n    }\r\n\r\n    cancel(): Promise<boolean> {\r\n        if (this.isStopped) {\r\n            return PROMISE_RESOLVE_FALSE;\r\n        }\r\n        this.isStopped = true;\r\n        this.subs.forEach(sub => sub.unsubscribe());\r\n        return PROMISE_RESOLVE_TRUE;\r\n    }\r\n}\r\n\r\n\r\nexport function backup(\r\n    this: RxDatabase,\r\n    options: BackupOptions\r\n): RxBackupState {\r\n    const backupState = new RxBackupState(this, options);\r\n    backupState.persistOnce();\r\n\r\n    if (options.live) {\r\n        backupState.watchForChanges();\r\n    }\r\n\r\n    return backupState;\r\n}\r\n\r\nexport * from './file-util.ts';\r\nexport const RxDBBackupPlugin: RxPlugin = {\r\n    name: 'backup',\r\n    rxdb: true,\r\n    prototypes: {\r\n        RxDatabase(proto: any) {\r\n            proto.backup = backup;\r\n        }\r\n    },\r\n    hooks: {\r\n        preCloseRxDatabase: {\r\n            after: function preCloseRxDatabase(db: RxDatabase) {\r\n                const states = BACKUP_STATES_BY_DB.get(db);\r\n                if (states) {\r\n                    states.forEach(state => state.cancel());\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n"],"mappings":"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","ignoreList":[]}