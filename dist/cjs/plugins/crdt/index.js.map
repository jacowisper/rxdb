{"version":3,"file":"index.js","names":["_rxError","require","_index","_index2","_mingoUpdater","updateCRDT","entry","overwritable","deepFreezeWhenDevMode","jsonSchema","collection","schema","crdt","newRxError","queryObj","crdtOptions","ensureNotFalsy","storageToken","database","incrementalModify","docData","crdtDocField","clone","getProperty","field","operation","body","toArray","creator","time","now","lastAr","operations","push","hash","hashCRDTOperations","hashFunction","runOperationOnDocument","setProperty","RX_CRDT_CONTEXT","insertCRDT","Array","isArray","insertData","result","insert","catch","err","code","doc","findOne","parameters","id","exec","sortOperationComparator","a","b","entryParts","forEach","entryPart","isMatching","selector","query","sort","skip","matcher","getQueryMatcher","ifMatch","mingoUpdater","ifNotMatch","crdts","hashObj","map","op","JSON","stringify","getCRDTSchemaPart","operationSchema","type","properties","items","additionalProperties","minItems","minimum","maximum","multipleOf","required","minLength","mergeCRDTFields","crdtsA","crdtsB","length","ret","row","index","mergedOps","ids","Set","add","has","rebuildFromCRDT","base","_deleted","getCRDTConflictHandler","crdtField","getCRDTValue","objectPathMonad","conflictHandler","isEqual","ctx","resolve","i","newDocCrdt","newDocumentState","masterDocCrdt","realMasterState","mergedCrdt","mergedDoc","exports","RxDBcrdtPlugin","name","rxdb","prototypes","RxDocument","proto","oldRemove","remove","bind","$set","oldincrementalPatch","incrementalPatch","patch","oldincrementalModify","fn","context","primary","args","RxCollection","hooks","preCreateRxCollection","after","data","createRxCollection","getCrdt","isDevMode","bulkWriteBefore","storageInstance","bulkWrite","writes","Promise","all","write","newDocState","document","rebuild","docWithoutMeta","Object","entries","k","v","startsWith","deepEqual","recalculatedHash","bulkInsertBefore","bulkInsert","docsData","useDocsData","setMe","key","value","crdtOperations"],"sources":["../../../../src/plugins/crdt/index.ts"],"sourcesContent":["import { newRxError } from '../../rx-error.ts';\r\nimport type {\r\n    CRDTDocumentField,\r\n    CRDTEntry,\r\n    CRDTOperation,\r\n    FilledMangoQuery,\r\n    HashFunction,\r\n    JsonSchema,\r\n    RxConflictHandler,\r\n    RxConflictHandlerInput,\r\n    RxDocument,\r\n    RxDocumentData,\r\n    RxJsonSchema,\r\n    RxPlugin,\r\n    WithDeleted\r\n} from '../../types/index.d.ts';\r\nimport {\r\n    clone,\r\n    deepEqual,\r\n    ensureNotFalsy,\r\n    getProperty,\r\n    now,\r\n    objectPathMonad,\r\n    setProperty,\r\n    toArray\r\n} from '../../plugins/utils/index.ts';\r\nimport {\r\n    getQueryMatcher,\r\n    overwritable,\r\n    RxCollection,\r\n    RxDocumentWriteData,\r\n    RxError\r\n} from '../../index.ts';\r\nimport { mingoUpdater } from '../update/mingo-updater.ts';\r\n\r\n\r\n\r\nexport async function updateCRDT<RxDocType>(\r\n    this: RxDocument<RxDocType>,\r\n    entry: CRDTEntry<RxDocType> | CRDTEntry<RxDocType>[]\r\n) {\r\n    entry = overwritable.deepFreezeWhenDevMode(entry) as any;\r\n\r\n    const jsonSchema = this.collection.schema.jsonSchema;\r\n    if (!jsonSchema.crdt) {\r\n        throw newRxError('CRDT1', {\r\n            schema: jsonSchema,\r\n            queryObj: entry\r\n        });\r\n    }\r\n    const crdtOptions = ensureNotFalsy(jsonSchema.crdt);\r\n    const storageToken = await this.collection.database.storageToken;\r\n\r\n    return this.incrementalModify(async (docData) => {\r\n        const crdtDocField: CRDTDocumentField<RxDocType> = clone(getProperty(docData as any, crdtOptions.field));\r\n        const operation: CRDTOperation<RxDocType> = {\r\n            body: toArray(entry),\r\n            creator: storageToken,\r\n            time: now()\r\n        };\r\n\r\n        /**\r\n         * A new write will ALWAYS be an operation in the last\r\n         * array which was non existing before.\r\n         */\r\n        const lastAr: CRDTOperation<RxDocType>[] = [operation];\r\n        crdtDocField.operations.push(lastAr);\r\n        crdtDocField.hash = await hashCRDTOperations(this.collection.database.hashFunction, crdtDocField);\r\n\r\n        docData = runOperationOnDocument(\r\n            this.collection.schema.jsonSchema,\r\n            docData,\r\n            operation\r\n        );\r\n        setProperty(docData, crdtOptions.field, crdtDocField);\r\n        return docData;\r\n    }, RX_CRDT_CONTEXT);\r\n}\r\n\r\n\r\nexport async function insertCRDT<RxDocType>(\r\n    this: RxCollection<RxDocType>,\r\n    entry: CRDTEntry<RxDocType> | CRDTEntry<RxDocType>[]\r\n) {\r\n    entry = overwritable.deepFreezeWhenDevMode(entry) as any;\r\n\r\n    const jsonSchema = this.schema.jsonSchema;\r\n    if (!jsonSchema.crdt) {\r\n        throw newRxError('CRDT1', {\r\n            schema: jsonSchema,\r\n            queryObj: entry\r\n        });\r\n    }\r\n    const crdtOptions = ensureNotFalsy(jsonSchema.crdt);\r\n    const storageToken = await this.database.storageToken;\r\n    const operation: CRDTOperation<RxDocType> = {\r\n        body: Array.isArray(entry) ? entry : [entry],\r\n        creator: storageToken,\r\n        time: now()\r\n    };\r\n\r\n    let insertData: RxDocumentWriteData<RxDocType> = {} as any;\r\n    insertData = runOperationOnDocument(\r\n        this.schema.jsonSchema,\r\n        insertData as any,\r\n        operation\r\n    ) as any;\r\n    const crdtDocField: CRDTDocumentField<RxDocType> = {\r\n        operations: [],\r\n        hash: ''\r\n    };\r\n    setProperty(insertData as any, crdtOptions.field, crdtDocField);\r\n\r\n    const lastAr: CRDTOperation<RxDocType>[] = [operation];\r\n    crdtDocField.operations.push(lastAr);\r\n    crdtDocField.hash = await hashCRDTOperations(this.database.hashFunction, crdtDocField);\r\n\r\n    const result = await this.insert(insertData).catch(async (err: RxError) => {\r\n        if (err.code === 'CONFLICT') {\r\n            // was a conflict, update document instead of inserting\r\n            const doc = await this.findOne(err.parameters.id).exec(true);\r\n            return doc.updateCRDT(entry);\r\n        } else {\r\n            throw err;\r\n        }\r\n    });\r\n    return result;\r\n}\r\n\r\n\r\nexport function sortOperationComparator<RxDocType>(a: CRDTOperation<RxDocType>, b: CRDTOperation<RxDocType>) {\r\n    return a.creator > b.creator ? 1 : -1;\r\n}\r\n\r\n\r\nfunction runOperationOnDocument<RxDocType>(\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    docData: WithDeleted<RxDocType>,\r\n    operation: CRDTOperation<RxDocType>\r\n): WithDeleted<RxDocType> {\r\n    const entryParts = operation.body;\r\n    entryParts.forEach(entryPart => {\r\n        let isMatching: boolean;\r\n        if (entryPart.selector) {\r\n            const query: FilledMangoQuery<RxDocType> = {\r\n                selector: ensureNotFalsy(entryPart.selector as any),\r\n                sort: [],\r\n                skip: 0\r\n            };\r\n            const matcher = getQueryMatcher(schema, query);\r\n            isMatching = matcher(docData as any);\r\n        } else {\r\n            isMatching = true;\r\n        }\r\n        if (isMatching) {\r\n            if (entryPart.ifMatch) {\r\n                docData = mingoUpdater<WithDeleted<RxDocType>>(docData, entryPart.ifMatch);\r\n            }\r\n        } else {\r\n            if (entryPart.ifNotMatch) {\r\n                docData = mingoUpdater<WithDeleted<RxDocType>>(docData, entryPart.ifNotMatch);\r\n            }\r\n        }\r\n    });\r\n    return docData;\r\n}\r\n\r\nexport async function hashCRDTOperations(\r\n    hashFunction: HashFunction,\r\n    crdts: CRDTDocumentField<any>\r\n): Promise<string> {\r\n    const hashObj = crdts.operations.map((operations) => {\r\n        return operations.map(op => op.creator);\r\n    });\r\n    const hash = await hashFunction(JSON.stringify(hashObj));\r\n    return hash;\r\n}\r\n\r\nexport function getCRDTSchemaPart<RxDocType>(): JsonSchema<CRDTDocumentField<RxDocType>> {\r\n    const operationSchema: JsonSchema<CRDTOperation<RxDocType>> = {\r\n        type: 'object',\r\n        properties: {\r\n            body: {\r\n                type: 'array',\r\n                items: {\r\n                    type: 'object',\r\n                    properties: {\r\n                        selector: {\r\n                            type: 'object'\r\n                        },\r\n                        ifMatch: {\r\n                            type: 'object'\r\n                        },\r\n                        ifNotMatch: {\r\n                            type: 'object'\r\n                        }\r\n                    },\r\n                    additionalProperties: false\r\n                },\r\n                minItems: 1\r\n            },\r\n            creator: {\r\n                type: 'string'\r\n            },\r\n            time: {\r\n                type: 'number',\r\n                minimum: 1,\r\n                maximum: 1000000000000000,\r\n                multipleOf: 0.01\r\n            }\r\n        },\r\n        additionalProperties: false,\r\n        required: [\r\n            'body',\r\n            'creator',\r\n            'time'\r\n        ]\r\n    };\r\n    return {\r\n        type: 'object',\r\n        properties: {\r\n            operations: {\r\n                type: 'array',\r\n                items: {\r\n                    type: 'array',\r\n                    items: operationSchema\r\n                }\r\n            },\r\n            hash: {\r\n                type: 'string',\r\n                // set a minLength to not accidentally store an empty string\r\n                minLength: 2\r\n            }\r\n        },\r\n        additionalProperties: false,\r\n        required: ['operations', 'hash']\r\n    };\r\n}\r\n\r\n\r\nexport async function mergeCRDTFields<RxDocType>(\r\n    hashFunction: HashFunction,\r\n    crdtsA: CRDTDocumentField<RxDocType>,\r\n    crdtsB: CRDTDocumentField<RxDocType>\r\n): Promise<CRDTDocumentField<RxDocType>> {\r\n\r\n    // the value with most operations must be A to\r\n    // ensure we not miss out rows when iterating over both fields.\r\n    if (crdtsA.operations.length < crdtsB.operations.length) {\r\n        [crdtsA, crdtsB] = [crdtsB, crdtsA];\r\n    }\r\n\r\n    const ret: CRDTDocumentField<RxDocType> = {\r\n        operations: [],\r\n        hash: ''\r\n    };\r\n    crdtsA.operations.forEach((row, index) => {\r\n        let mergedOps: CRDTOperation<RxDocType>[] = [];\r\n        const ids = new Set<string>(); // used to deduplicate\r\n\r\n        row.forEach(op => {\r\n            ids.add(op.creator);\r\n            mergedOps.push(op);\r\n        });\r\n        if (crdtsB.operations[index]) {\r\n            crdtsB.operations[index].forEach(op => {\r\n                if (!ids.has(op.creator)) {\r\n                    mergedOps.push(op);\r\n                }\r\n            });\r\n        }\r\n        mergedOps = mergedOps.sort(sortOperationComparator);\r\n        ret.operations[index] = mergedOps;\r\n    });\r\n\r\n\r\n    ret.hash = await hashCRDTOperations(hashFunction, ret);\r\n    return ret;\r\n}\r\n\r\nexport function rebuildFromCRDT<RxDocType>(\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    docData: WithDeleted<RxDocType> | RxDocType,\r\n    crdts: CRDTDocumentField<RxDocType>\r\n): WithDeleted<RxDocType> {\r\n    let base: WithDeleted<RxDocType> = {\r\n        _deleted: false\r\n    } as any;\r\n    setProperty(base, ensureNotFalsy(schema.crdt).field, crdts);\r\n    crdts.operations.forEach(operations => {\r\n        operations.forEach(op => {\r\n            base = runOperationOnDocument(\r\n                schema,\r\n                base,\r\n                op\r\n            );\r\n        });\r\n    });\r\n    return base;\r\n}\r\n\r\n\r\nexport function getCRDTConflictHandler<RxDocType>(\r\n    hashFunction: HashFunction,\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>\r\n): RxConflictHandler<RxDocType> {\r\n    const crdtOptions = ensureNotFalsy(schema.crdt);\r\n    const crdtField = crdtOptions.field;\r\n    const getCRDTValue = objectPathMonad<WithDeleted<RxDocType> | RxDocType, CRDTDocumentField<RxDocType>>(crdtField);\r\n\r\n    const conflictHandler: RxConflictHandler<RxDocType> = {\r\n        isEqual(a, b, ctx) {\r\n            return getCRDTValue(a).hash === getCRDTValue(b).hash;\r\n        },\r\n        async resolve(i) {\r\n            const newDocCrdt = getCRDTValue(i.newDocumentState);\r\n            const masterDocCrdt = getCRDTValue(i.realMasterState);\r\n            const mergedCrdt = await mergeCRDTFields(hashFunction, newDocCrdt, masterDocCrdt);\r\n            const mergedDoc = rebuildFromCRDT(\r\n                schema,\r\n                i.newDocumentState,\r\n                mergedCrdt\r\n            );\r\n            return mergedDoc;\r\n        }\r\n    }\r\n    return conflictHandler;\r\n}\r\n\r\n\r\nexport const RX_CRDT_CONTEXT = 'rx-crdt';\r\n\r\nexport const RxDBcrdtPlugin: RxPlugin = {\r\n    name: 'crdt',\r\n    rxdb: true,\r\n    prototypes: {\r\n        RxDocument: (proto: any) => {\r\n            proto.updateCRDT = updateCRDT;\r\n\r\n            const oldRemove = proto.remove;\r\n            proto.remove = function (this: RxDocument) {\r\n                if (!this.collection.schema.jsonSchema.crdt) {\r\n                    return oldRemove.bind(this)();\r\n                }\r\n                return this.updateCRDT({\r\n                    ifMatch: {\r\n                        $set: {\r\n                            _deleted: true\r\n                        }\r\n                    }\r\n                });\r\n            };\r\n\r\n            const oldincrementalPatch = proto.incrementalPatch;\r\n            proto.incrementalPatch = function (this: RxDocument, patch: any) {\r\n                if (!this.collection.schema.jsonSchema.crdt) {\r\n                    return oldincrementalPatch.bind(this)(patch);\r\n                }\r\n                return this.updateCRDT({\r\n                    ifMatch: {\r\n                        $set: patch\r\n                    }\r\n                });\r\n            };\r\n            const oldincrementalModify = proto.incrementalModify;\r\n            proto.incrementalModify = function (fn: any, context: string) {\r\n                if (!this.collection.schema.jsonSchema.crdt) {\r\n                    return oldincrementalModify.bind(this)(fn);\r\n                }\r\n                if (context === RX_CRDT_CONTEXT) {\r\n                    return oldincrementalModify.bind(this)(fn);\r\n                } else {\r\n                    throw newRxError('CRDT2', {\r\n                        id: this.primary,\r\n                        args: { context }\r\n                    });\r\n                }\r\n            };\r\n        },\r\n        RxCollection: (proto: any) => {\r\n            proto.insertCRDT = insertCRDT;\r\n        }\r\n    },\r\n    overwritable: {},\r\n    hooks: {\r\n        preCreateRxCollection: {\r\n            after: (data) => {\r\n                if (!data.schema.crdt) {\r\n                    return;\r\n                }\r\n                if (data.conflictHandler) {\r\n                    throw newRxError('CRDT3', {\r\n                        collection: data.name,\r\n                        schema: data.schema\r\n                    });\r\n                }\r\n                data.conflictHandler = getCRDTConflictHandler(\r\n                    data.database.hashFunction,\r\n                    data.schema\r\n                );\r\n            }\r\n        },\r\n        createRxCollection: {\r\n            after: ({ collection }) => {\r\n                if (!collection.schema.jsonSchema.crdt) {\r\n                    return;\r\n                }\r\n\r\n                const crdtOptions = ensureNotFalsy(collection.schema.jsonSchema.crdt);\r\n                const crdtField = crdtOptions.field;\r\n                const getCrdt = objectPathMonad<any, CRDTDocumentField<any>>(crdtOptions.field);\r\n\r\n                /**\r\n                 * In dev-mode we have to ensure that all document writes\r\n                 * have the correct crdt state so that nothing is missed out\r\n                 * or could accidentally do non-crdt writes to the document.\r\n                 */\r\n                if (overwritable.isDevMode()) {\r\n                    const bulkWriteBefore = collection.storageInstance.bulkWrite.bind(collection.storageInstance);\r\n                    collection.storageInstance.bulkWrite = async function (writes, context) {\r\n\r\n                        await Promise.all(\r\n                            writes.map(async (write) => {\r\n                                const newDocState: typeof write.document = clone(write.document);\r\n                                const crdts = getCrdt(newDocState);\r\n\r\n                                const rebuild = rebuildFromCRDT(\r\n                                    collection.schema.jsonSchema,\r\n                                    newDocState,\r\n                                    crdts\r\n                                );\r\n\r\n                                function docWithoutMeta(doc: any) {\r\n                                    const ret: any = {};\r\n                                    Object.entries(doc).forEach(([k, v]) => {\r\n                                        if (\r\n                                            !k.startsWith('_') &&\r\n                                            typeof v !== 'undefined'\r\n                                        ) {\r\n                                            ret[k] = v;\r\n                                        }\r\n                                    });\r\n                                    return ret;\r\n                                }\r\n                                if (!deepEqual(docWithoutMeta(newDocState), docWithoutMeta(rebuild))) {\r\n                                    throw newRxError('SNH', {\r\n                                        document: newDocState\r\n                                    });\r\n                                }\r\n                                const recalculatedHash = await hashCRDTOperations(collection.database.hashFunction, crdts);\r\n                                if (crdts.hash !== recalculatedHash) {\r\n                                    throw newRxError('SNH', {\r\n                                        document: newDocState,\r\n                                        args: { hash: crdts.hash, recalculatedHash }\r\n                                    });\r\n                                }\r\n                            })\r\n                        );\r\n\r\n                        return bulkWriteBefore(writes, context);\r\n                    };\r\n                }\r\n\r\n\r\n                const bulkInsertBefore = collection.bulkInsert.bind(collection);\r\n                collection.bulkInsert = async function (docsData: any[]) {\r\n                    const storageToken = await collection.database.storageToken;\r\n                    const useDocsData = await Promise.all(\r\n                        docsData.map(async (docData) => {\r\n                            const setMe: Partial<RxDocumentData<any>> = {};\r\n                            Object.entries(docData).forEach(([key, value]) => {\r\n                                if (\r\n                                    !key.startsWith('_') &&\r\n                                    key !== crdtField\r\n                                ) {\r\n                                    setMe[key] = value;\r\n                                }\r\n                            });\r\n\r\n                            const crdtOperations: CRDTDocumentField<any> = {\r\n                                operations: [\r\n                                    [{\r\n                                        creator: storageToken,\r\n                                        body: [{\r\n                                            ifMatch: {\r\n                                                $set: setMe\r\n                                            }\r\n                                        }],\r\n                                        time: now()\r\n                                    }]\r\n                                ],\r\n                                hash: ''\r\n                            };\r\n                            crdtOperations.hash = await hashCRDTOperations(collection.database.hashFunction, crdtOperations);\r\n                            setProperty(docData, crdtOptions.field, crdtOperations);\r\n                            return docData;\r\n                        })\r\n                    );\r\n                    return bulkInsertBefore(useDocsData);\r\n                };\r\n            }\r\n        }\r\n    }\r\n};\r\n"],"mappings":"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","ignoreList":[]}