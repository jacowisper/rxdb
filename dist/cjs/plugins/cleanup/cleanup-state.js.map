{"version":3,"file":"cleanup-state.js","names":["_index","require","_index2","_cleanupHelper","_cleanup","_rxjs","RXSTATE_CLEANUP_QUEUE","PROMISE_RESOLVE_TRUE","startCleanupForRxState","state","rxCollection","collection","rxDatabase","database","cleanupPolicy","Object","assign","DEFAULT_CLEANUP_POLICY","initialCleanupWait","closed","cleanupRxState","runCleanupAfterWrite","isDone","awaitReplicationsInSync","replicationStates","REPLICATION_STATE_BY_COLLECTION","get","Promise","all","map","replicationState","isStopped","awaitInSync","then","requestIdlePromise","firstValueFrom","eventBulks$","catch","promiseWait","runEach"],"sources":["../../../../src/plugins/cleanup/cleanup-state.ts"],"sourcesContent":["import type { RxCleanupPolicy, RxState } from '../../types/index.d.ts';\r\nimport { PROMISE_RESOLVE_TRUE } from '../../plugins/utils/index.ts';\r\nimport { REPLICATION_STATE_BY_COLLECTION } from '../replication/index.ts';\r\nimport { DEFAULT_CLEANUP_POLICY } from './cleanup-helper.ts';\r\nimport { initialCleanupWait } from './cleanup.ts';\r\nimport { firstValueFrom } from 'rxjs';\r\n\r\nlet RXSTATE_CLEANUP_QUEUE: Promise<any> = PROMISE_RESOLVE_TRUE;\r\n\r\nexport async function startCleanupForRxState(state: RxState<unknown, unknown>) {\r\n    const rxCollection = state.collection;\r\n    const rxDatabase = rxCollection.database;\r\n    const cleanupPolicy = Object.assign(\r\n        {},\r\n        DEFAULT_CLEANUP_POLICY,\r\n        rxDatabase.cleanupPolicy ? rxDatabase.cleanupPolicy : {}\r\n    );\r\n\r\n    await initialCleanupWait(rxCollection, cleanupPolicy);\r\n    if (rxCollection.closed) {\r\n        return;\r\n    }\r\n\r\n    // initially cleanup the state\r\n    await cleanupRxState(state, cleanupPolicy);\r\n\r\n    /**\r\n     * Afterwards we listen to writes\r\n     * and only re-run the cleanup if there was a write\r\n     * to the state.\r\n     */\r\n    await runCleanupAfterWrite(state, cleanupPolicy);\r\n}\r\n/**\r\n * Runs the cleanup for a single RxState\r\n */\r\nexport async function cleanupRxState(\r\n    state: RxState<unknown, unknown>,\r\n    cleanupPolicy: RxCleanupPolicy\r\n) {\r\n    const rxCollection = state.collection;\r\n    const rxDatabase = rxCollection.database;\r\n\r\n    // run cleanup() until it returns true\r\n    let isDone = false;\r\n    while (!isDone && !rxCollection.closed) {\r\n        if (cleanupPolicy.awaitReplicationsInSync) {\r\n            const replicationStates = REPLICATION_STATE_BY_COLLECTION.get(rxCollection);\r\n            if (replicationStates) {\r\n                await Promise.all(\r\n                    replicationStates.map(replicationState => {\r\n                        if (!replicationState.isStopped()) {\r\n                            return replicationState.awaitInSync();\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n        }\r\n        if (rxCollection.closed) {\r\n            return;\r\n        }\r\n        RXSTATE_CLEANUP_QUEUE = RXSTATE_CLEANUP_QUEUE\r\n            .then(async () => {\r\n                if (rxCollection.closed) {\r\n                    return true;\r\n                }\r\n                await rxDatabase.requestIdlePromise();\r\n                return state._cleanup();\r\n            });\r\n        isDone = await RXSTATE_CLEANUP_QUEUE;\r\n    }\r\n}\r\n\r\nexport async function runCleanupAfterWrite(\r\n    state: RxState<unknown, unknown>,\r\n    cleanupPolicy: RxCleanupPolicy\r\n) {\r\n    const rxCollection = state.collection;\r\n    while (!rxCollection.closed) {\r\n        /**\r\n         * We only start the timer if there was actually a write\r\n         * to the collection. Otherwise the cleanup would\r\n         * just run on intervals even if nothing has changed.\r\n         */\r\n        await firstValueFrom(rxCollection.eventBulks$).catch(() => { });\r\n        await rxCollection.promiseWait(cleanupPolicy.runEach);\r\n        if (rxCollection.closed) {\r\n            return;\r\n        }\r\n        await cleanupRxState(state, cleanupPolicy);\r\n    }\r\n}\r\n"],"mappings":";;;;;;;;AACA,IAAAA,MAAA,GAAAC,OAAA;AACA,IAAAC,OAAA,GAAAD,OAAA;AACA,IAAAE,cAAA,GAAAF,OAAA;AACA,IAAAG,QAAA,GAAAH,OAAA;AACA,IAAAI,KAAA,GAAAJ,OAAA;AAEA,IAAIK,qBAAmC,GAAGC,2BAAoB;AAEvD,eAAeC,sBAAsBA,CAACC,KAAgC,EAAE;EAC3E,IAAMC,YAAY,GAAGD,KAAK,CAACE,UAAU;EACrC,IAAMC,UAAU,GAAGF,YAAY,CAACG,QAAQ;EACxC,IAAMC,aAAa,GAAGC,MAAM,CAACC,MAAM,CAC/B,CAAC,CAAC,EACFC,qCAAsB,EACtBL,UAAU,CAACE,aAAa,GAAGF,UAAU,CAACE,aAAa,GAAG,CAAC,CAC3D,CAAC;EAED,MAAM,IAAAI,2BAAkB,EAACR,YAAY,EAAEI,aAAa,CAAC;EACrD,IAAIJ,YAAY,CAACS,MAAM,EAAE;IACrB;EACJ;;EAEA;EACA,MAAMC,cAAc,CAACX,KAAK,EAAEK,aAAa,CAAC;;EAE1C;AACJ;AACA;AACA;AACA;EACI,MAAMO,oBAAoB,CAACZ,KAAK,EAAEK,aAAa,CAAC;AACpD;AACA;AACA;AACA;AACO,eAAeM,cAAcA,CAChCX,KAAgC,EAChCK,aAA8B,EAChC;EACE,IAAMJ,YAAY,GAAGD,KAAK,CAACE,UAAU;EACrC,IAAMC,UAAU,GAAGF,YAAY,CAACG,QAAQ;;EAExC;EACA,IAAIS,MAAM,GAAG,KAAK;EAClB,OAAO,CAACA,MAAM,IAAI,CAACZ,YAAY,CAACS,MAAM,EAAE;IACpC,IAAIL,aAAa,CAACS,uBAAuB,EAAE;MACvC,IAAMC,iBAAiB,GAAGC,uCAA+B,CAACC,GAAG,CAAChB,YAAY,CAAC;MAC3E,IAAIc,iBAAiB,EAAE;QACnB,MAAMG,OAAO,CAACC,GAAG,CACbJ,iBAAiB,CAACK,GAAG,CAACC,gBAAgB,IAAI;UACtC,IAAI,CAACA,gBAAgB,CAACC,SAAS,CAAC,CAAC,EAAE;YAC/B,OAAOD,gBAAgB,CAACE,WAAW,CAAC,CAAC;UACzC;QACJ,CAAC,CACL,CAAC;MACL;IACJ;IACA,IAAItB,YAAY,CAACS,MAAM,EAAE;MACrB;IACJ;IACAb,qBAAqB,GAAGA,qBAAqB,CACxC2B,IAAI,CAAC,YAAY;MACd,IAAIvB,YAAY,CAACS,MAAM,EAAE;QACrB,OAAO,IAAI;MACf;MACA,MAAMP,UAAU,CAACsB,kBAAkB,CAAC,CAAC;MACrC,OAAOzB,KAAK,CAACL,QAAQ,CAAC,CAAC;IAC3B,CAAC,CAAC;IACNkB,MAAM,GAAG,MAAMhB,qBAAqB;EACxC;AACJ;AAEO,eAAee,oBAAoBA,CACtCZ,KAAgC,EAChCK,aAA8B,EAChC;EACE,IAAMJ,YAAY,GAAGD,KAAK,CAACE,UAAU;EACrC,OAAO,CAACD,YAAY,CAACS,MAAM,EAAE;IACzB;AACR;AACA;AACA;AACA;IACQ,MAAM,IAAAgB,oBAAc,EAACzB,YAAY,CAAC0B,WAAW,CAAC,CAACC,KAAK,CAAC,MAAM,CAAE,CAAC,CAAC;IAC/D,MAAM3B,YAAY,CAAC4B,WAAW,CAACxB,aAAa,CAACyB,OAAO,CAAC;IACrD,IAAI7B,YAAY,CAACS,MAAM,EAAE;MACrB;IACJ;IACA,MAAMC,cAAc,CAACX,KAAK,EAAEK,aAAa,CAAC;EAC9C;AACJ","ignoreList":[]}