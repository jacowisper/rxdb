{"version":3,"file":"cleanup.js","names":["_index","require","_index2","_cleanupHelper","_hooks","_rxjs","RXSTORAGE_CLEANUP_QUEUE","PROMISE_RESOLVE_TRUE","startCleanupForRxCollection","rxCollection","rxDatabase","database","cleanupPolicy","Object","assign","DEFAULT_CLEANUP_POLICY","initialCleanupWait","closed","cleanupRxCollection","runCleanupAfterDelete","collection","promiseWait","minimumCollectionAge","waitForLeadership","storageInstance","isDone","awaitReplicationsInSync","replicationStates","REPLICATION_STATE_BY_COLLECTION","get","Promise","all","map","replicationState","isStopped","awaitInSync","then","requestIdlePromise","cleanup","minimumDeletedTime","runAsyncPluginHooks","collectionName","name","databaseName","firstValueFrom","eventBulks$","catch","runEach"],"sources":["../../../../src/plugins/cleanup/cleanup.ts"],"sourcesContent":["import type { RxCleanupPolicy, RxCollection } from '../../types/index.d.ts';\r\nimport { PROMISE_RESOLVE_TRUE } from '../../plugins/utils/index.ts';\r\nimport { REPLICATION_STATE_BY_COLLECTION } from '../replication/index.ts';\r\nimport { DEFAULT_CLEANUP_POLICY } from './cleanup-helper.ts';\r\nimport { runAsyncPluginHooks } from '../../hooks.ts';\r\nimport { filter, firstValueFrom } from 'rxjs';\r\n\r\n/**\r\n * Even on multiple databases,\r\n * the calls to RxStorage().cleanup()\r\n * must never run in parallel.\r\n * The cleanup is a background task which should\r\n * not affect the performance of other, more important tasks.\r\n */\r\nlet RXSTORAGE_CLEANUP_QUEUE: Promise<boolean> = PROMISE_RESOLVE_TRUE;\r\n\r\nexport async function startCleanupForRxCollection(\r\n    rxCollection: RxCollection\r\n) {\r\n    const rxDatabase = rxCollection.database;\r\n    const cleanupPolicy = Object.assign(\r\n        {},\r\n        DEFAULT_CLEANUP_POLICY,\r\n        rxDatabase.cleanupPolicy ? rxDatabase.cleanupPolicy : {}\r\n    );\r\n\r\n\r\n    await initialCleanupWait(rxCollection, cleanupPolicy);\r\n    if (rxCollection.closed) {\r\n        return;\r\n    }\r\n\r\n    // initially cleanup the collection\r\n    await cleanupRxCollection(rxCollection, cleanupPolicy);\r\n\r\n    /**\r\n     * Afterwards we listen to deletes\r\n     * and only re-run the cleanup after\r\n     * minimumDeletedTime is reached.\r\n     */\r\n    await runCleanupAfterDelete(rxCollection, cleanupPolicy);\r\n}\r\n\r\n\r\nexport async function initialCleanupWait(collection: RxCollection, cleanupPolicy: RxCleanupPolicy) {\r\n    /**\r\n     * Wait until minimumDatabaseInstanceAge is reached\r\n     * or collection is closed.\r\n     */\r\n    await collection.promiseWait(cleanupPolicy.minimumCollectionAge);\r\n    if (collection.closed) {\r\n        return;\r\n    }\r\n\r\n    if (cleanupPolicy.waitForLeadership) {\r\n        await collection.database.waitForLeadership();\r\n    }\r\n}\r\n\r\n/**\r\n * Runs the cleanup for a single RxCollection\r\n */\r\nexport async function cleanupRxCollection(\r\n    rxCollection: RxCollection,\r\n    cleanupPolicy: RxCleanupPolicy\r\n) {\r\n    const rxDatabase = rxCollection.database;\r\n    const storageInstance = rxCollection.storageInstance;\r\n\r\n    // run cleanup() until it returns true\r\n    let isDone = false;\r\n    while (!isDone && !rxCollection.closed) {\r\n        if (cleanupPolicy.awaitReplicationsInSync) {\r\n            const replicationStates = REPLICATION_STATE_BY_COLLECTION.get(rxCollection);\r\n            if (replicationStates) {\r\n                await Promise.all(\r\n                    replicationStates.map(replicationState => {\r\n                        if (!replicationState.isStopped()) {\r\n                            return replicationState.awaitInSync();\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n        }\r\n        if (rxCollection.closed) {\r\n            return;\r\n        }\r\n        RXSTORAGE_CLEANUP_QUEUE = RXSTORAGE_CLEANUP_QUEUE\r\n            .then(async () => {\r\n                if (rxCollection.closed) {\r\n                    return true;\r\n                }\r\n                await rxDatabase.requestIdlePromise();\r\n                return storageInstance.cleanup(cleanupPolicy.minimumDeletedTime);\r\n            });\r\n        isDone = await RXSTORAGE_CLEANUP_QUEUE;\r\n    }\r\n    await runAsyncPluginHooks('postCleanup', {\r\n        collectionName: rxCollection.name,\r\n        databaseName: rxDatabase.name\r\n    });\r\n}\r\n\r\nexport async function runCleanupAfterDelete(\r\n    rxCollection: RxCollection,\r\n    cleanupPolicy: RxCleanupPolicy\r\n) {\r\n    while (!rxCollection.closed) {\r\n        /**\r\n         * In theory we should wait here until a document is deleted.\r\n         * But this would mean we have to search through all events ever processed.\r\n         * So instead we just wait for any write event and then we anyway throttle\r\n         * the calls with the promiseWait() below.\r\n         */\r\n        await firstValueFrom(rxCollection.eventBulks$).catch(() => { });\r\n\r\n        await rxCollection.promiseWait(cleanupPolicy.runEach);\r\n        if (rxCollection.closed) {\r\n            return;\r\n        }\r\n        await cleanupRxCollection(rxCollection, cleanupPolicy);\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]}