{"version":3,"file":"index.js","names":["_jsonschemaKeyCompression","require","_overwritable","_pluginHelpers","_rxSchemaHelper","_rxStorageHelper","_index","_rxQueryHelper","COMPRESSION_STATE_BY_SCHEMA","WeakMap","getCompressionStateByRxJsonSchema","schema","overwritable","deepFreezeWhenDevMode","getFromMapOrCreate","compressionSchema","flatClone","primaryKey","table","createCompressionTable","DEFAULT_COMPRESSION_FLAG","getPrimaryFieldOfPrimaryKey","compressedSchema","createCompressedJsonSchema","composedPrimary","newComposedPrimary","key","compressedPath","fields","map","field","separator","indexes","newIndexes","idx","isMaybeReadonlyArray","subIdx","compressionState","wrappedKeyCompressionStorage","args","Object","assign","storage","createStorageInstance","params","keyCompression","modifyToStorage","docData","ret","compressDocumentData","modifyFromStorage","decompressDocumentData","childSchema","instance","wrappedInstance","wrapRxStorageInstance","overwriteMethods","forEach","methodName","methodBefore","bind","preparedQuery","compressedQuery","compressQuery","query","compressedPreparedQuery","prepareQuery","flatCloneDocWithMeta","attachments","_attachments","compressObject","decompressObject"],"sources":["../../../../src/plugins/key-compression/index.ts"],"sourcesContent":["/**\r\n * this plugin adds the keycompression-capabilities to rxdb\r\n * if you don't use this, ensure that you set disableKeyCompression to false in your schema\r\n */\r\n\r\nimport {\r\n    createCompressionTable,\r\n    CompressionTable,\r\n    JsonSchema as KeyCompressionJsonSchema,\r\n    compressObject,\r\n    decompressObject,\r\n    compressedPath,\r\n    DEFAULT_COMPRESSION_FLAG,\r\n    createCompressedJsonSchema,\r\n    compressQuery\r\n} from 'jsonschema-key-compression';\r\nimport {\r\n    overwritable\r\n} from '../../overwritable.ts';\r\nimport { wrapRxStorageInstance } from '../../plugin-helpers.ts';\r\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper.ts';\r\nimport { flatCloneDocWithMeta } from '../../rx-storage-helper.ts';\r\n\r\nimport type {\r\n    RxJsonSchema,\r\n    CompositePrimaryKey,\r\n    RxStorage,\r\n    RxStorageInstanceCreationParams,\r\n    RxDocumentData,\r\n    FilledMangoQuery,\r\n    PreparedQuery,\r\n    RxDocumentWriteData\r\n} from '../../types/index.d.ts';\r\nimport {\r\n    clone,\r\n    flatClone,\r\n    getFromMapOrCreate,\r\n    isMaybeReadonlyArray\r\n} from '../../plugins/utils/index.ts';\r\nimport { prepareQuery } from '../../rx-query-helper.ts';\r\n\r\ndeclare type CompressionState = {\r\n    table: CompressionTable;\r\n    schema: RxJsonSchema<any>;\r\n    compressedSchema: RxJsonSchema<any>;\r\n};\r\n\r\n/**\r\n * Cache the compression table and the compressed schema\r\n * by the storage instance for better performance.\r\n */\r\nconst COMPRESSION_STATE_BY_SCHEMA: WeakMap<\r\n    RxJsonSchema<any>,\r\n    CompressionState\r\n> = new WeakMap();\r\n\r\n\r\nexport function getCompressionStateByRxJsonSchema(\r\n    schema: RxJsonSchema<any>\r\n): CompressionState {\r\n    /**\r\n     * Because we cache the state by the JsonSchema,\r\n     * it must be assured that the given schema object\r\n     * is never mutated.\r\n     */\r\n    overwritable.deepFreezeWhenDevMode(schema);\r\n\r\n    return getFromMapOrCreate(\r\n        COMPRESSION_STATE_BY_SCHEMA,\r\n        schema,\r\n        () => {\r\n            const compressionSchema: KeyCompressionJsonSchema = flatClone(schema) as any;\r\n            delete (compressionSchema as any).primaryKey;\r\n\r\n            const table = createCompressionTable(\r\n                compressionSchema,\r\n                DEFAULT_COMPRESSION_FLAG,\r\n                [\r\n                    /**\r\n                     * Do not compress the primary field\r\n                     * for easier debugging.\r\n                     */\r\n                    getPrimaryFieldOfPrimaryKey(schema.primaryKey),\r\n                    '_rev',\r\n                    '_attachments',\r\n                    '_deleted',\r\n                    '_meta'\r\n                ]\r\n            );\r\n\r\n            delete (compressionSchema as any).primaryKey;\r\n            const compressedSchema: RxJsonSchema<any> = createCompressedJsonSchema(\r\n                table,\r\n                compressionSchema\r\n            ) as RxJsonSchema<any>;\r\n\r\n            // also compress primary key\r\n            if (typeof schema.primaryKey !== 'string') {\r\n                const composedPrimary: CompositePrimaryKey<any> = schema.primaryKey;\r\n                const newComposedPrimary: CompositePrimaryKey<any> = {\r\n                    key: compressedPath(table, composedPrimary.key as string),\r\n                    fields: composedPrimary.fields.map(field => compressedPath(table, field as string)),\r\n                    separator: composedPrimary.separator\r\n                };\r\n                compressedSchema.primaryKey = newComposedPrimary;\r\n            } else {\r\n                compressedSchema.primaryKey = compressedPath(table, schema.primaryKey);\r\n            }\r\n\r\n            /**\r\n             * the key compression module does not know about indexes\r\n             * in the schema, so we have to also compress them here.\r\n             */\r\n            if (schema.indexes) {\r\n                const newIndexes = schema.indexes.map(idx => {\r\n                    if (isMaybeReadonlyArray(idx)) {\r\n                        return idx.map(subIdx => compressedPath(table, subIdx));\r\n                    } else {\r\n                        return compressedPath(table, idx);\r\n                    }\r\n                });\r\n                compressedSchema.indexes = newIndexes;\r\n            }\r\n\r\n            const compressionState = {\r\n                table,\r\n                schema,\r\n                compressedSchema\r\n            };\r\n            return compressionState;\r\n        }\r\n    );\r\n}\r\n\r\nexport function wrappedKeyCompressionStorage<Internals, InstanceCreationOptions>(\r\n    args: {\r\n        storage: RxStorage<Internals, InstanceCreationOptions>;\r\n    }\r\n): RxStorage<Internals, InstanceCreationOptions> {\r\n    return Object.assign(\r\n        {},\r\n        args.storage,\r\n        {\r\n            async createStorageInstance<RxDocType>(\r\n                params: RxStorageInstanceCreationParams<RxDocType, any>\r\n            ) {\r\n                if (!params.schema.keyCompression) {\r\n                    return args.storage.createStorageInstance(params);\r\n                }\r\n\r\n                const compressionState = getCompressionStateByRxJsonSchema(params.schema);\r\n                function modifyToStorage(docData: RxDocumentWriteData<RxDocType>) {\r\n                    const ret = compressDocumentData(compressionState, docData);\r\n                    return ret;\r\n                }\r\n                function modifyFromStorage(docData: RxDocumentData<any>): Promise<RxDocumentData<RxDocType>> {\r\n                    return decompressDocumentData(compressionState, docData);\r\n                }\r\n\r\n                /**\r\n                 * Because this wrapper resolves the key-compression,\r\n                 * we can set the flag to false\r\n                 * which allows underlying storages to detect wrong configurations\r\n                 * like when keyCompression is set to false but no key-compression module is used.\r\n                 */\r\n                const childSchema = flatClone(compressionState.compressedSchema);\r\n                childSchema.keyCompression = false;\r\n\r\n                const instance = await args.storage.createStorageInstance(\r\n                    Object.assign(\r\n                        {},\r\n                        params,\r\n                        {\r\n                            schema: childSchema\r\n                        }\r\n                    )\r\n                );\r\n\r\n                const wrappedInstance = wrapRxStorageInstance(\r\n                    params.schema,\r\n                    instance,\r\n                    modifyToStorage,\r\n                    modifyFromStorage\r\n                );\r\n\r\n\r\n                const overwriteMethods = ['query', 'count'] as const;\r\n                overwriteMethods.forEach(methodName => {\r\n                    const methodBefore = wrappedInstance[methodName].bind(wrappedInstance);\r\n                    (wrappedInstance as any)[methodName] = async (preparedQuery: PreparedQuery<RxDocType>) => {\r\n                        const compressedQuery: FilledMangoQuery<RxDocType> = compressQuery(\r\n                            compressionState.table,\r\n                            preparedQuery.query as any\r\n                        ) as any;\r\n\r\n                        const compressedPreparedQuery = prepareQuery(\r\n                            compressionState.compressedSchema,\r\n                            compressedQuery\r\n                        );\r\n                        return methodBefore(compressedPreparedQuery);\r\n                    }\r\n                });\r\n\r\n                return wrappedInstance;\r\n            }\r\n        }\r\n    );\r\n}\r\n\r\nexport function compressDocumentData(\r\n    compressionState: CompressionState,\r\n    docData: RxDocumentData<any>\r\n): RxDocumentData<any> {\r\n    /**\r\n     * Do not send attachments to compressObject()\r\n     * because it will deep clone which does not work on Blob or Buffer.\r\n     */\r\n    docData = flatCloneDocWithMeta(docData);\r\n    const attachments = docData._attachments;\r\n    delete docData._attachments;\r\n\r\n    docData = compressObject(\r\n        compressionState.table,\r\n        docData\r\n    );\r\n    docData._attachments = attachments;\r\n    return docData;\r\n}\r\n\r\nexport function decompressDocumentData(\r\n    compressionState: CompressionState,\r\n    docData: RxDocumentData<any>\r\n): RxDocumentData<any> {\r\n    return decompressObject(\r\n        compressionState.table,\r\n        docData\r\n    );\r\n}\r\n"],"mappings":"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","ignoreList":[]}