{"version":3,"file":"doc-cache.js","names":["_index2","require","_overwritable","DocumentCache","exports","primaryPath","changes$","documentCreator","cacheItemByDocId","Map","tasks","Set","registry","FinalizationRegistry","docMeta","docId","cacheItem","get","delete","revisionHeight","size","undefined","subscribe","events","add","index","length","event","documentId","documentData","previousDocumentData","requestIdlePromiseNoQueue","then","processTasks","_proto","prototype","Array","from","forEach","task","clear","getLatestDocumentData","getFromMapOrThrow","getLatestDocumentDataIfExists","_createClass2","default","key","fn","getCachedRxDocumentMonad","overwriteGetterForCaching","doc","docCache","deepFreezeWhenDevMode","overwritable","docsData","ret","registryTasks","docData","getHeightOfRevision","_rev","byRev","cachedRxDocumentWeakRef","set","cachedRxDocument","deref","createWeakRefWithFallback","push","register","primary","revision","mapDocumentsDataToCacheDocs","getCachedRxDocuments","HAS_WEAK_REF","WeakRef","createWeakRef","createWeakRefFallback","obj"],"sources":["../../src/doc-cache.ts"],"sourcesContent":["import type {\r\n    RxDocument,\r\n    RxDocumentData,\r\n    RxStorageChangeEvent\r\n} from './types/index.d.ts';\r\nimport {\r\n    getFromMapOrThrow,\r\n    getHeightOfRevision,\r\n    overwriteGetterForCaching,\r\n    requestIdlePromiseNoQueue\r\n} from './plugins/utils/index.ts';\r\nimport {\r\n    overwritable\r\n} from './overwritable.ts';\r\nimport { Observable } from 'rxjs';\r\n\r\n/**\r\n * Because we have to create many cache items,\r\n * we use an array instead of an object with properties\r\n * for better performance and less memory usage.\r\n * @link https://stackoverflow.com/questions/17295056/array-vs-object-efficiency-in-javascript\r\n */\r\ndeclare type CacheItem<RxDocType, OrmMethods> = [\r\n    /**\r\n     * Store the different document states of time\r\n     * based on their revision height (rev height = array index).\r\n     * We store WeakRefs so that we can later clean up\r\n     * document states that are no longer needed.\r\n     */\r\n    Map<number, WeakRef<RxDocument<RxDocType, OrmMethods>>>,\r\n\r\n    /**\r\n     * Store the latest known document state.\r\n     * As long as any state of the document is in the cache,\r\n     * we observe the changestream and update the latestDoc accordingly.\r\n     * This makes it easier to optimize performance on other parts\r\n     * because for each known document we can always get the current state\r\n     * in the storage.\r\n     * Also it makes it possible to call RxDocument.latest() in a non-async way\r\n     * to retrieve the latest document state or to observe$ some property.\r\n     *\r\n     * To not prevent the whole cacheItem from being garbage collected,\r\n     * we store only the document data here, but not the RxDocument.\r\n     */\r\n    RxDocumentData<RxDocType>\r\n];\r\n\r\n\r\n/**\r\n * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\r\n */\r\ndeclare type FinalizationRegistryValue = {\r\n    docId: string;\r\n    revisionHeight: number;\r\n};\r\n\r\n/**\r\n * The DocumentCache stores RxDocument objects\r\n * by their primary key and revision.\r\n * This is useful on client side applications where\r\n * it is not known how much memory can be used, so\r\n * we de-duplicate RxDocument states to save memory.\r\n * To not fill up the memory with old document states, the DocumentCache\r\n * only contains weak references to the RxDocuments themself.\r\n * @link https://caniuse.com/?search=weakref\r\n */\r\nexport class DocumentCache<RxDocType, OrmMethods> {\r\n    public readonly cacheItemByDocId = new Map<string, CacheItem<RxDocType, OrmMethods>>();\r\n\r\n    /**\r\n     * Process stuff lazy to not block the CPU\r\n     * on critical paths.\r\n     */\r\n    public readonly tasks = new Set<Function>();\r\n\r\n    /**\r\n     * Some JavaScript runtimes like QuickJS,\r\n     * so not have a FinalizationRegistry or WeakRef.\r\n     * Therefore we need a workaround which might waste a lot of memory,\r\n     * but at least works.\r\n     */\r\n    public readonly registry?: FinalizationRegistry<FinalizationRegistryValue> = typeof FinalizationRegistry === 'function' ?\r\n        new FinalizationRegistry<FinalizationRegistryValue>(docMeta => {\r\n            const docId = docMeta.docId;\r\n            const cacheItem = this.cacheItemByDocId.get(docId);\r\n            if (cacheItem) {\r\n                cacheItem[0].delete(docMeta.revisionHeight);\r\n                if (cacheItem[0].size === 0) {\r\n                    /**\r\n                     * No state of the document is cached anymore,\r\n                     * so we can clean up.\r\n                     */\r\n                    this.cacheItemByDocId.delete(docId);\r\n                }\r\n            }\r\n        }) :\r\n        undefined;\r\n\r\n    constructor(\r\n        public readonly primaryPath: string,\r\n        public readonly changes$: Observable<RxStorageChangeEvent<RxDocType>[]>,\r\n        /**\r\n         * A method that can create a RxDocument by the given document data.\r\n         */\r\n        public documentCreator: (docData: RxDocumentData<RxDocType>) => RxDocument<RxDocType, OrmMethods>\r\n    ) {\r\n        changes$.subscribe(events => {\r\n            this.tasks.add(() => {\r\n                const cacheItemByDocId = this.cacheItemByDocId;\r\n                for (let index = 0; index < events.length; index++) {\r\n                    const event = events[index];\r\n                    const cacheItem = cacheItemByDocId.get(event.documentId);\r\n                    if (cacheItem) {\r\n                        let documentData = event.documentData;\r\n                        if (!documentData) {\r\n                            documentData = event.previousDocumentData as any;\r\n                        }\r\n                        cacheItem[1] = documentData;\r\n                    }\r\n                }\r\n            });\r\n            if (this.tasks.size <= 1) {\r\n                requestIdlePromiseNoQueue().then(() => {\r\n                    this.processTasks();\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    public processTasks() {\r\n        if (this.tasks.size === 0) {\r\n            return;\r\n        }\r\n        const tasks = Array.from(this.tasks);\r\n        tasks.forEach(task => task());\r\n        this.tasks.clear();\r\n    }\r\n\r\n    /**\r\n     * Get the RxDocument from the cache\r\n     * and create a new one if not exits before.\r\n     * @overwrites itself with the actual function\r\n     * because this is @performance relevant.\r\n     * It is called on each document row for each write and read.\r\n     */\r\n    get getCachedRxDocuments(): (docsData: RxDocumentData<RxDocType>[]) => RxDocument<RxDocType, OrmMethods>[] {\r\n        const fn = getCachedRxDocumentMonad(this);\r\n        return overwriteGetterForCaching(\r\n            this,\r\n            'getCachedRxDocuments',\r\n            fn\r\n        );\r\n    }\r\n\r\n    get getCachedRxDocument(): (docData: RxDocumentData<RxDocType>) => RxDocument<RxDocType, OrmMethods> {\r\n        const fn = getCachedRxDocumentMonad(this);\r\n        return overwriteGetterForCaching(\r\n            this,\r\n            'getCachedRxDocument',\r\n            doc => fn([doc])[0]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Throws if not exists\r\n     */\r\n    public getLatestDocumentData(docId: string): RxDocumentData<RxDocType> {\r\n        this.processTasks();\r\n        const cacheItem = getFromMapOrThrow(this.cacheItemByDocId, docId);\r\n        return cacheItem[1];\r\n    }\r\n\r\n    public getLatestDocumentDataIfExists(docId: string): RxDocumentData<RxDocType> | undefined {\r\n        this.processTasks();\r\n        const cacheItem = this.cacheItemByDocId.get(docId);\r\n        if (cacheItem) {\r\n            return cacheItem[1];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * This function is called very very often.\r\n * This is likely the most important function for RxDB overall performance\r\n * @hotPath This is one of the most important methods for performance.\r\n * It is used in many places to transform the raw document data into RxDocuments.\r\n */\r\nfunction getCachedRxDocumentMonad<RxDocType, OrmMethods>(\r\n    docCache: DocumentCache<RxDocType, OrmMethods>\r\n): (docsData: RxDocumentData<RxDocType>[]) => RxDocument<RxDocType, OrmMethods>[] {\r\n    const primaryPath = docCache.primaryPath;\r\n    const cacheItemByDocId = docCache.cacheItemByDocId;\r\n    const registry = docCache.registry;\r\n    const deepFreezeWhenDevMode = overwritable.deepFreezeWhenDevMode;\r\n    const documentCreator = docCache.documentCreator;\r\n    const fn: (docsData: RxDocumentData<RxDocType>[]) => RxDocument<RxDocType, OrmMethods>[] = (docsData: RxDocumentData<RxDocType>[]) => {\r\n        const ret: RxDocument<RxDocType, OrmMethods>[] = new Array(docsData.length);\r\n        const registryTasks: RxDocument<RxDocType, OrmMethods>[] = [];\r\n        for (let index = 0; index < docsData.length; index++) {\r\n            let docData = docsData[index];\r\n            const docId: string = (docData as any)[primaryPath];\r\n\r\n            const revisionHeight = getHeightOfRevision(docData._rev);\r\n\r\n            let byRev: Map<number, WeakRef<RxDocument<RxDocType, OrmMethods>>>;\r\n            let cachedRxDocumentWeakRef: WeakRef<RxDocument<RxDocType, OrmMethods>> | undefined;\r\n            let cacheItem = cacheItemByDocId.get(docId);\r\n            if (!cacheItem) {\r\n                byRev = new Map();\r\n                cacheItem = [\r\n                    byRev,\r\n                    docData\r\n                ];\r\n                cacheItemByDocId.set(docId, cacheItem);\r\n            } else {\r\n                byRev = cacheItem[0];\r\n                cachedRxDocumentWeakRef = byRev.get(revisionHeight);\r\n            }\r\n            let cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : undefined;\r\n            if (!cachedRxDocument) {\r\n                docData = deepFreezeWhenDevMode(docData) as any;\r\n                cachedRxDocument = documentCreator(docData) as RxDocument<RxDocType, OrmMethods>;\r\n                byRev.set(revisionHeight, createWeakRefWithFallback(cachedRxDocument));\r\n                if (registry) {\r\n                    registryTasks.push(cachedRxDocument);\r\n                }\r\n            }\r\n            ret[index] = cachedRxDocument;\r\n        }\r\n        if (registryTasks.length > 0 && registry) {\r\n            /**\r\n             * Calling registry.register() has shown to have\r\n             * really bad performance. So we add the cached documents\r\n             * lazily.\r\n             */\r\n            docCache.tasks.add(() => {\r\n                for (let index = 0; index < registryTasks.length; index++) {\r\n                    const doc = registryTasks[index];\r\n                    registry.register(doc, {\r\n                        docId: doc.primary,\r\n                        revisionHeight: getHeightOfRevision(doc.revision)\r\n                    });\r\n                }\r\n            });\r\n            if (docCache.tasks.size <= 1) {\r\n                requestIdlePromiseNoQueue().then(() => {\r\n                    docCache.processTasks();\r\n                });\r\n            }\r\n        }\r\n        return ret;\r\n    };\r\n    return fn;\r\n}\r\n\r\nexport function mapDocumentsDataToCacheDocs<RxDocType, OrmMethods>(\r\n    docCache: DocumentCache<RxDocType, OrmMethods>,\r\n    docsData: RxDocumentData<RxDocType>[]\r\n) {\r\n    const getCachedRxDocuments = docCache.getCachedRxDocuments;\r\n    return getCachedRxDocuments(docsData);\r\n}\r\n\r\n/**\r\n * Fallback for JavaScript runtimes that do not support WeakRef.\r\n * The fallback will keep the items in cache forever,\r\n * but at least works.\r\n */\r\nconst HAS_WEAK_REF = typeof WeakRef === 'function';\r\nconst createWeakRefWithFallback = HAS_WEAK_REF ? createWeakRef : createWeakRefFallback;\r\nfunction createWeakRef<T extends object>(obj: T): WeakRef<T> {\r\n    return new WeakRef(obj) as any;\r\n}\r\nfunction createWeakRefFallback<T extends object>(obj: T): WeakRef<T> {\r\n    return {\r\n        deref() {\r\n            return obj;\r\n        }\r\n    } as any;\r\n}\r\n"],"mappings":"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","ignoreList":[]}