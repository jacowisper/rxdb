{"version":3,"file":"incremental-write.js","names":["_rxError","require","_index","_rxStorageHelper","IncrementalWriteQueue","exports","storageInstance","primaryPath","preWrite","postWrite","queueByDocId","Map","isRunning","_proto","prototype","addWrite","lastKnownDocumentState","modifier","docId","ar","getFromMapOrCreate","ret","Promise","resolve","reject","item","ensureNotFalsy","push","triggerRun","size","writeRows","itemsById","all","Array","from","entries","map","_docId","items","oldData","findNewestOfDocumentStates","i","newData","clone","err","forEach","previous","document","writeResult","length","bulkWrite","error","getWrittenDocumentsFromBulkWriteResponse","result","getFromMapOrThrow","documentId","isConflict","isBulkWriteConflictError","reverse","documentInDb","unshift","rxError","rxStorageWriteErrorToRxError","modifierFromPublicToInternal","publicModifier","docData","withoutMeta","stripMetaDataFromDocument","_deleted","modified","reattachedMeta","Object","assign","_meta","_attachments","_rev","docs","newest","newestRevisionHeight","getHeightOfRevision","doc","height"],"sources":["../../src/incremental-write.ts"],"sourcesContent":["import {\r\n    isBulkWriteConflictError,\r\n    rxStorageWriteErrorToRxError\r\n} from './rx-error.ts';\r\nimport type {\r\n    ModifyFunction,\r\n    BulkWriteRow,\r\n    MaybePromise,\r\n    RxDocumentData,\r\n    RxDocumentWriteData,\r\n    RxError,\r\n    RxStorageBulkWriteResponse,\r\n    RxStorageInstance,\r\n    StringKeys,\r\n    WithDeleted\r\n} from './types/index.d.ts';\r\nimport {\r\n    clone,\r\n    ensureNotFalsy,\r\n    getFromMapOrCreate,\r\n    getFromMapOrThrow,\r\n    getHeightOfRevision,\r\n    stripMetaDataFromDocument\r\n} from './plugins/utils/index.ts';\r\nimport { getWrittenDocumentsFromBulkWriteResponse } from './rx-storage-helper.ts';\r\n\r\n\r\n\r\nexport type IncrementalWriteModifier<RxDocType> = (\r\n    doc: RxDocumentData<RxDocType>\r\n) => MaybePromise<RxDocumentData<RxDocType>> | MaybePromise<RxDocumentWriteData<RxDocType>>;\r\n\r\n\r\ntype IncrementalWriteQueueItem<RxDocType> = {\r\n    lastKnownDocumentState: RxDocumentData<RxDocType>;\r\n    modifier: IncrementalWriteModifier<RxDocType>;\r\n    resolve: (d: RxDocumentData<RxDocType>) => void;\r\n    reject: (error: RxError) => void;\r\n};\r\n\r\n/**\r\n * The incremental write queue\r\n * batches up all incremental writes to a collection\r\n * so that performance can be improved by:\r\n * - Running only one write even when there are multiple modifications to the same document.\r\n * - Run all writes ins a single bulkWrite() call even when there are writes to many documents.\r\n */\r\nexport class IncrementalWriteQueue<RxDocType> {\r\n    public queueByDocId = new Map<string, IncrementalWriteQueueItem<RxDocType>[]>();\r\n    public isRunning: boolean = false;\r\n\r\n    constructor(\r\n        public readonly storageInstance: RxStorageInstance<RxDocType, any, any>,\r\n        public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>,\r\n        // can be used to run hooks etc.\r\n        public readonly preWrite: (newData: RxDocumentData<RxDocType>, oldData: RxDocumentData<RxDocType>) => MaybePromise<void>,\r\n        public readonly postWrite: (docData: RxDocumentData<RxDocType>) => void\r\n\r\n    ) { }\r\n\r\n    addWrite(\r\n        lastKnownDocumentState: RxDocumentData<RxDocType>,\r\n        modifier: IncrementalWriteModifier<RxDocType>\r\n    ): Promise<RxDocumentData<RxDocType>> {\r\n        const docId: string = lastKnownDocumentState[this.primaryPath] as any;\r\n        const ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\r\n        const ret = new Promise<RxDocumentData<RxDocType>>((resolve, reject) => {\r\n            const item: IncrementalWriteQueueItem<RxDocType> = {\r\n                lastKnownDocumentState,\r\n                modifier,\r\n                resolve,\r\n                reject\r\n            };\r\n            ensureNotFalsy(ar).push(item);\r\n            this.triggerRun();\r\n        });\r\n        return ret;\r\n    }\r\n\r\n    async triggerRun(): Promise<void> {\r\n        if (\r\n            this.isRunning === true ||\r\n            this.queueByDocId.size === 0\r\n        ) {\r\n            // already running\r\n            return;\r\n        }\r\n        this.isRunning = true;\r\n        const writeRows: BulkWriteRow<RxDocType>[] = [];\r\n\r\n        /**\r\n         * 'take over' so that while the async functions runs,\r\n         * new incremental updates could be added from the outside.\r\n         */\r\n        const itemsById = this.queueByDocId;\r\n        this.queueByDocId = new Map();\r\n        await Promise.all(\r\n            Array.from(itemsById.entries())\r\n                .map(async ([_docId, items]) => {\r\n                    const oldData = findNewestOfDocumentStates(\r\n                        items.map(i => i.lastKnownDocumentState)\r\n                    );\r\n                    let newData = oldData;\r\n                    for (const item of items) {\r\n                        try {\r\n                            newData = await item.modifier(\r\n                                /**\r\n                                 * We have to clone() each time because the modifier\r\n                                 * might throw while it already changed some properties\r\n                                 * of the document.\r\n                                 */\r\n                                clone(newData)\r\n                            ) as any;\r\n                        } catch (err: any) {\r\n                            item.reject(err);\r\n                            item.reject = () => { };\r\n                            item.resolve = () => { };\r\n                        }\r\n                    }\r\n\r\n                    try {\r\n                        await this.preWrite(newData, oldData);\r\n                    } catch (err: any) {\r\n                        /**\r\n                         * If the before-hooks fail,\r\n                         * we reject all of the writes because it is\r\n                         * not possible to determine which one is to blame.\r\n                         */\r\n                        items.forEach(item => item.reject(err));\r\n                        return;\r\n                    }\r\n                    writeRows.push({\r\n                        previous: oldData,\r\n                        document: newData\r\n                    });\r\n                })\r\n        );\r\n        const writeResult: RxStorageBulkWriteResponse<RxDocType> = writeRows.length > 0 ?\r\n            await this.storageInstance.bulkWrite(writeRows, 'incremental-write') :\r\n            { error: [] };\r\n\r\n        // process success\r\n        await Promise.all(\r\n            getWrittenDocumentsFromBulkWriteResponse(this.primaryPath, writeRows, writeResult).map(result => {\r\n                const docId = result[this.primaryPath] as string;\r\n                this.postWrite(result);\r\n                const items = getFromMapOrThrow(itemsById, docId);\r\n                items.forEach(item => item.resolve(result));\r\n            })\r\n        );\r\n\r\n        // process errors\r\n        writeResult.error\r\n            .forEach(error => {\r\n                const docId = error.documentId;\r\n                const items = getFromMapOrThrow(itemsById, docId);\r\n                const isConflict = isBulkWriteConflictError<RxDocType>(error);\r\n                if (isConflict) {\r\n                    // had conflict -> retry afterwards\r\n                    const ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\r\n                    /**\r\n                     * Add the items back to this.queueByDocId\r\n                     * by maintaining the original order.\r\n                     */\r\n                    items\r\n                        .reverse()\r\n                        .forEach(item => {\r\n                            item.lastKnownDocumentState = ensureNotFalsy(isConflict.documentInDb);\r\n                            ensureNotFalsy(ar).unshift(item);\r\n                        });\r\n                } else {\r\n                    // other error -> must be thrown\r\n                    const rxError = rxStorageWriteErrorToRxError(error);\r\n                    items.forEach(item => item.reject(rxError));\r\n                }\r\n            });\r\n        this.isRunning = false;\r\n\r\n        /**\r\n         * Always trigger another run\r\n         * because in between there might be new items\r\n         * been added to the queue.\r\n         */\r\n        return this.triggerRun();\r\n    }\r\n}\r\n\r\n\r\nexport function modifierFromPublicToInternal<RxDocType>(\r\n    publicModifier: ModifyFunction<RxDocType>\r\n): IncrementalWriteModifier<RxDocType> {\r\n    const ret = async (docData: RxDocumentData<RxDocType>) => {\r\n        const withoutMeta: WithDeleted<RxDocType> = stripMetaDataFromDocument(docData) as any;\r\n        withoutMeta._deleted = docData._deleted;\r\n        const modified = await publicModifier(withoutMeta);\r\n        const reattachedMeta: RxDocumentData<RxDocType> = Object.assign({}, modified, {\r\n            _meta: docData._meta,\r\n            _attachments: docData._attachments,\r\n            _rev: docData._rev,\r\n            _deleted: typeof (modified as WithDeleted<RxDocType>)._deleted !== 'undefined' ?\r\n                (modified as WithDeleted<RxDocType>)._deleted :\r\n                docData._deleted\r\n        });\r\n        if (typeof reattachedMeta._deleted === 'undefined') {\r\n            reattachedMeta._deleted = false;\r\n        }\r\n        return reattachedMeta;\r\n    };\r\n    return ret;\r\n}\r\n\r\n\r\nexport function findNewestOfDocumentStates<RxDocType>(\r\n    docs: RxDocumentData<RxDocType>[]\r\n): RxDocumentData<RxDocType> {\r\n\r\n    let newest = docs[0];\r\n    let newestRevisionHeight = getHeightOfRevision(newest._rev);\r\n    docs.forEach(doc => {\r\n        const height = getHeightOfRevision(doc._rev);\r\n        if (height > newestRevisionHeight) {\r\n            newest = doc;\r\n            newestRevisionHeight = height;\r\n        }\r\n    });\r\n    return newest;\r\n}\r\n"],"mappings":"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","ignoreList":[]}