{"version":3,"file":"query-planner.js","names":["_index","require","_rxError","_rxSchemaHelper","INDEX_MAX","exports","String","fromCharCode","INDEX_MIN","Number","MIN_SAFE_INTEGER","getQueryPlan","schema","query","selector","indexes","slice","index","hasDescSorting","sort","find","sortField","Object","values","sortIrrelevevantFields","Set","keys","forEach","fieldName","schemaPart","getSchemaByObjectPath","type","prototype","hasOwnProperty","call","add","optimalSortIndex","map","optimalSortIndexCompareString","filter","f","has","join","currentBestQuality","currentBestQueryPlan","inclusiveEnd","inclusiveStart","opts","indexField","matcher","operators","matcherOpts","length","startKey","endKey","operator","LOGICAL_OPERATORS","operatorValue","partialOpts","getMatcherQueryOpts","assign","startKeys","opt","endKeys","queryPlan","sortSatisfiedByIndex","selectorSatisfiedByIndex","isSelectorSatisfiedByIndex","quality","rateQueryPlan","newRxError","LOWER_BOUND_LOGICAL_OPERATORS","UPPER_BOUND_LOGICAL_OPERATORS","selectorEntries","entries","hasNonMatchingOperator","operation","includes","hasNonLogicOperator","op","_value","$and","$or","satisfieldLowerBound","lowerOperatorFieldNames","lowerLogicOps","key","hasLowerLogicOp","push","satisfieldUpperBound","upperOperatorFieldNames","upperLogicOps","hasUperLogicOp","i","set","size","delete","Error","addQuality","value","pointsPerMatchingKey","nonMinKeyCount","countUntilNotMatching","keyValue","nonMaxKeyCount","equalKeyCount","idx","pointsIfNoReSortMustBeDone"],"sources":["../../src/query-planner.ts"],"sourcesContent":["import { countUntilNotMatching } from './plugins/utils/index.ts';\r\nimport { newRxError } from './rx-error.ts';\r\nimport { getSchemaByObjectPath } from './rx-schema-helper.ts';\r\nimport type {\r\n    FilledMangoQuery,\r\n    MangoQuerySelector,\r\n    RxDocumentData,\r\n    RxJsonSchema,\r\n    RxQueryPlan,\r\n    RxQueryPlanKey,\r\n    RxQueryPlanerOpts\r\n} from './types/index.d.ts';\r\n\r\nexport const INDEX_MAX = String.fromCharCode(65535);\r\n\r\n/**\r\n * Do not use -Infinity here because it would be\r\n * transformed to null on JSON.stringify() which can break things\r\n * when the query plan is send to the storage as json.\r\n * @link https://stackoverflow.com/a/16644751\r\n * Notice that for IndexedDB IDBKeyRange we have\r\n * to transform the value back to -Infinity\r\n * before we can use it in IDBKeyRange.bound.\r\n */\r\nexport const INDEX_MIN = Number.MIN_SAFE_INTEGER;\r\n\r\n/**\r\n * Returns the query plan which contains\r\n * information about how to run the query\r\n * and which indexes to use.\r\n *\r\n * This is used in some storage like Memory, dexie.js and IndexedDB.\r\n */\r\nexport function getQueryPlan<RxDocType>(\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    query: FilledMangoQuery<RxDocType>\r\n): RxQueryPlan {\r\n    const selector = query.selector;\r\n\r\n    let indexes: string[][] = schema.indexes ? schema.indexes.slice(0) as any : [];\r\n    if (query.index) {\r\n        indexes = [query.index];\r\n    }\r\n\r\n    /**\r\n     * Most storages do not support descending indexes\r\n     * so having a 'desc' in the sorting, means we always have to re-sort the results.\r\n     */\r\n    const hasDescSorting = !!query.sort.find(sortField => Object.values(sortField)[0] === 'desc');\r\n\r\n    /**\r\n     * Some fields can be part of the selector while not being relevant for sorting\r\n     * because their selector operators specify that in all cases all matching docs\r\n     * would have the same value.\r\n     * For example the boolean field _deleted.\r\n     * TODO similar thing could be done for enums.\r\n     */\r\n    const sortIrrelevevantFields = new Set();\r\n    Object.keys(selector).forEach(fieldName => {\r\n        const schemaPart = getSchemaByObjectPath(schema, fieldName);\r\n        if (\r\n            schemaPart &&\r\n            schemaPart.type === 'boolean' &&\r\n            Object.prototype.hasOwnProperty.call((selector as any)[fieldName], '$eq')\r\n        ) {\r\n            sortIrrelevevantFields.add(fieldName);\r\n        }\r\n    });\r\n\r\n\r\n    const optimalSortIndex = query.sort.map(sortField => Object.keys(sortField)[0]);\r\n    const optimalSortIndexCompareString = optimalSortIndex\r\n        .filter(f => !sortIrrelevevantFields.has(f))\r\n        .join(',');\r\n\r\n    let currentBestQuality = -1;\r\n    let currentBestQueryPlan: RxQueryPlan | undefined;\r\n\r\n    /**\r\n     * Calculate one query plan for each index\r\n     * and then test which of the plans is best.\r\n     */\r\n    indexes.forEach((index) => {\r\n        let inclusiveEnd = true;\r\n        let inclusiveStart = true;\r\n        const opts: RxQueryPlanerOpts[] = index.map(indexField => {\r\n            const matcher = (selector as any)[indexField];\r\n            const operators = matcher ? Object.keys(matcher) : [];\r\n\r\n            let matcherOpts: RxQueryPlanerOpts = {} as any;\r\n            if (\r\n                !matcher ||\r\n                !operators.length\r\n            ) {\r\n                const startKey = inclusiveStart ? INDEX_MIN : INDEX_MAX;\r\n                matcherOpts = {\r\n                    startKey,\r\n                    endKey: inclusiveEnd ? INDEX_MAX : INDEX_MIN,\r\n                    inclusiveStart: true,\r\n                    inclusiveEnd: true\r\n                };\r\n            } else {\r\n                operators.forEach(operator => {\r\n                    if (LOGICAL_OPERATORS.has(operator)) {\r\n                        const operatorValue = matcher[operator];\r\n                        const partialOpts = getMatcherQueryOpts(operator, operatorValue);\r\n                        matcherOpts = Object.assign(matcherOpts, partialOpts);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // fill missing attributes\r\n            if (typeof matcherOpts.startKey === 'undefined') {\r\n                matcherOpts.startKey = INDEX_MIN;\r\n            }\r\n            if (typeof matcherOpts.endKey === 'undefined') {\r\n                matcherOpts.endKey = INDEX_MAX;\r\n            }\r\n            if (typeof matcherOpts.inclusiveStart === 'undefined') {\r\n                matcherOpts.inclusiveStart = true;\r\n            }\r\n            if (typeof matcherOpts.inclusiveEnd === 'undefined') {\r\n                matcherOpts.inclusiveEnd = true;\r\n            }\r\n\r\n            if (inclusiveStart && !matcherOpts.inclusiveStart) {\r\n                inclusiveStart = false;\r\n            }\r\n            if (inclusiveEnd && !matcherOpts.inclusiveEnd) {\r\n                inclusiveEnd = false;\r\n            }\r\n\r\n            return matcherOpts;\r\n        });\r\n\r\n\r\n        const startKeys = opts.map(opt => opt.startKey);\r\n        const endKeys = opts.map(opt => opt.endKey);\r\n        const queryPlan: RxQueryPlan = {\r\n            index,\r\n            startKeys,\r\n            endKeys,\r\n            inclusiveEnd,\r\n            inclusiveStart,\r\n            sortSatisfiedByIndex: !hasDescSorting && optimalSortIndexCompareString === index.filter(f => !sortIrrelevevantFields.has(f)).join(','),\r\n            selectorSatisfiedByIndex: isSelectorSatisfiedByIndex(index, query.selector, startKeys, endKeys)\r\n        };\r\n        const quality = rateQueryPlan(\r\n            schema,\r\n            query,\r\n            queryPlan\r\n        );\r\n        if (\r\n            (\r\n                quality >= currentBestQuality\r\n            ) ||\r\n            query.index\r\n        ) {\r\n            currentBestQuality = quality;\r\n            currentBestQueryPlan = queryPlan;\r\n        }\r\n    });\r\n\r\n    /**\r\n     * In all cases and index must be found\r\n     */\r\n    if (!currentBestQueryPlan) {\r\n        throw newRxError('SNH', {\r\n            query\r\n        });\r\n    }\r\n\r\n    return currentBestQueryPlan;\r\n}\r\n\r\nexport const LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte', '$lt', '$lte']);\r\nexport const LOWER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte']);\r\nexport const UPPER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$lt', '$lte']);\r\n\r\n\r\nexport function isSelectorSatisfiedByIndex(\r\n    index: string[],\r\n    selector: MangoQuerySelector<any>,\r\n    startKeys: RxQueryPlanKey[],\r\n    endKeys: RxQueryPlanKey[]\r\n): boolean {\r\n\r\n\r\n    /**\r\n     * Not satisfied if one or more operators are non-logical\r\n     * operators that can never be satisfied by an index.\r\n     */\r\n    const selectorEntries = Object.entries(selector);\r\n    const hasNonMatchingOperator = selectorEntries\r\n        .find(([fieldName, operation]) => {\r\n            if (!index.includes(fieldName)) {\r\n                return true;\r\n            }\r\n            const hasNonLogicOperator = Object.entries(operation as any)\r\n                .find(([op, _value]) => !LOGICAL_OPERATORS.has(op));\r\n            return hasNonLogicOperator;\r\n        });\r\n\r\n    if (hasNonMatchingOperator) {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Not satisfied if contains $and or $or operations.\r\n     */\r\n    if (selector.$and || selector.$or) {\r\n        return false;\r\n    }\r\n\r\n\r\n\r\n    // ensure all lower bound in index\r\n    const satisfieldLowerBound: string[] = [];\r\n    const lowerOperatorFieldNames = new Set<string>();\r\n    for (const [fieldName, operation] of Object.entries(selector)) {\r\n        if (!index.includes(fieldName)) {\r\n            return false;\r\n        }\r\n\r\n        // If more then one logic op on the same field, we have to selector-match.\r\n        const lowerLogicOps = Object.keys(operation as any).filter(key => LOWER_BOUND_LOGICAL_OPERATORS.has(key));\r\n        if (lowerLogicOps.length > 1) {\r\n            return false;\r\n        }\r\n\r\n        const hasLowerLogicOp = lowerLogicOps[0];\r\n        if (hasLowerLogicOp) {\r\n            lowerOperatorFieldNames.add(fieldName);\r\n        }\r\n        if (hasLowerLogicOp !== '$eq') {\r\n            if (satisfieldLowerBound.length > 0) {\r\n                return false;\r\n            } else {\r\n                satisfieldLowerBound.push(hasLowerLogicOp);\r\n            }\r\n        }\r\n    }\r\n\r\n    // ensure all upper bound in index\r\n    const satisfieldUpperBound: string[] = [];\r\n    const upperOperatorFieldNames = new Set<string>();\r\n    for (const [fieldName, operation] of Object.entries(selector)) {\r\n        if (!index.includes(fieldName)) {\r\n            return false;\r\n        }\r\n\r\n        // If more then one logic op on the same field, we have to selector-match.\r\n        const upperLogicOps = Object.keys(operation as any).filter(key => UPPER_BOUND_LOGICAL_OPERATORS.has(key));\r\n        if (upperLogicOps.length > 1) {\r\n            return false;\r\n        }\r\n\r\n        const hasUperLogicOp = upperLogicOps[0];\r\n        if (hasUperLogicOp) {\r\n            upperOperatorFieldNames.add(fieldName);\r\n        }\r\n        if (hasUperLogicOp !== '$eq') {\r\n            if (satisfieldUpperBound.length > 0) {\r\n                return false;\r\n            } else {\r\n                satisfieldUpperBound.push(hasUperLogicOp);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * If the index contains a non-relevant field between\r\n     * the relevant fields, then the index is not satisfying.\r\n     */\r\n    let i = 0;\r\n    for (const fieldName of index) {\r\n        for (const set of [\r\n            lowerOperatorFieldNames,\r\n            upperOperatorFieldNames\r\n        ]) {\r\n            if (\r\n                !set.has(fieldName) &&\r\n                set.size > 0\r\n            ) {\r\n                return false;\r\n            }\r\n            set.delete(fieldName);\r\n        }\r\n\r\n        const startKey = startKeys[i];\r\n        const endKey = endKeys[i];\r\n\r\n        if (\r\n            startKey !== endKey && (\r\n                lowerOperatorFieldNames.size > 0 &&\r\n                upperOperatorFieldNames.size > 0\r\n            )\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        i++;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport function getMatcherQueryOpts(\r\n    operator: string,\r\n    operatorValue: any\r\n): Partial<RxQueryPlanerOpts> {\r\n    switch (operator) {\r\n        case '$eq':\r\n            return {\r\n                startKey: operatorValue,\r\n                endKey: operatorValue,\r\n                inclusiveEnd: true,\r\n                inclusiveStart: true\r\n            };\r\n        case '$lte':\r\n            return {\r\n                endKey: operatorValue,\r\n                inclusiveEnd: true\r\n            };\r\n        case '$gte':\r\n            return {\r\n                startKey: operatorValue,\r\n                inclusiveStart: true\r\n            };\r\n        case '$lt':\r\n            return {\r\n                endKey: operatorValue,\r\n                inclusiveEnd: false\r\n            };\r\n        case '$gt':\r\n            return {\r\n                startKey: operatorValue,\r\n                inclusiveStart: false\r\n            };\r\n        default:\r\n            throw new Error('SNH');\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Returns a number that determines the quality of the query plan.\r\n * Higher number means better query plan.\r\n */\r\nexport function rateQueryPlan<RxDocType>(\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    query: FilledMangoQuery<RxDocType>,\r\n    queryPlan: RxQueryPlan\r\n): number {\r\n    let quality: number = 0;\r\n    const addQuality = (value: number) => {\r\n        if (value > 0) {\r\n            quality = quality + value;\r\n        }\r\n    };\r\n\r\n    const pointsPerMatchingKey = 10;\r\n\r\n    const nonMinKeyCount = countUntilNotMatching(queryPlan.startKeys, keyValue => keyValue !== INDEX_MIN && keyValue !== INDEX_MAX);\r\n    addQuality(nonMinKeyCount * pointsPerMatchingKey);\r\n\r\n    const nonMaxKeyCount = countUntilNotMatching(queryPlan.startKeys, keyValue => keyValue !== INDEX_MAX && keyValue !== INDEX_MIN);\r\n    addQuality(nonMaxKeyCount * pointsPerMatchingKey);\r\n\r\n    const equalKeyCount = countUntilNotMatching(queryPlan.startKeys, (keyValue, idx) => {\r\n        if (keyValue === queryPlan.endKeys[idx]) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    });\r\n    addQuality(equalKeyCount * pointsPerMatchingKey * 1.5);\r\n\r\n    const pointsIfNoReSortMustBeDone = queryPlan.sortSatisfiedByIndex ? 5 : 0;\r\n    addQuality(pointsIfNoReSortMustBeDone);\r\n\r\n    return quality;\r\n}\r\n"],"mappings":"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","ignoreList":[]}