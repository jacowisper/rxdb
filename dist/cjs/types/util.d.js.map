{"version":3,"file":"util.d.js","names":[],"sources":["../../../src/types/util.d.ts"],"sourcesContent":["import type { RxStorage } from './rx-storage.interface';\r\n\r\nexport type MaybePromise<T> = Promise<T> | T;\r\n\r\n\r\nexport type PlainJsonValue = string | number | boolean | PlainSimpleJsonObject | PlainSimpleJsonObject[] | PlainJsonValue[];\r\nexport type PlainSimpleJsonObject = {\r\n    [k: string]: PlainJsonValue | PlainJsonValue[];\r\n};\r\n\r\n/**\r\n * @link https://stackoverflow.com/a/49670389/3443137\r\n */\r\ntype DeepReadonly<T> =\r\n    T extends (infer R)[] ? DeepReadonlyArray<R> :\r\n    T extends Function ? T :\r\n    T extends object ? DeepReadonlyObject<T> :\r\n    T;\r\n\r\ninterface DeepReadonlyArray<T> extends ReadonlyArray<DeepReadonly<T>> { }\r\n\r\ntype DeepReadonlyObject<T> = {\r\n    readonly [P in keyof T]: DeepReadonly<T[P]>;\r\n};\r\n\r\nexport type MaybeReadonly<T> = T | Readonly<T>;\r\n\r\n\r\n/**\r\n * Opposite of DeepReadonly,\r\n * makes everything mutable again.\r\n */\r\ntype DeepMutable<T> = (\r\n    T extends object\r\n    ? {\r\n        -readonly [K in keyof T]: (\r\n            T[K] extends object\r\n            ? DeepMutable<T[K]>\r\n            : T[K]\r\n        )\r\n    }\r\n    : never\r\n);\r\n\r\n/**\r\n * Can be used like 'keyof'\r\n * but only represents the string keys, not the Symbols or numbers.\r\n * @link https://stackoverflow.com/a/51808262/3443137\r\n */\r\nexport type StringKeys<X> = Extract<keyof X, string>;\r\n\r\nexport type AnyKeys<T> = { [P in keyof T]?: T[P] | any };\r\nexport interface AnyObject {\r\n    [k: string]: any;\r\n}\r\n\r\n/**\r\n * @link https://dev.to/vborodulin/ts-how-to-override-properties-with-type-intersection-554l\r\n */\r\nexport type Override<T1, T2> = Omit<T1, keyof T2> & T2;\r\n\r\n\r\n\r\nexport type ById<T> = {\r\n    [id: string]: T;\r\n};\r\n\r\n/**\r\n * Must be async to support async hashing like from the WebCrypto API.\r\n */\r\nexport type HashFunction = (input: string) => Promise<string>;\r\n\r\nexport declare type QueryMatcher<DocType> = (doc: DocType | DeepReadonly<DocType>) => boolean;\r\n\r\n/**\r\n * To have a deterministic sorting, we cannot return 0,\r\n * we only return 1 or -1.\r\n * This ensures that we always end with the same output array, no mather of the\r\n * pre-sorting of the input array.\r\n */\r\nexport declare type DeterministicSortComparator<DocType> = (a: DocType, b: DocType) => 1 | -1;\r\n\r\n/**\r\n * To test a storage, we need these\r\n * configuration values.\r\n */\r\nexport type RxTestStorage = {\r\n    // can be used to setup async stuff\r\n    readonly init?: () => any;\r\n    readonly name: string;\r\n    readonly getStorage: () => RxStorage<any, any>;\r\n    /**\r\n     * Returns a storage that is used in performance tests.\r\n     * For example in a browser it should return the storage with an IndexedDB based adapter,\r\n     * while in node.js it must use the filesystem.\r\n     */\r\n    readonly getPerformanceStorage: () => {\r\n        storage: RxStorage<any, any>;\r\n        /**\r\n         * A description that describes the storage and setting.\r\n         * For example 'dexie-native'.\r\n         */\r\n        description: string;\r\n    };\r\n    /**\r\n     * True if the storage is able to\r\n     * keep data after an instance is closed and opened again.\r\n     */\r\n    readonly hasPersistence: boolean;\r\n    readonly hasMultiInstance: boolean;\r\n    readonly hasAttachments: boolean;\r\n\r\n    /**\r\n     * Some storages likes the memory-synced storage,\r\n     * are not able to provide a replication while guaranteeing\r\n     * data integrity.\r\n     */\r\n    readonly hasReplication: boolean;\r\n\r\n    /**\r\n     * To make it possible to test alternative encryption plugins,\r\n     * you can specify hasEncryption to signal\r\n     * the test runner that the given storage already contains an\r\n     * encryption plugin that should be used to test encryption tests.\r\n     * Otherwise the encryption-crypto-js plugin will be tested.\r\n     *\r\n     * hasEncryption must contain a function that is able\r\n     * to create a new password.\r\n     */\r\n    readonly hasEncryption?: () => Promise<string>;\r\n};\r\n\r\n\r\n/**\r\n * The paths as strings-type of nested object\r\n * @link https://stackoverflow.com/a/58436959/3443137\r\n */\r\ntype Join<K, P> = K extends string | number ?\r\n    P extends string | number ?\r\n    `${K}${'' extends P ? '' : '.'}${P}`\r\n    : never : never;\r\n\r\nexport type Paths<T, D extends number = 10> = [D] extends [never] ? never : T extends object ?\r\n    { [K in keyof T]-?: K extends string | number ?\r\n        `${K}` | (Paths<T[K], Prev[D]> extends infer R ? Join<K, R> : never)\r\n        : never\r\n    }[keyof T] : '';\r\n\r\nexport type Leaves<T, D extends number = 10> = [D] extends [never] ? never : T extends object ?\r\n    { [K in keyof T]-?: Join<K, Leaves<T[K], Prev[D]>> }[keyof T] : '';\r\ntype Prev = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\r\n    11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...0[]];\r\n"],"mappings":"","ignoreList":[]}