{"version":3,"file":"replication-protocol.d.js","names":[],"sources":["../../../src/types/replication-protocol.d.ts"],"sourcesContent":["import { BehaviorSubject, Observable, Subject } from 'rxjs';\r\nimport type {\r\n    RxConflictHandler,\r\n    RxConflictHandlerInput\r\n} from './conflict-handling.d.ts';\r\nimport type { RxError, RxTypeError } from './rx-error.d.ts';\r\nimport type {\r\n    BulkWriteRow,\r\n    RxDocumentData,\r\n    WithDeleted,\r\n    WithDeletedAndAttachments\r\n} from './rx-storage.d.ts';\r\nimport type {\r\n    RxStorageInstance\r\n} from './rx-storage.interface.d.ts';\r\nimport type { HashFunction } from './util.d.ts';\r\n\r\nexport type RxStorageReplicationMeta<RxDocType, CheckpointType> = {\r\n\r\n    /**\r\n     * Combined primary key consisting\r\n     * of: [replicationId, itemId, isCheckpoint]\r\n     * so that the same RxStorageInstance\r\n     * can be used for multiple replication states.\r\n     */\r\n    id: string;\r\n\r\n    /**\r\n     * Either the document primaryKey\r\n     * or the id of the replication checkpoint.\r\n     */\r\n    itemId: string;\r\n\r\n    /**\r\n     * True if the doc data is about a checkpoint,\r\n     * False if it is about a document state from the master.\r\n     * Stored as a string so it can be used\r\n     * in the combined primary key 'id'\r\n     */\r\n    isCheckpoint: '0' | '1';\r\n    checkpointData?: CheckpointType;\r\n\r\n    /**\r\n     * the document state of the master\r\n     * only set if not checkpoint.\r\n     */\r\n    docData?: RxDocType | RxDocumentData<RxDocType> | any;\r\n    /**\r\n     * If the current assumed master was written while\r\n     * resolving a conflict, this field contains\r\n     * the revision of the conflict-solution that\r\n     * is stored in the forkInstance.\r\n     */\r\n    isResolvedConflict?: string;\r\n};\r\n\r\nexport type RxReplicationWriteToMasterRow<RxDocType> = {\r\n    assumedMasterState?: WithDeletedAndAttachments<RxDocType>;\r\n    newDocumentState: WithDeletedAndAttachments<RxDocType>;\r\n};\r\n\r\n\r\nexport type DocumentsWithCheckpoint<RxDocType, CheckpointType> = {\r\n    documents: WithDeletedAndAttachments<RxDocType>[];\r\n    checkpoint: CheckpointType;\r\n};\r\n\r\n\r\nexport type RxReplicationPullStreamItem<RxDocType, MasterCheckpointType> = DocumentsWithCheckpoint<RxDocType, MasterCheckpointType> |\r\n    /**\r\n         * Emit this when the masterChangeStream$ might have missed out\r\n         * some events because the fork lost the connection to the master.\r\n         * Like when the user went offline and reconnects.\r\n         */\r\n    'RESYNC';\r\n\r\n/**\r\n * The replication handler contains all logic\r\n * that is required by the replication protocol\r\n * to interact with the master instance.\r\n * This is an abstraction so that we can use different\r\n * handlers for GraphQL, REST or any other transportation layer.\r\n * Even a RxStorageInstance can be wrapped in a way to represent a replication handler.\r\n *\r\n * The RxStorage instance of the master branch that is\r\n * replicated with the fork branch.\r\n * The replication algorithm is made to make\r\n * as less writes on the master as possible.\r\n * The master instance is always 'the truth' which\r\n * does never contain conflicting document states.\r\n * All conflicts are handled on the fork branch\r\n * before being replicated to the master.\r\n */\r\nexport type RxReplicationHandler<RxDocType, MasterCheckpointType> = {\r\n    masterChangeStream$: Observable<RxReplicationPullStreamItem<RxDocType, MasterCheckpointType>>;\r\n    masterChangesSince(\r\n        checkpoint: MasterCheckpointType,\r\n        batchSize: number\r\n    ): Promise<DocumentsWithCheckpoint<RxDocType, MasterCheckpointType>>;\r\n    /**\r\n     * Writes the fork changes to the master.\r\n     * Only returns the conflicts if there are any.\r\n     * (otherwise returns an empty array.)\r\n     */\r\n    masterWrite(\r\n        rows: RxReplicationWriteToMasterRow<RxDocType>[]\r\n    ): Promise<WithDeleted<RxDocType>[]>;\r\n};\r\n\r\nexport type RxStorageInstanceReplicationInput<RxDocType> = {\r\n    /**\r\n     * A string that uniquely identifies\r\n     * the replication.\r\n     * Ensures that checkpoint are not\r\n     * mixed with other replications.\r\n     */\r\n    identifier: string;\r\n    pullBatchSize: number;\r\n    pushBatchSize: number;\r\n    replicationHandler: RxReplicationHandler<RxDocType, any>;\r\n    conflictHandler: RxConflictHandler<RxDocType>;\r\n\r\n    // can be set to also replicate the _meta field of the document.\r\n    keepMeta?: boolean;\r\n\r\n    /**\r\n     * The fork is the one that contains the forked chain of document writes.\r\n     * All conflicts are solved on the fork and only resolved correct document data\r\n     * is written back to the parent.\r\n     */\r\n    forkInstance: RxStorageInstance<RxDocType, any, any>;\r\n\r\n    /**\r\n     * The replication needs to store some meta data\r\n     * for documents to know which state is at the master\r\n     * and how/if it diverges from the fork.\r\n     * In the past this was stored in the _meta field of\r\n     * the forkInstance documents but that was not a good design decision\r\n     * because it required additional writes on the forkInstance\r\n     * to know which documents have been upstream replicated\r\n     * to not cause conflicts.\r\n     * Using the metaInstance instead leads to better overall performance\r\n     * because RxDB will not re-emit query results or document state\r\n     * when replication meta data is written.\r\n     *\r\n     * In addition to per-document meta data,\r\n     * the replication checkpoints are also stored in this instance.\r\n     *\r\n     */\r\n    metaInstance: RxStorageInstance<RxStorageReplicationMeta<RxDocType, any>, any, any>;\r\n\r\n    /**\r\n     * When a write happens to the fork,\r\n     * normally the replication will directly try to persist.\r\n     *\r\n     * For many use cases, it is better to await the next event loop tick\r\n     * or to wait until the RxDatabase is idle or requestIdleCallback() calls\r\n     * to ensure the CPU is idle.\r\n     * This can improve performance because the persistence will not affect UI\r\n     * renders.\r\n     *\r\n     * But: The longer you wait here, the higher is the risk of losing fork\r\n     * writes when the replication is closed unexpected.\r\n     */\r\n    waitBeforePersist?: () => Promise<any>;\r\n\r\n    hashFunction: HashFunction;\r\n\r\n    initialCheckpoint?: {\r\n        upstream?: any;\r\n        downstream?: any;\r\n    };\r\n};\r\n\r\nexport type RxStorageInstanceReplicationState<RxDocType> = {\r\n    // store the primaryPath here for better reuse and performance.\r\n    primaryPath: string;\r\n    hasAttachments: boolean;\r\n    input: RxStorageInstanceReplicationInput<RxDocType>;\r\n\r\n    events: {\r\n        /**\r\n         * Streams all document writes that have successfully\r\n         * been written in one direction.\r\n         */\r\n        processed: {\r\n            up: Subject<RxReplicationWriteToMasterRow<RxDocType>>;\r\n            down: Subject<BulkWriteRow<RxDocType>>;\r\n        };\r\n        resolvedConflicts: Subject<{\r\n            input: RxConflictHandlerInput<RxDocType>;\r\n            output: WithDeleted<RxDocType>;\r\n        }>;\r\n        /**\r\n         * Contains the cancel state.\r\n         * Emit true here to cancel the replication.\r\n         */\r\n        canceled: BehaviorSubject<boolean>;\r\n        /**\r\n         * Contains the pause state.\r\n         * Emit true here to pause the replication.\r\n         */\r\n        paused: BehaviorSubject<boolean>;\r\n        /**\r\n         * Contains true if the replication is doing something\r\n         * at this point in time.\r\n         * If this is false, it means that the replication\r\n         * is idle AND in sync.\r\n         */\r\n        active: {\r\n            [direction in RxStorageReplicationDirection]: BehaviorSubject<boolean>;\r\n        };\r\n        /**\r\n         * All errors that would otherwise be unhandled,\r\n         * get emitted here.\r\n         */\r\n        error: Subject<RxError | RxTypeError>;\r\n    };\r\n\r\n\r\n    /**\r\n     * Contains counters that can be used in tests\r\n     * or to debug problems.\r\n     */\r\n    stats: {\r\n        down: {\r\n            addNewTask: number;\r\n            downstreamResyncOnce: number;\r\n            downstreamProcessChanges: number;\r\n            masterChangeStreamEmit: number;\r\n            persistFromMaster: number;\r\n        };\r\n        up: {\r\n            upstreamInitialSync: number;\r\n            forkChangeStreamEmit: number;\r\n            processTasks: number;\r\n            persistToMaster: number;\r\n            persistToMasterHadConflicts: number;\r\n            persistToMasterConflictWrites: number;\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Used in checkpoints and ._meta fields\r\n     * to ensure we do not mix up meta data of\r\n     * different replications.\r\n     * We have to use the promise because the key is hashed which runs async.\r\n     */\r\n    checkpointKey: Promise<string>;\r\n\r\n    /**\r\n     * Storage.bulkWrites() that are initialized from the\r\n     * downstream, get this flag as context-param\r\n     * so that the emitted event bulk can be identified\r\n     * to be sourced from the downstream and it will not try\r\n     * to upstream these documents again.\r\n     */\r\n    downstreamBulkWriteFlag: Promise<string>;\r\n\r\n    /**\r\n     * Tracks if the streams have been in sync\r\n     * for at least one time.\r\n     */\r\n    firstSyncDone: {\r\n        [direction in RxStorageReplicationDirection]: BehaviorSubject<boolean>;\r\n    };\r\n\r\n    /**\r\n     * Can be used to detect if the replication is doing something\r\n     * or if it is in an idle state.\r\n     */\r\n    streamQueue: {\r\n        [direction in RxStorageReplicationDirection]: Promise<any>;\r\n    };\r\n\r\n    checkpointQueue: Promise<any>;\r\n\r\n    /**\r\n     * For better performance we store the last known checkpoint\r\n     * document so that we can likely do checkpoint storing without\r\n     * conflicts.\r\n     */\r\n    lastCheckpointDoc: {\r\n        [direction in RxStorageReplicationDirection]?: RxDocumentData<RxStorageReplicationMeta<RxDocType, any>>;\r\n    };\r\n};\r\n\r\nexport type RxStorageReplicationDirection = 'up' | 'down';\r\n"],"mappings":"","ignoreList":[]}