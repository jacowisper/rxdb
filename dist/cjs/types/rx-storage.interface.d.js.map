{"version":3,"file":"rx-storage.interface.d.js","names":[],"sources":["../../../src/types/rx-storage.interface.d.ts"],"sourcesContent":["import type {\r\n    BulkWriteRow,\r\n    EventBulk,\r\n    RxDocumentData,\r\n    RxStorageBulkWriteResponse,\r\n    RxStorageChangeEvent,\r\n    RxStorageCountResult,\r\n    RxStorageInstanceCreationParams,\r\n    RxStorageQueryResult\r\n} from './rx-storage.ts';\r\nimport type {\r\n    MangoQuerySelector,\r\n    MangoQuerySortPart,\r\n    RxJsonSchema,\r\n    RxQueryPlan\r\n} from './index.d.ts';\r\nimport type {\r\n    Observable\r\n} from 'rxjs';\r\n\r\n/**\r\n * RxStorage\r\n * This is an interface that abstracts the storage engine.\r\n * This allows us to use RxDB with different storage engines.\r\n *\r\n * @link https://rxdb.info/rx-storage.html\r\n * @link https://github.com/pubkey/rxdb/issues/1636\r\n */\r\n\r\n\r\n/**\r\n * A RxStorage is a module that acts\r\n * as a factory that can create multiple RxStorageInstance\r\n * objects.\r\n *\r\n * All data inputs and outputs of a StorageInstance must be plain json objects.\r\n * Do not use Map, Set or anything else that cannot be JSON.stringify-ed.\r\n * This will ensure that the storage can exchange data\r\n * when it is a WebWorker or a WASM process or data is send via BroadcastChannel.\r\n */\r\nexport interface RxStorage<Internals, InstanceCreationOptions> {\r\n    /**\r\n     * name of the storage engine\r\n     * used to detect if plugins do not work so we can throw proper errors.\r\n     */\r\n    readonly name: string;\r\n\r\n    /**\r\n     * RxDB version is part of the storage\r\n     * so we can have fallbacks and stuff when\r\n     * multiple storages with different version are in use\r\n     * like in the storage migration plugin.\r\n     */\r\n    readonly rxdbVersion: string;\r\n\r\n    /**\r\n     * Creates a storage instance\r\n     * that can contain the NoSQL documents of a collection.\r\n     */\r\n    createStorageInstance<RxDocType>(\r\n        params: RxStorageInstanceCreationParams<RxDocType, InstanceCreationOptions>\r\n    ): Promise<RxStorageInstance<RxDocType, Internals, InstanceCreationOptions>>;\r\n}\r\n\r\n\r\n/**\r\n * User provided mango queries will be filled up by RxDB via normalizeMangoQuery()\r\n * so we do not have to do many if-field-exist tests in the internals.\r\n */\r\nexport type FilledMangoQuery<RxDocType> = {\r\n    /**\r\n     * The selector is required here.\r\n     */\r\n    selector: MangoQuerySelector<RxDocumentData<RxDocType>>;\r\n\r\n    /**\r\n     * In contrast to the user-provided MangoQuery,\r\n     * the sorting is required here because\r\n     * RxDB has to ensure that the primary key is always\r\n     * part of the sort params.\r\n     */\r\n    sort: MangoQuerySortPart<RxDocumentData<RxDocType>>[];\r\n\r\n    /**\r\n     * In the normalized mango query,\r\n     * the index must always be a string[],\r\n     * never just a string.\r\n     * This makes it easier to use the query because\r\n     * we do not have to do an array check.\r\n     */\r\n    index?: string[];\r\n\r\n    /**\r\n     * Skip must be set which defaults to 0\r\n     */\r\n    skip: number;\r\n\r\n    limit?: number;\r\n};\r\n\r\n\r\n/**\r\n * Before sending a query to the storageInstance.query()\r\n * we run it through the query planner and do some normalization\r\n * stuff. Notice that the queryPlan is a hint for the storage and\r\n * it is not required to use it when running queries. Some storages\r\n * might use their own query planning instead.\r\n */\r\nexport type PreparedQuery<RxDocType> = {\r\n    // original query from the input\r\n    query: FilledMangoQuery<RxDocType>;\r\n    queryPlan: RxQueryPlan;\r\n};\r\n\r\nexport interface RxStorageInstance<\r\n    /**\r\n     * The type of the documents that can be stored in this instance.\r\n     * All documents in an instance must comply to the same schema.\r\n     * Also all documents are RxDocumentData with the meta properties like\r\n     * _deleted or _rev etc.\r\n     */\r\n    RxDocType,\r\n    Internals,\r\n    InstanceCreationOptions,\r\n    CheckpointType = any\r\n> {\r\n    readonly databaseName: string;\r\n    /**\r\n     * Returns the internal data that is used by the storage engine.\r\n     */\r\n    readonly internals: Readonly<Internals>;\r\n    readonly options: Readonly<InstanceCreationOptions>;\r\n    /**\r\n     * The schema that defines the documents that are stored in this instance.\r\n     * Notice that the schema must be enhanced with the meta properties like\r\n     * _meta, _rev and _deleted etc. which are added by fillWithDefaultSettings()\r\n     */\r\n    readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>;\r\n    readonly collectionName: string;\r\n\r\n    /**\r\n     * (Optional) reference to the underlying persistent storage instance.\r\n     * If set, things like replication will run on that storageInstance instead of the parent.\r\n     * This is mostly used in things like the memory-synced storage where we want to\r\n     * run replications and migrations on the persistent storage instead of the in-memory storage.\r\n     *\r\n     * Having this is the least hacky option. The only other option would be to toggle all calls to the\r\n     * storageInstance by checking the givent context-string. But this would make it impossible\r\n     * to run a replication on the parentStorage itself.\r\n     */\r\n    readonly underlyingPersistentStorage?: RxStorageInstance<RxDocType, any, any, any>;\r\n\r\n    /**\r\n     * Writes multiple documents to the storage instance.\r\n     * The write for each single document is atomic, there\r\n     * is no transaction around all documents.\r\n     * The written documents must be the newest revision of that documents data.\r\n     * If the previous document is not the current newest revision, a conflict error\r\n     * must be returned.\r\n     * It must be possible that some document writes succeed\r\n     * and others error. We need this to have a similar behavior as most NoSQL databases.\r\n     */\r\n    bulkWrite(\r\n        documentWrites: BulkWriteRow<RxDocType>[],\r\n        /**\r\n         * Context will be used in all\r\n         * changeStream()-events that are emitted as a result\r\n         * of that bulkWrite() operation.\r\n         * Used in plugins so that we can detect that event X\r\n         * comes from operation Y.\r\n         */\r\n        context: string\r\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>>;\r\n\r\n    /**\r\n     * Get Multiple documents by their primary value.\r\n     * This must also return deleted documents.\r\n     */\r\n    findDocumentsById(\r\n        /**\r\n         * List of primary values\r\n         * of the documents to find.\r\n         */\r\n        ids: string[],\r\n        /**\r\n         * If set to true, deleted documents will also be returned.\r\n         */\r\n        withDeleted: boolean\r\n\r\n    ): Promise<\r\n        /**\r\n         * For better performance, we return an array\r\n         * instead of an indexed object because most consumers\r\n         * of this anyway have to fill a Map() instance or\r\n         * even do only need the list at all.\r\n         */\r\n        RxDocumentData<RxDocType>[]\r\n    >;\r\n\r\n    /**\r\n     * Runs a NoSQL 'mango' query over the storage\r\n     * and returns the found documents data.\r\n     * Having all storage instances behave similar\r\n     * is likely the most difficult thing when creating a new\r\n     * rx-storage implementation.\r\n     */\r\n    query(\r\n        preparedQuery: PreparedQuery<RxDocType>\r\n    ): Promise<RxStorageQueryResult<RxDocType>>;\r\n\r\n    /**\r\n     * Returns the amount of non-deleted documents\r\n     * that match the given query.\r\n     * Sort, skip and limit of the query must be ignored!\r\n     */\r\n    count(\r\n        preparedQuery: PreparedQuery<RxDocType>\r\n    ): Promise<RxStorageCountResult>;\r\n\r\n    /**\r\n     * Returns the plain data of a single attachment.\r\n     */\r\n    getAttachmentData(\r\n        documentId: string,\r\n        attachmentId: string,\r\n        digest: string\r\n    ): Promise<string>;\r\n\r\n    /**\r\n     * Returns the current (not the old!) data of all documents that have been changed AFTER the given checkpoint.\r\n     * If the returned array does not reach the limit, it can be assumed that the \"end\" is reached, when paginating over the changes.\r\n     * Also returns a new checkpoint for each document which can be used to continue with the pagination from that change on.\r\n     * Must never return the same document multiple times in the same call operation.\r\n     * This is used by RxDB to known what has changed since X so these docs can be handled by the backup or the replication\r\n     * plugin.\r\n     *\r\n     * Important: This method is optional. If not defined,\r\n     * RxDB will manually run a query and use the last returned document\r\n     * for checkpointing. In  the future we might even remove this method completely\r\n     * and let RxDB do the work instead of the RxStorage.\r\n     */\r\n    getChangedDocumentsSince?(\r\n        limit: number,\r\n        /**\r\n         * The checkpoint from with to start\r\n         * when the events are sorted in time.\r\n         * If we want to start from the beginning,\r\n         * undefined is used as a checkpoint.\r\n         */\r\n        checkpoint?: CheckpointType\r\n    ): Promise<{\r\n        documents: RxDocumentData<RxDocType>[];\r\n        /**\r\n         * The checkpoint contains data so that another\r\n         * call to getChangedDocumentsSince() will continue\r\n         * from exactly the last document that was returned before.\r\n         */\r\n        checkpoint: CheckpointType;\r\n    }>;\r\n\r\n    /**\r\n     * Returns an ongoing stream\r\n     * of all changes that happen to the\r\n     * storage instance.\r\n     * Do not forget to unsubscribe.\r\n     *\r\n     * If the RxStorage support multi-instance,\r\n     * and the storage is persistent,\r\n     * then the emitted changes of one RxStorageInstance\r\n     * must be also emitted to other instances with the same databaseName+collectionName.\r\n     * See ./rx-storage-multiinstance.ts\r\n     */\r\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocType>, CheckpointType>>;\r\n\r\n    /**\r\n     * Runs a cleanup that removes all tompstones\r\n     * of documents that have _deleted set to true\r\n     * to free up disc space.\r\n     *\r\n     * Returns true if all cleanable documents have been removed.\r\n     * Returns false if there are more documents to be cleaned up,\r\n     * but not all have been purged because that would block the storage for too long.\r\n     */\r\n    cleanup(\r\n        /**\r\n         * The minimum time in milliseconds\r\n         * of how long a document must have been deleted\r\n         * until it is purged by the cleanup.\r\n         */\r\n        minimumDeletedTime: number\r\n    ): Promise<\r\n        /**\r\n         * True if all docs cleaned up,\r\n         * false if there are more docs to clean up\r\n         */\r\n        boolean\r\n    >;\r\n\r\n    /**\r\n     * Closes the storage instance so it cannot be used\r\n     * anymore and should clear all memory.\r\n     * The returned promise must resolve when everything is cleaned up.\r\n     */\r\n    close(): Promise<void>;\r\n\r\n    /**\r\n     * Remove the database and\r\n     * deletes all of its data.\r\n     */\r\n    remove(): Promise<void>;\r\n}\r\n"],"mappings":"","ignoreList":[]}