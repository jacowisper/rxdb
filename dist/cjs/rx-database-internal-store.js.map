{"version":3,"file":"rx-database-internal-store.js","names":["_rxError","require","_rxSchemaHelper","_rxStorageHelper","_index","_rxQueryHelper","INTERNAL_CONTEXT_COLLECTION","exports","INTERNAL_CONTEXT_STORAGE_TOKEN","INTERNAL_CONTEXT_MIGRATION_STATUS","INTERNAL_CONTEXT_PIPELINE_CHECKPOINT","INTERNAL_STORE_SCHEMA_TITLE","INTERNAL_STORE_SCHEMA","fillWithDefaultSettings","version","title","primaryKey","key","fields","separator","type","properties","id","maxLength","context","enum","data","additionalProperties","indexes","required","sharding","shards","mode","getPrimaryKeyOfInternalDocument","getComposedPrimaryKeyOfDocumentData","getAllCollectionDocuments","storageInstance","getAllQueryPrepared","prepareQuery","schema","selector","_deleted","$eq","sort","skip","queryResult","query","allDocs","documents","STORAGE_TOKEN_DOCUMENT_KEY","STORAGE_TOKEN_DOCUMENT_ID","ensureStorageTokenDocumentExists","rxDatabase","storageToken","randomToken","passwordHash","password","hashFunction","JSON","stringify","undefined","docData","rxdbVersion","token","instanceToken","_meta","getDefaultRxDocumentMeta","_rev","getDefaultRevision","_attachments","writeRows","document","writeResult","internalStore","bulkWrite","error","getWrittenDocumentsFromBulkWriteResponse","ensureNotFalsy","isError","isBulkWriteConflictError","conflictError","isDatabaseStateVersionCompatibleWithDatabaseCode","documentInDb","newRxError","args","database","name","databaseStateVersion","codeVersion","existingPasswordHash","storageTokenDocInDb","stateMajor","split","codeMajor","addConnectedStorageToCollection","collection","storageCollectionName","collectionNameWithVersion","_collectionNamePrimary","jsonSchema","collectionDocId","collectionDoc","getSingleDocument","saveData","clone","alreadyThere","connectedStorages","find","row","collectionName","push","writeSingle","previous","err","removeConnectedStorageFromCollection","isThere","filter","item"],"sources":["../../src/rx-database-internal-store.ts"],"sourcesContent":["import {\r\n    isBulkWriteConflictError,\r\n    newRxError\r\n} from './rx-error.ts';\r\nimport {\r\n    fillWithDefaultSettings,\r\n    getComposedPrimaryKeyOfDocumentData\r\n} from './rx-schema-helper.ts';\r\nimport { getSingleDocument, getWrittenDocumentsFromBulkWriteResponse, writeSingle } from './rx-storage-helper.ts';\r\nimport type {\r\n    CollectionsOfDatabase,\r\n    InternalStoreCollectionDocType,\r\n    InternalStoreDocType,\r\n    InternalStoreStorageTokenDocType,\r\n    RxCollection,\r\n    RxDatabase,\r\n    RxDocumentData,\r\n    RxJsonSchema,\r\n    RxStorageInstance,\r\n    RxStorageWriteErrorConflict\r\n} from './types/index.d.ts';\r\nimport {\r\n    clone,\r\n    ensureNotFalsy,\r\n    getDefaultRevision,\r\n    getDefaultRxDocumentMeta,\r\n    randomToken\r\n} from './plugins/utils/index.ts';\r\nimport { prepareQuery } from './rx-query-helper.ts';\r\n\r\nexport const INTERNAL_CONTEXT_COLLECTION = 'collection';\r\nexport const INTERNAL_CONTEXT_STORAGE_TOKEN = 'storage-token';\r\nexport const INTERNAL_CONTEXT_MIGRATION_STATUS = 'rx-migration-status';\r\nexport const INTERNAL_CONTEXT_PIPELINE_CHECKPOINT = 'rx-pipeline-checkpoint';\r\n\r\n/**\r\n * Do not change the title,\r\n * we have to flag the internal schema so that\r\n * some RxStorage implementations are able\r\n * to detect if the created RxStorageInstance\r\n * is from the internals or not,\r\n * to do some optimizations in some cases.\r\n */\r\nexport const INTERNAL_STORE_SCHEMA_TITLE = 'RxInternalDocument';\r\n\r\nexport const INTERNAL_STORE_SCHEMA: RxJsonSchema<RxDocumentData<InternalStoreDocType<any>>> = fillWithDefaultSettings({\r\n    version: 0,\r\n    title: INTERNAL_STORE_SCHEMA_TITLE,\r\n    primaryKey: {\r\n        key: 'id',\r\n        fields: [\r\n            'context',\r\n            'key'\r\n        ],\r\n        separator: '|'\r\n    },\r\n    type: 'object',\r\n    properties: {\r\n        id: {\r\n            type: 'string',\r\n            maxLength: 200\r\n        },\r\n        key: {\r\n            type: 'string'\r\n        },\r\n        context: {\r\n            type: 'string',\r\n            enum: [\r\n                INTERNAL_CONTEXT_COLLECTION,\r\n                INTERNAL_CONTEXT_STORAGE_TOKEN,\r\n                INTERNAL_CONTEXT_MIGRATION_STATUS,\r\n                INTERNAL_CONTEXT_PIPELINE_CHECKPOINT,\r\n                'OTHER'\r\n            ]\r\n        },\r\n        data: {\r\n            type: 'object',\r\n            additionalProperties: true\r\n        }\r\n    },\r\n    indexes: [],\r\n    required: [\r\n        'key',\r\n        'context',\r\n        'data'\r\n    ],\r\n    additionalProperties: false,\r\n    /**\r\n     * If the sharding plugin is used,\r\n     * it must not shard on the internal RxStorageInstance\r\n     * because that one anyway has only a small amount of documents\r\n     * and also its creation is in the hot path of the initial page load,\r\n     * so we should spend less time creating multiple RxStorageInstances.\r\n     */\r\n    sharding: {\r\n        shards: 1,\r\n        mode: 'collection'\r\n    }\r\n});\r\n\r\n\r\nexport function getPrimaryKeyOfInternalDocument(\r\n    key: string,\r\n    context: string\r\n): string {\r\n    return getComposedPrimaryKeyOfDocumentData<InternalStoreDocType>(\r\n        INTERNAL_STORE_SCHEMA,\r\n        {\r\n            key,\r\n            context\r\n        }\r\n    );\r\n}\r\n\r\n/**\r\n * Returns all internal documents\r\n * with context 'collection'\r\n */\r\nexport async function getAllCollectionDocuments(\r\n    storageInstance: RxStorageInstance<InternalStoreDocType<any>, any, any>\r\n): Promise<RxDocumentData<InternalStoreCollectionDocType>[]> {\r\n    const getAllQueryPrepared = prepareQuery<InternalStoreDocType<any>>(\r\n        storageInstance.schema,\r\n        {\r\n            selector: {\r\n                context: INTERNAL_CONTEXT_COLLECTION,\r\n                _deleted: {\r\n                    $eq: false\r\n                }\r\n            },\r\n            sort: [{ id: 'asc' }],\r\n            skip: 0\r\n        }\r\n    );\r\n    const queryResult = await storageInstance.query(getAllQueryPrepared);\r\n    const allDocs = queryResult.documents;\r\n    return allDocs;\r\n}\r\n\r\n/**\r\n * to not confuse multiInstance-messages with other databases that have the same\r\n * name and adapter, but do not share state with this one (for example in-memory-instances),\r\n * we set a storage-token and use it in the broadcast-channel\r\n */\r\nexport const STORAGE_TOKEN_DOCUMENT_KEY = 'storageToken';\r\n\r\nexport const STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(\r\n    STORAGE_TOKEN_DOCUMENT_KEY,\r\n    INTERNAL_CONTEXT_STORAGE_TOKEN\r\n);\r\n\r\nexport async function ensureStorageTokenDocumentExists<Collections extends CollectionsOfDatabase = any>(\r\n    rxDatabase: RxDatabase<Collections>\r\n): Promise<RxDocumentData<InternalStoreStorageTokenDocType>> {\r\n\r\n    /**\r\n     * To have less read-write cycles,\r\n     * we just try to insert a new document\r\n     * and only fetch the existing one if a conflict happened.\r\n     */\r\n    const storageToken = randomToken(10);\r\n\r\n    const passwordHash = rxDatabase.password ?\r\n        await rxDatabase.hashFunction(JSON.stringify(rxDatabase.password)) :\r\n        undefined;\r\n\r\n    const docData: RxDocumentData<InternalStoreStorageTokenDocType> = {\r\n        id: STORAGE_TOKEN_DOCUMENT_ID,\r\n        context: INTERNAL_CONTEXT_STORAGE_TOKEN,\r\n        key: STORAGE_TOKEN_DOCUMENT_KEY,\r\n        data: {\r\n            rxdbVersion: rxDatabase.rxdbVersion,\r\n            token: storageToken,\r\n            /**\r\n             * We add the instance token here\r\n             * to be able to detect if a given RxDatabase instance\r\n             * is the first instance that was ever created\r\n             * or if databases have existed earlier on that storage\r\n             * with the same database name.\r\n             */\r\n            instanceToken: rxDatabase.token,\r\n            passwordHash\r\n        },\r\n        _deleted: false,\r\n        _meta: getDefaultRxDocumentMeta(),\r\n        _rev: getDefaultRevision(),\r\n        _attachments: {}\r\n    };\r\n\r\n    const writeRows = [{ document: docData }];\r\n    const writeResult = await rxDatabase.internalStore.bulkWrite(\r\n        writeRows,\r\n        'internal-add-storage-token'\r\n    );\r\n    if (!writeResult.error[0]) {\r\n        return getWrittenDocumentsFromBulkWriteResponse(\r\n            'id',\r\n            writeRows,\r\n            writeResult\r\n        )[0];\r\n    }\r\n\r\n    /**\r\n     * If we get a 409 error,\r\n     * it means another instance already inserted the storage token.\r\n     * So we get that token from the database and return that one.\r\n     */\r\n    const error = ensureNotFalsy(writeResult.error[0]);\r\n    if (\r\n        error.isError &&\r\n        isBulkWriteConflictError(error)\r\n    ) {\r\n        const conflictError = (error as RxStorageWriteErrorConflict<InternalStoreStorageTokenDocType>);\r\n\r\n        if (\r\n            !isDatabaseStateVersionCompatibleWithDatabaseCode(\r\n                conflictError.documentInDb.data.rxdbVersion,\r\n                rxDatabase.rxdbVersion\r\n            )\r\n        ) {\r\n            throw newRxError('DM5', {\r\n                args: {\r\n                    database: rxDatabase.name,\r\n                    databaseStateVersion: conflictError.documentInDb.data.rxdbVersion,\r\n                    codeVersion: rxDatabase.rxdbVersion\r\n                }\r\n            });\r\n        }\r\n\r\n        if (\r\n            passwordHash &&\r\n            passwordHash !== conflictError.documentInDb.data.passwordHash\r\n        ) {\r\n            throw newRxError('DB1', {\r\n                passwordHash,\r\n                existingPasswordHash: conflictError.documentInDb.data.passwordHash\r\n            });\r\n        }\r\n\r\n        const storageTokenDocInDb = conflictError.documentInDb;\r\n        return ensureNotFalsy(storageTokenDocInDb);\r\n    }\r\n    throw error;\r\n}\r\n\r\n\r\nexport function isDatabaseStateVersionCompatibleWithDatabaseCode(\r\n    databaseStateVersion: string,\r\n    codeVersion: string\r\n): boolean {\r\n    if (!databaseStateVersion) {\r\n        return false;\r\n    }\r\n\r\n    const stateMajor = databaseStateVersion.split('.')[0];\r\n    const codeMajor = codeVersion.split('.')[0];\r\n\r\n    /**\r\n     * Version v15 data must be upwards compatible to v16\r\n     */\r\n    if (stateMajor === '15' && codeMajor === '16') {\r\n        return true;\r\n    }\r\n\r\n    if (stateMajor !== codeMajor) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n\r\n\r\n\r\nexport async function addConnectedStorageToCollection(\r\n    collection: RxCollection<any>,\r\n    storageCollectionName: string,\r\n    schema: RxJsonSchema<any>\r\n) {\r\n\r\n    if (collection.schema.version !== schema.version) {\r\n        throw newRxError('SNH', {\r\n            schema,\r\n            version: collection.schema.version,\r\n            name: collection.name,\r\n            collection,\r\n            args: {\r\n                storageCollectionName\r\n            }\r\n        });\r\n    }\r\n\r\n    const collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\r\n    const collectionDocId = getPrimaryKeyOfInternalDocument(\r\n        collectionNameWithVersion,\r\n        INTERNAL_CONTEXT_COLLECTION\r\n    );\r\n\r\n    while (true) {\r\n        const collectionDoc = await getSingleDocument(\r\n            collection.database.internalStore,\r\n            collectionDocId\r\n        );\r\n        const saveData: RxDocumentData<InternalStoreCollectionDocType> = clone(ensureNotFalsy(collectionDoc));\r\n\r\n        // do nothing if already in array\r\n        const alreadyThere = saveData.data.connectedStorages\r\n            .find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\r\n        if (alreadyThere) {\r\n            return;\r\n        }\r\n\r\n        // otherwise add to array and save\r\n        saveData.data.connectedStorages.push({\r\n            collectionName: storageCollectionName,\r\n            schema\r\n        });\r\n        try {\r\n            await writeSingle(\r\n                collection.database.internalStore,\r\n                {\r\n                    previous: ensureNotFalsy(collectionDoc),\r\n                    document: saveData\r\n                },\r\n                'add-connected-storage-to-collection'\r\n            );\r\n        } catch (err) {\r\n            if (!isBulkWriteConflictError(err)) {\r\n                throw err;\r\n            }\r\n            // retry on conflict\r\n        }\r\n    }\r\n}\r\n\r\nexport async function removeConnectedStorageFromCollection(\r\n    collection: RxCollection<any>,\r\n    storageCollectionName: string,\r\n    schema: RxJsonSchema<any>\r\n) {\r\n    if (collection.schema.version !== schema.version) {\r\n        throw newRxError('SNH', {\r\n            schema,\r\n            version: collection.schema.version,\r\n            name: collection.name,\r\n            collection,\r\n            args: {\r\n                storageCollectionName\r\n            }\r\n        });\r\n    }\r\n\r\n    const collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\r\n    const collectionDocId = getPrimaryKeyOfInternalDocument(\r\n        collectionNameWithVersion,\r\n        INTERNAL_CONTEXT_COLLECTION\r\n    );\r\n\r\n    while (true) {\r\n        const collectionDoc = await getSingleDocument(\r\n            collection.database.internalStore,\r\n            collectionDocId\r\n        );\r\n        const saveData: RxDocumentData<InternalStoreCollectionDocType> = clone(ensureNotFalsy(collectionDoc));\r\n\r\n        // do nothing if not there\r\n        const isThere = saveData.data.connectedStorages\r\n            .find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\r\n        if (!isThere) {\r\n            return;\r\n        }\r\n\r\n        // otherwise remove from array and save\r\n        saveData.data.connectedStorages = saveData.data.connectedStorages.filter(item => item.collectionName !== storageCollectionName);\r\n        try {\r\n            await writeSingle(\r\n                collection.database.internalStore,\r\n                {\r\n                    previous: ensureNotFalsy(collectionDoc),\r\n                    document: saveData\r\n                },\r\n                'remove-connected-storage-from-collection'\r\n            );\r\n        } catch (err) {\r\n            if (!isBulkWriteConflictError(err)) {\r\n                throw err;\r\n            }\r\n            // retry on conflict\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * returns the primary for a given collection-data\r\n * used in the internal store of a RxDatabase\r\n */\r\nexport function _collectionNamePrimary(name: string, schema: RxJsonSchema<any>) {\r\n    return name + '-' + schema.version;\r\n}\r\n"],"mappings":"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","ignoreList":[]}