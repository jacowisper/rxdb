{"version":3,"file":"query-cache.js","names":["_index","require","QueryCache","exports","_map","Map","_proto","prototype","getByQuery","rxQuery","stringRep","toString","ret","getFromMapOrCreate","createQueryCache","uncacheRxQuery","queryCache","uncached","delete","countRxQuerySubscribers","refCount$","observers","length","DEFAULT_TRY_TO_KEEP_MAX","DEFAULT_UNEXECUTED_LIFETIME","defaultCacheReplacementPolicyMonad","tryToKeepMax","unExecutedLifetime","_collection","size","minUnExecutedLifetime","now","maybeUncache","queriesInCache","Array","from","values","_lastEnsureEqual","_creationTime","push","mustUncache","sortedByLastUsage","sort","a","b","toRemove","slice","forEach","defaultCacheReplacementPolicy","COLLECTIONS_WITH_RUNNING_CLEANUP","WeakSet","triggerCacheReplacement","rxCollection","has","add","nextTick","then","requestIdlePromise","closed","cacheReplacementPolicy","_queryCache"],"sources":["../../src/query-cache.ts"],"sourcesContent":["/**\r\n * the query-cache makes sure that on every query-state, exactly one instance can exist\r\n * if you use the same mango-query more then once, it will reuse the first RxQuery\r\n */\r\nimport type {\r\n    RxQuery,\r\n    RxCacheReplacementPolicy,\r\n    RxCollection\r\n} from './types/index.d.ts';\r\nimport {\r\n    getFromMapOrCreate,\r\n    nextTick,\r\n    now,\r\n    requestIdlePromise\r\n} from './plugins/utils/index.ts';\r\n\r\nexport class QueryCache {\r\n    public _map: Map<string, RxQuery> = new Map();\r\n\r\n    /**\r\n     * check if an equal query is in the cache,\r\n     * if true, return the cached one,\r\n     * if false, save the given one and return it\r\n     */\r\n    getByQuery(rxQuery: RxQuery): RxQuery {\r\n        const stringRep = rxQuery.toString();\r\n        const ret = getFromMapOrCreate(\r\n            this._map,\r\n            stringRep,\r\n            () => rxQuery\r\n        );\r\n        return ret;\r\n    }\r\n}\r\n\r\nexport function createQueryCache() {\r\n    return new QueryCache();\r\n}\r\n\r\n\r\nexport function uncacheRxQuery(queryCache: QueryCache, rxQuery: RxQuery) {\r\n    rxQuery.uncached = true;\r\n    const stringRep = rxQuery.toString();\r\n    queryCache._map.delete(stringRep);\r\n\r\n}\r\n\r\n\r\nexport function countRxQuerySubscribers(rxQuery: RxQuery): number {\r\n    return rxQuery.refCount$.observers.length;\r\n}\r\n\r\n\r\nexport const DEFAULT_TRY_TO_KEEP_MAX = 100;\r\nexport const DEFAULT_UNEXECUTED_LIFETIME = 30 * 1000;\r\n\r\n/**\r\n * The default cache replacement policy\r\n * See docs-src/query-cache.md to learn how it should work.\r\n * Notice that this runs often and should block the cpu as less as possible\r\n * This is a monad which makes it easier to unit test\r\n */\r\nexport const defaultCacheReplacementPolicyMonad: (\r\n    tryToKeepMax: number,\r\n    unExecutedLifetime: number\r\n) => RxCacheReplacementPolicy = (\r\n    tryToKeepMax,\r\n    unExecutedLifetime\r\n) => (\r\n    _collection: RxCollection,\r\n    queryCache: QueryCache\r\n) => {\r\n            if (queryCache._map.size < tryToKeepMax) {\r\n                return;\r\n            }\r\n\r\n            const minUnExecutedLifetime = now() - unExecutedLifetime;\r\n            const maybeUncache: RxQuery[] = [];\r\n\r\n            const queriesInCache = Array.from(queryCache._map.values());\r\n            for (const rxQuery of queriesInCache) {\r\n                // filter out queries with subscribers\r\n                if (countRxQuerySubscribers(rxQuery) > 0) {\r\n                    continue;\r\n                }\r\n                // directly uncache queries that never executed and are older than unExecutedLifetime\r\n                if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {\r\n                    uncacheRxQuery(queryCache, rxQuery);\r\n                    continue;\r\n                }\r\n                maybeUncache.push(rxQuery);\r\n            }\r\n\r\n            const mustUncache = maybeUncache.length - tryToKeepMax;\r\n            if (mustUncache <= 0) {\r\n                return;\r\n            }\r\n\r\n            const sortedByLastUsage = maybeUncache.sort((a, b) => a._lastEnsureEqual - b._lastEnsureEqual);\r\n            const toRemove = sortedByLastUsage.slice(0, mustUncache);\r\n            toRemove.forEach(rxQuery => uncacheRxQuery(queryCache, rxQuery));\r\n        };\r\n\r\n\r\nexport const defaultCacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(\r\n    DEFAULT_TRY_TO_KEEP_MAX,\r\n    DEFAULT_UNEXECUTED_LIFETIME\r\n);\r\n\r\nexport const COLLECTIONS_WITH_RUNNING_CLEANUP: WeakSet<RxCollection> = new WeakSet();\r\n\r\n/**\r\n * Triggers the cache replacement policy after waitTime has passed.\r\n * We do not run this directly because at exactly the time a query is created,\r\n * we need all CPU to minimize latency.\r\n * Also this should not be triggered multiple times when waitTime is still waiting.\r\n */\r\nexport function triggerCacheReplacement(\r\n    rxCollection: RxCollection\r\n) {\r\n    if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {\r\n        // already started\r\n        return;\r\n    }\r\n\r\n    COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);\r\n\r\n    /**\r\n     * Do not run directly to not reduce result latency of a new query\r\n     */\r\n    nextTick() // wait at least one tick\r\n        .then(() => requestIdlePromise(200)) // and then wait for the CPU to be idle\r\n        .then(() => {\r\n            if (!rxCollection.closed) {\r\n                rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);\r\n            }\r\n            COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);\r\n        });\r\n}\r\n"],"mappings":"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","ignoreList":[]}