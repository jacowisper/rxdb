{"version":3,"file":"downstream.js","names":["_rxjs","require","_rxError","_rxStorageHelper","_index","_checkpoint","_helper","_metaInstance","startReplicationDownstream","state","input","initialCheckpoint","downstream","checkpointDoc","getLastCheckpointDoc","setCheckpoint","identifierHash","hashFunction","identifier","replicationHandler","timer","openTasks","addNewTask","task","stats","down","taskWithTime","time","push","streamQueue","then","useTasks","length","events","active","next","innerTaskWithTime","ensureNotFalsy","shift","lastTimeMasterChangesRequested","downstreamResyncOnce","downstreamProcessChanges","firstSyncDone","getValue","canceled","sub","masterChangeStream$","pipe","mergeMap","ev","firstValueFrom","up","filter","s","subscribe","masterChangeStreamEmit","unsubscribe","checkpointQueue","lastCheckpoint","promises","downResult","masterChangesSince","pullBatchSize","documents","stackCheckpoints","checkpoint","persistFromMaster","Promise","all","tasks","docsOfAllTasks","forEach","Error","appendToArray","persistenceQueue","PROMISE_RESOLVE_VOID","nonPersistedFromMaster","docs","primaryPath","docData","docId","downDocsById","useCheckpoint","docIds","Object","keys","writeRowsToFork","writeRowsToForkById","writeRowsToMeta","useMetaWriteRows","forkInstance","findDocumentsById","getAssumedMasterState","currentForkStateList","assumedMasterState","currentForkState","Map","doc","set","map","forkStateFullDoc","get","forkStateDocData","writeDocToDocState","hasAttachments","undefined","masterState","assumedMaster","metaDocument","isResolvedConflict","_rev","isAssumedMasterEqualToForkState","conflictHandler","isEqual","_meta","getHeightOfRevision","areStatesExactlyEqual","getMetaWriteRow","newForkState","assign","flatClone","_attachments","getDefaultRevision","lwt","now","nextRevisionHeight","keepMeta","forkWriteRow","previous","document","createRevision","bulkWrite","downstreamBulkWriteFlag","forkWriteResult","success","getWrittenDocumentsFromBulkWriteResponse","processed","mustThrow","error","status","throwMe","newRxError","writeError","metaInstance","stripAttachmentsDataFromMetaWriteRows","metaWriteResult","id","documentId","catch","unhandledError"],"sources":["../../../src/replication-protocol/downstream.ts"],"sourcesContent":["import {\r\n    firstValueFrom,\r\n    filter,\r\n    mergeMap\r\n} from 'rxjs';\r\nimport { newRxError } from '../rx-error.ts';\r\nimport { getWrittenDocumentsFromBulkWriteResponse, stackCheckpoints } from '../rx-storage-helper.ts';\r\nimport type {\r\n    RxStorageInstanceReplicationState,\r\n    BulkWriteRow,\r\n    BulkWriteRowById,\r\n    RxStorageReplicationMeta,\r\n    RxDocumentData,\r\n    ById,\r\n    WithDeleted,\r\n    DocumentsWithCheckpoint,\r\n    WithDeletedAndAttachments,\r\n    RxError\r\n} from '../types/index.d.ts';\r\nimport {\r\n    appendToArray,\r\n    createRevision,\r\n    ensureNotFalsy,\r\n    flatClone,\r\n    getDefaultRevision,\r\n    getHeightOfRevision,\r\n    now,\r\n    PROMISE_RESOLVE_VOID\r\n} from '../plugins/utils/index.ts';\r\nimport {\r\n    getLastCheckpointDoc,\r\n    setCheckpoint\r\n} from './checkpoint.ts';\r\nimport {\r\n    stripAttachmentsDataFromMetaWriteRows,\r\n    writeDocToDocState\r\n} from './helper.ts';\r\nimport {\r\n    getAssumedMasterState,\r\n    getMetaWriteRow\r\n} from './meta-instance.ts';\r\n\r\n/**\r\n * Writes all documents from the master to the fork.\r\n * The downstream has two operation modes\r\n * - Sync by iterating over the checkpoints via downstreamResyncOnce()\r\n * - Sync by listening to the changestream via downstreamProcessChanges()\r\n * We need this to be able to do initial syncs\r\n * and still can have fast event based sync when the client is not offline.\r\n */\r\nexport async function startReplicationDownstream<RxDocType, CheckpointType = any>(\r\n    state: RxStorageInstanceReplicationState<RxDocType>\r\n) {\r\n    if (\r\n        state.input.initialCheckpoint &&\r\n        state.input.initialCheckpoint.downstream\r\n    ) {\r\n        const checkpointDoc = await getLastCheckpointDoc(state, 'down');\r\n        if (!checkpointDoc) {\r\n            await setCheckpoint(\r\n                state,\r\n                'down',\r\n                state.input.initialCheckpoint.downstream\r\n            );\r\n        }\r\n    }\r\n\r\n    const identifierHash = await state.input.hashFunction(state.input.identifier);\r\n    const replicationHandler = state.input.replicationHandler;\r\n\r\n    // used to detect which tasks etc can in it at which order.\r\n    let timer = 0;\r\n\r\n\r\n    type Task = DocumentsWithCheckpoint<RxDocType, any> | 'RESYNC';\r\n    type TaskWithTime = {\r\n        time: number;\r\n        task: Task;\r\n    };\r\n    const openTasks: TaskWithTime[] = [];\r\n\r\n\r\n    function addNewTask(task: Task): void {\r\n        state.stats.down.addNewTask = state.stats.down.addNewTask + 1;\r\n        const taskWithTime = {\r\n            time: timer++,\r\n            task\r\n        };\r\n        openTasks.push(taskWithTime);\r\n        state.streamQueue.down = state.streamQueue.down\r\n            .then(() => {\r\n                const useTasks: Task[] = [];\r\n                while (openTasks.length > 0) {\r\n                    state.events.active.down.next(true);\r\n                    const innerTaskWithTime = ensureNotFalsy(openTasks.shift());\r\n\r\n                    /**\r\n                     * If the task came in before the last time we started the pull\r\n                     * from the master, then we can drop the task.\r\n                     */\r\n                    if (innerTaskWithTime.time < lastTimeMasterChangesRequested) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (innerTaskWithTime.task === 'RESYNC') {\r\n                        if (useTasks.length === 0) {\r\n                            useTasks.push(innerTaskWithTime.task);\r\n                            break;\r\n                        } else {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    useTasks.push(innerTaskWithTime.task);\r\n                }\r\n                if (useTasks.length === 0) {\r\n                    return;\r\n                }\r\n\r\n                if (useTasks[0] === 'RESYNC') {\r\n                    return downstreamResyncOnce();\r\n                } else {\r\n                    return downstreamProcessChanges(useTasks);\r\n                }\r\n            }).then(() => {\r\n                state.events.active.down.next(false);\r\n                if (\r\n                    !state.firstSyncDone.down.getValue() &&\r\n                    !state.events.canceled.getValue()\r\n                ) {\r\n                    state.firstSyncDone.down.next(true);\r\n                }\r\n            });\r\n    }\r\n    addNewTask('RESYNC');\r\n\r\n    /**\r\n     * If a write on the master happens, we have to trigger the downstream.\r\n     * Only do this if not canceled yet, otherwise firstValueFrom errors\r\n     * when running on a completed observable.\r\n     */\r\n    if (!state.events.canceled.getValue()) {\r\n        const sub = replicationHandler\r\n            .masterChangeStream$\r\n            .pipe(\r\n                mergeMap(async (ev) => {\r\n                    /**\r\n                     * While a push is running, we have to delay all incoming\r\n                     * events from the server to not mix up the replication state.\r\n                     */\r\n                    await firstValueFrom(\r\n                        state.events.active.up.pipe(filter(s => !s))\r\n                    );\r\n                    return ev;\r\n                })\r\n            )\r\n            .subscribe((task: Task) => {\r\n                state.stats.down.masterChangeStreamEmit = state.stats.down.masterChangeStreamEmit + 1;\r\n                addNewTask(task);\r\n            });\r\n        // unsubscribe when replication is canceled\r\n        firstValueFrom(\r\n            state.events.canceled.pipe(\r\n                filter(canceled => !!canceled)\r\n            )\r\n        ).then(() => sub.unsubscribe());\r\n    }\r\n\r\n\r\n    /**\r\n     * For faster performance, we directly start each write\r\n     * and then await all writes at the end.\r\n     */\r\n    let lastTimeMasterChangesRequested: number = -1;\r\n    async function downstreamResyncOnce() {\r\n        state.stats.down.downstreamResyncOnce = state.stats.down.downstreamResyncOnce + 1;\r\n        if (state.events.canceled.getValue()) {\r\n            return;\r\n        }\r\n\r\n        state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'down'));\r\n        let lastCheckpoint: CheckpointType = await state.checkpointQueue;\r\n\r\n\r\n        const promises: Promise<any>[] = [];\r\n        while (!state.events.canceled.getValue()) {\r\n            lastTimeMasterChangesRequested = timer++;\r\n            const downResult = await replicationHandler.masterChangesSince(\r\n                lastCheckpoint,\r\n                state.input.pullBatchSize\r\n            );\r\n\r\n            if (downResult.documents.length === 0) {\r\n                break;\r\n            }\r\n\r\n            lastCheckpoint = stackCheckpoints([lastCheckpoint, downResult.checkpoint]);\r\n\r\n            promises.push(\r\n                persistFromMaster(\r\n                    downResult.documents,\r\n                    lastCheckpoint\r\n                )\r\n            );\r\n\r\n            /**\r\n             * By definition we stop pull when the pulled documents\r\n             * do not fill up the pullBatchSize because we\r\n             * can assume that the remote has no more documents.\r\n             */\r\n            if (downResult.documents.length < state.input.pullBatchSize) {\r\n                break;\r\n            }\r\n\r\n        }\r\n        await Promise.all(promises);\r\n    }\r\n\r\n\r\n    function downstreamProcessChanges(tasks: Task[]) {\r\n        state.stats.down.downstreamProcessChanges = state.stats.down.downstreamProcessChanges + 1;\r\n        const docsOfAllTasks: WithDeleted<RxDocType>[] = [];\r\n        let lastCheckpoint: CheckpointType | undefined = null as any;\r\n\r\n        tasks.forEach(task => {\r\n            if (task === 'RESYNC') {\r\n                throw new Error('SNH');\r\n            }\r\n            appendToArray(docsOfAllTasks, task.documents);\r\n            lastCheckpoint = stackCheckpoints([lastCheckpoint, task.checkpoint]);\r\n        });\r\n        return persistFromMaster(\r\n            docsOfAllTasks,\r\n            ensureNotFalsy(lastCheckpoint)\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n     * It can happen that the calls to masterChangesSince() or the changeStream()\r\n     * are way faster then how fast the documents can be persisted.\r\n     * Therefore we merge all incoming downResults into the nonPersistedFromMaster object\r\n     * and process them together if possible.\r\n     * This often bundles up single writes and improves performance\r\n     * by processing the documents in bulks.\r\n     */\r\n    let persistenceQueue = PROMISE_RESOLVE_VOID;\r\n    const nonPersistedFromMaster: {\r\n        checkpoint?: CheckpointType;\r\n        docs: ById<WithDeleted<RxDocType>>;\r\n    } = {\r\n        docs: {}\r\n    };\r\n\r\n    function persistFromMaster(\r\n        docs: WithDeleted<RxDocType>[],\r\n        checkpoint: CheckpointType\r\n    ): Promise<void> {\r\n        const primaryPath = state.primaryPath;\r\n        state.stats.down.persistFromMaster = state.stats.down.persistFromMaster + 1;\r\n\r\n        /**\r\n         * Add the new docs to the non-persistent list\r\n         */\r\n        docs.forEach(docData => {\r\n            const docId: string = (docData as any)[primaryPath];\r\n            nonPersistedFromMaster.docs[docId] = docData;\r\n        });\r\n        nonPersistedFromMaster.checkpoint = checkpoint;\r\n\r\n        /**\r\n         * Run in the queue\r\n         * with all open documents from nonPersistedFromMaster.\r\n         */\r\n        persistenceQueue = persistenceQueue.then(() => {\r\n\r\n            const downDocsById: ById<WithDeletedAndAttachments<RxDocType>> = nonPersistedFromMaster.docs;\r\n            nonPersistedFromMaster.docs = {};\r\n            const useCheckpoint = nonPersistedFromMaster.checkpoint;\r\n            const docIds = Object.keys(downDocsById);\r\n\r\n            if (\r\n                state.events.canceled.getValue() ||\r\n                docIds.length === 0\r\n            ) {\r\n                return PROMISE_RESOLVE_VOID;\r\n            }\r\n\r\n            const writeRowsToFork: BulkWriteRow<RxDocType>[] = [];\r\n            const writeRowsToForkById: ById<BulkWriteRow<RxDocType>> = {};\r\n            const writeRowsToMeta: BulkWriteRowById<RxStorageReplicationMeta<RxDocType, CheckpointType>> = {};\r\n            const useMetaWriteRows: BulkWriteRow<RxStorageReplicationMeta<RxDocType, CheckpointType>>[] = [];\r\n\r\n            return Promise.all([\r\n                state.input.forkInstance.findDocumentsById(docIds, true),\r\n                getAssumedMasterState(\r\n                    state,\r\n                    docIds\r\n                )\r\n            ]).then(([\r\n                currentForkStateList,\r\n                assumedMasterState\r\n            ]) => {\r\n                const currentForkState = new Map<string, RxDocumentData<RxDocType>>();\r\n                currentForkStateList.forEach(doc => currentForkState.set((doc as any)[primaryPath], doc));\r\n                return Promise.all(\r\n                    docIds.map(async (docId) => {\r\n                        const forkStateFullDoc: RxDocumentData<RxDocType> | undefined = currentForkState.get(docId);\r\n                        const forkStateDocData: WithDeletedAndAttachments<RxDocType> | undefined = forkStateFullDoc\r\n                            ? writeDocToDocState(forkStateFullDoc, state.hasAttachments, false)\r\n                            : undefined\r\n                            ;\r\n                        const masterState = downDocsById[docId];\r\n                        const assumedMaster = assumedMasterState[docId];\r\n\r\n                        if (\r\n                            assumedMaster &&\r\n                            forkStateFullDoc &&\r\n                            assumedMaster.metaDocument.isResolvedConflict === forkStateFullDoc._rev\r\n                        ) {\r\n                            /**\r\n                             * The current fork state represents a resolved conflict\r\n                             * that first must be send to the master in the upstream.\r\n                             * All conflicts are resolved by the upstream.\r\n                             */\r\n                            // return PROMISE_RESOLVE_VOID;\r\n                            await state.streamQueue.up;\r\n                        }\r\n\r\n                        let isAssumedMasterEqualToForkState = !assumedMaster || !forkStateDocData ?\r\n                            false :\r\n                            state.input.conflictHandler.isEqual(\r\n                                assumedMaster.docData,\r\n                                forkStateDocData,\r\n                                'downstream-check-if-equal-0'\r\n                            );\r\n                        if (\r\n                            !isAssumedMasterEqualToForkState &&\r\n                            (\r\n                                assumedMaster &&\r\n                                (assumedMaster.docData as any)._rev &&\r\n                                forkStateFullDoc &&\r\n                                forkStateFullDoc._meta[state.input.identifier] &&\r\n                                getHeightOfRevision(forkStateFullDoc._rev) === forkStateFullDoc._meta[state.input.identifier]\r\n                            )\r\n                        ) {\r\n                            isAssumedMasterEqualToForkState = true;\r\n                        }\r\n                        if (\r\n                            (\r\n                                forkStateFullDoc &&\r\n                                assumedMaster &&\r\n                                isAssumedMasterEqualToForkState === false\r\n                            ) ||\r\n                            (\r\n                                forkStateFullDoc && !assumedMaster\r\n                            )\r\n                        ) {\r\n                            /**\r\n                             * We have a non-upstream-replicated\r\n                             * local write to the fork.\r\n                             * This means we ignore the downstream of this document\r\n                             * because anyway the upstream will first resolve the conflict.\r\n                             */\r\n                            return PROMISE_RESOLVE_VOID;\r\n                        }\r\n\r\n                        const areStatesExactlyEqual = !forkStateDocData\r\n                            ? false\r\n                            : state.input.conflictHandler.isEqual(\r\n                                masterState,\r\n                                forkStateDocData,\r\n                                'downstream-check-if-equal-1'\r\n                            );\r\n                        if (\r\n                            forkStateDocData &&\r\n                            areStatesExactlyEqual\r\n                        ) {\r\n                            /**\r\n                             * Document states are exactly equal.\r\n                             * This can happen when the replication is shut down\r\n                             * unexpected like when the user goes offline.\r\n                             *\r\n                             * Only when the assumedMaster is different from the forkState,\r\n                             * we have to patch the document in the meta instance.\r\n                             */\r\n                            if (\r\n                                !assumedMaster ||\r\n                                isAssumedMasterEqualToForkState === false\r\n                            ) {\r\n                                useMetaWriteRows.push(\r\n                                    await getMetaWriteRow(\r\n                                        state,\r\n                                        forkStateDocData,\r\n                                        assumedMaster ? assumedMaster.metaDocument : undefined\r\n                                    )\r\n                                );\r\n                            }\r\n                            return PROMISE_RESOLVE_VOID;\r\n                        }\r\n\r\n                        /**\r\n                         * All other master states need to be written to the forkInstance\r\n                         * and metaInstance.\r\n                         */\r\n                        const newForkState = Object.assign(\r\n                            {},\r\n                            masterState,\r\n                            forkStateFullDoc ? {\r\n                                _meta: flatClone(forkStateFullDoc._meta),\r\n                                _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {},\r\n                                _rev: getDefaultRevision()\r\n                            } : {\r\n                                _meta: {\r\n                                    lwt: now()\r\n                                },\r\n                                _rev: getDefaultRevision(),\r\n                                _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {}\r\n                            }\r\n                        );\r\n                        /**\r\n                         * If the remote works with revisions,\r\n                         * we store the height of the next fork-state revision\r\n                         * inside of the documents meta data.\r\n                         * By doing so we can filter it out in the upstream\r\n                         * and detect the document as being equal to master or not.\r\n                         * This is used for example in the CouchDB replication plugin.\r\n                         */\r\n                        if ((masterState as any)._rev) {\r\n                            const nextRevisionHeight = !forkStateFullDoc ? 1 : getHeightOfRevision(forkStateFullDoc._rev) + 1;\r\n                            newForkState._meta[state.input.identifier] = nextRevisionHeight;\r\n                            if (state.input.keepMeta) {\r\n                                newForkState._rev = (masterState as any)._rev;\r\n                            }\r\n                        }\r\n                        if (\r\n                            state.input.keepMeta &&\r\n                            (masterState as any)._meta\r\n                        ) {\r\n                            newForkState._meta = (masterState as any)._meta;\r\n                        }\r\n\r\n                        const forkWriteRow = {\r\n                            previous: forkStateFullDoc,\r\n                            document: newForkState\r\n                        };\r\n\r\n                        forkWriteRow.document._rev = forkWriteRow.document._rev ? forkWriteRow.document._rev : createRevision(\r\n                            identifierHash,\r\n                            forkWriteRow.previous\r\n                        );\r\n                        writeRowsToFork.push(forkWriteRow);\r\n                        writeRowsToForkById[docId] = forkWriteRow;\r\n                        writeRowsToMeta[docId] = await getMetaWriteRow(\r\n                            state,\r\n                            masterState,\r\n                            assumedMaster ? assumedMaster.metaDocument : undefined\r\n                        );\r\n                    })\r\n                );\r\n            }).then(async () => {\r\n                if (writeRowsToFork.length > 0) {\r\n                    return state.input.forkInstance.bulkWrite(\r\n                        writeRowsToFork,\r\n                        await state.downstreamBulkWriteFlag\r\n                    ).then((forkWriteResult) => {\r\n                        const success = getWrittenDocumentsFromBulkWriteResponse(\r\n                            state.primaryPath,\r\n                            writeRowsToFork,\r\n                            forkWriteResult\r\n                        );\r\n                        success.forEach(doc => {\r\n                            const docId = (doc as any)[primaryPath];\r\n                            state.events.processed.down.next(writeRowsToForkById[docId]);\r\n                            useMetaWriteRows.push(writeRowsToMeta[docId]);\r\n                        });\r\n                        let mustThrow: RxError | undefined;\r\n                        forkWriteResult.error.forEach(error => {\r\n                            /**\r\n                             * We do not have to care about downstream conflict errors here\r\n                             * because on conflict, it will be solved locally and result in another write.\r\n                             */\r\n                            if (error.status === 409) {\r\n                                return;\r\n                            }\r\n                            // other non-conflict errors must be handled\r\n                            const throwMe = newRxError('RC_PULL', {\r\n                                writeError: error\r\n                            });\r\n                            state.events.error.next(throwMe);\r\n                            mustThrow = throwMe;\r\n                        });\r\n                        if (mustThrow) {\r\n                            throw mustThrow;\r\n                        }\r\n                    });\r\n                }\r\n            }).then(() => {\r\n                if (useMetaWriteRows.length > 0) {\r\n                    return state.input.metaInstance.bulkWrite(\r\n                        stripAttachmentsDataFromMetaWriteRows(state, useMetaWriteRows),\r\n                        'replication-down-write-meta'\r\n                    ).then(metaWriteResult => {\r\n                        metaWriteResult.error\r\n                            .forEach(writeError => {\r\n                                state.events.error.next(newRxError('RC_PULL', {\r\n                                    id: writeError.documentId,\r\n                                    writeError\r\n                                }));\r\n                            });\r\n                    });\r\n                }\r\n            }).then(() => {\r\n                /**\r\n                 * For better performance we do not await checkpoint writes,\r\n                 * but to ensure order on parallel checkpoint writes,\r\n                 * we have to use a queue.\r\n                 */\r\n                setCheckpoint(\r\n                    state,\r\n                    'down',\r\n                    useCheckpoint\r\n                );\r\n            });\r\n        }).catch(unhandledError => state.events.error.next(unhandledError));\r\n        return persistenceQueue;\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]}