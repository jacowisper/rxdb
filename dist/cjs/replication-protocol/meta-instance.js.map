{"version":3,"file":"meta-instance.js","names":["_rxSchemaHelper","require","_rxStorageHelper","_index","META_INSTANCE_SCHEMA_TITLE","exports","getRxReplicationMetaInstanceSchema","replicatedDocumentsSchema","encrypted","parentPrimaryKeyLength","getLengthOfPrimaryKey","baseSchema","title","primaryKey","key","fields","separator","type","version","additionalProperties","properties","id","minLength","maxLength","isCheckpoint","enum","itemId","checkpointData","docData","isResolvedConflict","keyCompression","required","metaInstanceSchema","fillWithDefaultSettings","getAssumedMasterState","state","docIds","input","metaInstance","findDocumentsById","map","docId","useId","getComposedPrimaryKeyOfDocumentData","schema","then","metaDocs","ret","Object","values","forEach","metaDoc","metaDocument","getMetaWriteRow","newMasterDocState","previous","primaryPath","newMeta","flatCloneDocWithMeta","_attachments","_deleted","_rev","getDefaultRevision","_meta","lwt","now","createRevision","checkpointKey","document"],"sources":["../../../src/replication-protocol/meta-instance.ts"],"sourcesContent":["import {\r\n    fillWithDefaultSettings,\r\n    getComposedPrimaryKeyOfDocumentData,\r\n    getLengthOfPrimaryKey\r\n} from '../rx-schema-helper.ts';\r\nimport { flatCloneDocWithMeta } from '../rx-storage-helper.ts';\r\nimport type {\r\n    BulkWriteRow,\r\n    ById,\r\n    RxDocumentData,\r\n    RxJsonSchema,\r\n    RxStorageInstanceReplicationState,\r\n    RxStorageReplicationMeta,\r\n    WithDeleted\r\n} from '../types/index.d.ts';\r\nimport {\r\n    getDefaultRevision,\r\n    createRevision,\r\n    now\r\n} from '../plugins/utils/index.ts';\r\n\r\n\r\nexport const META_INSTANCE_SCHEMA_TITLE = 'RxReplicationProtocolMetaData';\r\n\r\nexport function getRxReplicationMetaInstanceSchema<RxDocType, CheckpointType>(\r\n    replicatedDocumentsSchema: RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    encrypted: boolean\r\n): RxJsonSchema<RxDocumentData<RxStorageReplicationMeta<RxDocType, CheckpointType>>> {\r\n    const parentPrimaryKeyLength = getLengthOfPrimaryKey(replicatedDocumentsSchema);\r\n\r\n    const baseSchema: RxJsonSchema<RxStorageReplicationMeta<RxDocType, CheckpointType>> = {\r\n        title: META_INSTANCE_SCHEMA_TITLE,\r\n        primaryKey: {\r\n            key: 'id',\r\n            fields: [\r\n                'itemId',\r\n                'isCheckpoint'\r\n            ],\r\n            separator: '|'\r\n        },\r\n        type: 'object',\r\n        version: replicatedDocumentsSchema.version,\r\n        additionalProperties: false,\r\n        properties: {\r\n            id: {\r\n                type: 'string',\r\n                minLength: 1,\r\n                // add +1 for the '|' and +1 for the 'isCheckpoint' flag\r\n                maxLength: parentPrimaryKeyLength + 2\r\n            },\r\n            isCheckpoint: {\r\n                type: 'string',\r\n                enum: [\r\n                    '0',\r\n                    '1'\r\n                ],\r\n                minLength: 1,\r\n                maxLength: 1\r\n            },\r\n            itemId: {\r\n                type: 'string',\r\n                /**\r\n                 * ensure that all values of RxStorageReplicationDirection ('DOWN' has 4 chars) fit into it\r\n                 * because checkpoints use the itemId field for that.\r\n                 */\r\n                maxLength: parentPrimaryKeyLength > 4 ? parentPrimaryKeyLength : 4\r\n            },\r\n            checkpointData: {\r\n                type: 'object',\r\n                additionalProperties: true\r\n            },\r\n            docData: {\r\n                type: 'object',\r\n                properties: replicatedDocumentsSchema.properties\r\n            },\r\n            isResolvedConflict: {\r\n                type: 'string'\r\n            }\r\n        },\r\n        keyCompression: replicatedDocumentsSchema.keyCompression,\r\n        required: [\r\n            'id',\r\n            'isCheckpoint',\r\n            'itemId'\r\n        ]\r\n    };\r\n    if (encrypted) {\r\n        baseSchema.encrypted = ['docData'];\r\n    }\r\n    const metaInstanceSchema: RxJsonSchema<RxDocumentData<RxStorageReplicationMeta<RxDocType, CheckpointType>>> = fillWithDefaultSettings(baseSchema);\r\n    return metaInstanceSchema;\r\n}\r\n\r\n\r\n\r\n/**\r\n * Returns the document states of what the fork instance\r\n * assumes to be the latest state on the master instance.\r\n */\r\nexport function getAssumedMasterState<RxDocType>(\r\n    state: RxStorageInstanceReplicationState<RxDocType>,\r\n    docIds: string[]\r\n): Promise<ById<{\r\n    docData: WithDeleted<RxDocType>;\r\n    metaDocument: RxDocumentData<RxStorageReplicationMeta<RxDocType, any>>;\r\n}>> {\r\n    return state.input.metaInstance.findDocumentsById(\r\n        docIds.map(docId => {\r\n            const useId = getComposedPrimaryKeyOfDocumentData(\r\n                state.input.metaInstance.schema,\r\n                {\r\n                    itemId: docId,\r\n                    isCheckpoint: '0'\r\n                }\r\n            );\r\n            return useId;\r\n        }),\r\n        true\r\n    ).then(metaDocs => {\r\n        const ret: {\r\n            [docId: string]: {\r\n                docData: RxDocumentData<RxDocType>;\r\n                metaDocument: RxDocumentData<RxStorageReplicationMeta<RxDocType, any>>;\r\n            };\r\n        } = {};\r\n        Object\r\n            .values(metaDocs)\r\n            .forEach((metaDoc) => {\r\n                ret[metaDoc.itemId] = {\r\n                    docData: metaDoc.docData,\r\n                    metaDocument: metaDoc\r\n                };\r\n            });\r\n\r\n        return ret;\r\n    });\r\n}\r\n\r\n\r\nexport async function getMetaWriteRow<RxDocType>(\r\n    state: RxStorageInstanceReplicationState<RxDocType>,\r\n    newMasterDocState: WithDeleted<RxDocType>,\r\n    previous?: RxDocumentData<RxStorageReplicationMeta<RxDocType, any>>,\r\n    isResolvedConflict?: string\r\n): Promise<BulkWriteRow<RxStorageReplicationMeta<RxDocType, any>>> {\r\n    const docId: string = (newMasterDocState as any)[state.primaryPath];\r\n    const newMeta: RxDocumentData<RxStorageReplicationMeta<RxDocType, any>> = previous ? flatCloneDocWithMeta(\r\n        previous\r\n    ) : {\r\n        id: '',\r\n        isCheckpoint: '0',\r\n        itemId: docId,\r\n        docData: newMasterDocState,\r\n        _attachments: {},\r\n        _deleted: false,\r\n        _rev: getDefaultRevision(),\r\n        _meta: {\r\n            lwt: 0\r\n        }\r\n    };\r\n    newMeta.docData = newMasterDocState;\r\n\r\n    /**\r\n     * Sending isResolvedConflict with the value undefined\r\n     * will throw a schema validation error because it must be either\r\n     * not set or have a string.\r\n     */\r\n    if (isResolvedConflict) {\r\n        newMeta.isResolvedConflict = isResolvedConflict;\r\n    }\r\n\r\n    newMeta._meta.lwt = now();\r\n    newMeta.id = getComposedPrimaryKeyOfDocumentData(\r\n        state.input.metaInstance.schema,\r\n        newMeta\r\n    );\r\n    newMeta._rev = createRevision(\r\n        await state.checkpointKey,\r\n        previous\r\n    );\r\n\r\n    const ret = {\r\n        previous,\r\n        document: newMeta\r\n    };\r\n\r\n    return ret;\r\n}\r\n"],"mappings":"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","ignoreList":[]}